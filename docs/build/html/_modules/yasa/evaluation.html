<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>yasa.evaluation &#8212; yasa 0.6.5 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/bootstrap-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-bootstrap.5fd3999ee7762ccc51105388f4a9d115.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../../_static/js/jquery-1.12.4.min.js"></script>
<script type="text/javascript" src="../../_static/js/jquery-fix.js"></script>
<script type="text/javascript" src="../../_static/bootstrap-3.4.1/js/bootstrap.min.js"></script>
<script type="text/javascript" src="../../_static/bootstrap-sphinx.js"></script>

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../index.html"><span><img src="../../_static/yasa_128x128.png"></span>
          yasa</a>
        <span class="navbar-text navbar-version pull-left"><b>0.6.5</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../../api.html">API</a></li>
                <li><a href="../../quickstart.html">Quickstart</a></li>
                <li><a href="../../faq.html">FAQ</a></li>
                <li><a href="../../changelog.html">What's new</a></li>
                <li><a href="../../contributing.html">Contribute</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"></ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <h1>Source code for yasa.evaluation</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">YASA code for evaluating the agreement between two scorers (e.g., human vs YASA), either at the</span>
<span class="sd">epoch-by-epoch level or at the level of summary sleep statistics.</span>

<span class="sd">Analyses are influenced by the standardized framework proposed in Menghini et al., 2021, SLEEP.</span>
<span class="sd">See the following resources:</span>
<span class="sd">- https://doi.org/10.1093/sleep/zsaa170</span>
<span class="sd">- https://sri-human-sleep.github.io/sleep-trackers-performance</span>
<span class="sd">- https://github.com/SRI-human-sleep/sleep-trackers-performance</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">logging</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">scipy.stats</span> <span class="k">as</span> <span class="nn">sps</span>
<span class="kn">import</span> <span class="nn">sklearn.metrics</span> <span class="k">as</span> <span class="nn">skm</span>


<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;yasa&quot;</span><span class="p">)</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;EpochByEpochAgreement&quot;</span><span class="p">,</span>
    <span class="s2">&quot;SleepStatsAgreement&quot;</span><span class="p">,</span>
<span class="p">]</span>


<span class="c1">################################################################################</span>
<span class="c1"># EPOCH BY EPOCH</span>
<span class="c1">################################################################################</span>


<div class="viewcode-block" id="EpochByEpochAgreement"><a class="viewcode-back" href="../../generated/yasa.EpochByEpochAgreement.html#yasa.EpochByEpochAgreement">[docs]</a><span class="k">class</span> <span class="nc">EpochByEpochAgreement</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Evaluate agreement between two hypnograms or two collections of hypnograms.</span>

<span class="sd">    Evaluation includes averaged agreement scores, one-vs-rest agreement scores, agreement scores</span>
<span class="sd">    summarized across all sleep and summarized by sleep stage, and various plotting options to</span>
<span class="sd">    visualize the two hypnograms simultaneously. See examples for more detail.</span>

<span class="sd">    .. versionadded:: 0.7.0</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ref_hyps : iterable of :py:class:`yasa.Hypnogram`</span>
<span class="sd">        A collection of reference hypnograms (i.e., those considered ground-truth).</span>

<span class="sd">        Each :py:class:`yasa.Hypnogram` in ``ref_hyps`` must have the same</span>
<span class="sd">        :py:attr:`~yasa.Hypnogram.scorer`.</span>

<span class="sd">        If a ``dict``, key values are use to generate unique sleep session IDs. If any other</span>
<span class="sd">        iterable (e.g., ``list`` or ``tuple``), then unique sleep session IDs are automatically</span>
<span class="sd">        generated.</span>
<span class="sd">    obs_hyps : iterable of :py:class:`yasa.Hypnogram`</span>
<span class="sd">        A collection of observed hypnograms (i.e., those to be evaluated).</span>

<span class="sd">        Each :py:class:`yasa.Hypnogram` in ``obs_hyps`` must have the same</span>
<span class="sd">        :py:attr:`~yasa.Hypnogram.scorer`, and this scorer must be different than the scorer of</span>
<span class="sd">        hypnograms in ``ref_hyps``.</span>

<span class="sd">        If a ``dict``, key values must match those of ``ref_hyps``.</span>

<span class="sd">    .. important::</span>
<span class="sd">        It is assumed that the order of hypnograms are the same in ``ref_hyps`` and ``obs_hyps``.</span>
<span class="sd">        For example, the third hypnogram in ``ref_hyps`` and ``obs_hyps`` must come from the same</span>
<span class="sd">        sleep session, and they must only differ in that they have different scorers.</span>

<span class="sd">    .. seealso:: For comparing just two hypnograms, use :py:meth:`yasa.Hynogram.evaluate`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Many steps here are influenced by guidelines proposed in Menghini et al., 2021 [Menghini2021]_.</span>
<span class="sd">    See https://sri-human-sleep.github.io/sleep-trackers-performance/AnalyticalPipeline_v1.0.0.html</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [Menghini2021] Menghini, L., Cellini, N., Goldstone, A., Baker, F. C., &amp; de Zambotti, M.</span>
<span class="sd">                      (2021). A standardized framework for testing the performance of sleep-tracking</span>
<span class="sd">                      technology: step-by-step guidelines and open-source code. SLEEP, 44(2),</span>
<span class="sd">                      zsaa170. https://doi.org/10.1093/sleep/zsaa170</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import yasa</span>
<span class="sd">    &gt;&gt;&gt; ref_hyps = [yasa.simulate_hypnogram(tib=600, scorer=&quot;Human&quot;, seed=i) for i in range(10)]</span>
<span class="sd">    &gt;&gt;&gt; obs_hyps = [h.simulate_similar(scorer=&quot;YASA&quot;, seed=i) for i, h in enumerate(ref_hyps)]</span>
<span class="sd">    &gt;&gt;&gt; ebe = yasa.EpochByEpochAgreement(ref_hyps, obs_hyps)</span>
<span class="sd">    &gt;&gt;&gt; agr = ebe.get_agreement()</span>
<span class="sd">    &gt;&gt;&gt; agr.head(5).round(2)</span>
<span class="sd">              accuracy  balanced_acc  kappa   mcc  precision  recall     f1</span>
<span class="sd">    sleep_id</span>
<span class="sd">    1             0.31          0.26   0.07  0.07       0.31    0.31   0.31</span>
<span class="sd">    2             0.33          0.33   0.14  0.14       0.35    0.33   0.34</span>
<span class="sd">    3             0.35          0.24   0.06  0.06       0.35    0.35   0.35</span>
<span class="sd">    4             0.22          0.21   0.01  0.01       0.21    0.22   0.21</span>
<span class="sd">    5             0.21          0.17  -0.06 -0.06       0.20    0.21   0.21</span>

<span class="sd">    &gt;&gt;&gt; ebe.get_agreement_bystage().head(12).round(3)</span>
<span class="sd">                    fbeta  precision  recall  support</span>
<span class="sd">    stage sleep_id</span>
<span class="sd">    WAKE  1         0.391      0.371   0.413    189.0</span>
<span class="sd">          2         0.299      0.276   0.326    184.0</span>
<span class="sd">          3         0.234      0.204   0.275    255.0</span>
<span class="sd">          4         0.268      0.285   0.252    321.0</span>
<span class="sd">          5         0.228      0.230   0.227    181.0</span>
<span class="sd">          6         0.407      0.384   0.433    284.0</span>
<span class="sd">          7         0.362      0.296   0.467    287.0</span>
<span class="sd">          8         0.298      0.519   0.209    263.0</span>
<span class="sd">          9         0.210      0.191   0.233    313.0</span>
<span class="sd">          10        0.369      0.420   0.329    362.0</span>
<span class="sd">    N1    1         0.185      0.185   0.185    124.0</span>
<span class="sd">          2         0.121      0.131   0.112    160.0</span>

<span class="sd">    &gt;&gt;&gt; ebe.get_confusion_matrix(sleep_id=1)</span>
<span class="sd">    YASA   WAKE  N1   N2  N3  REM</span>
<span class="sd">    Human</span>
<span class="sd">    WAKE     78  24   50   3   34</span>
<span class="sd">    N1       23  23   43  15   20</span>
<span class="sd">    N2       60  58  183  43  139</span>
<span class="sd">    N3       30  10   50   5   32</span>
<span class="sd">    REM      19   9  121  50   78</span>

<span class="sd">    .. plot::</span>

<span class="sd">        &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">        &gt;&gt;&gt; fig, ax = plt.subplots(figsize=(6, 3), constrained_layout=True)</span>
<span class="sd">        &gt;&gt;&gt; ebe.plot_hypnograms(sleep_id=10)</span>

<span class="sd">    .. plot::</span>

<span class="sd">        &gt;&gt;&gt; fig, ax = plt.subplots(figsize=(6, 3))</span>
<span class="sd">        &gt;&gt;&gt; ebe.plot_hypnograms(</span>
<span class="sd">        &gt;&gt;&gt;     sleep_id=8, ax=ax, obs_kwargs={&quot;color&quot;: &quot;red&quot;, &quot;lw&quot;: 2, &quot;ls&quot;: &quot;dotted&quot;}</span>
<span class="sd">        &gt;&gt;&gt; )</span>
<span class="sd">        &gt;&gt;&gt; plt.tight_layout()</span>

<span class="sd">    .. plot::</span>

<span class="sd">        &gt;&gt;&gt; session = 8</span>
<span class="sd">        &gt;&gt;&gt; fig, ax = plt.subplots(figsize=(6.5, 2.5), constrained_layout=True)</span>
<span class="sd">        &gt;&gt;&gt; style_a = dict(alpha=1, lw=2.5, ls=&quot;solid&quot;, color=&quot;gainsboro&quot;, label=&quot;Michel&quot;)</span>
<span class="sd">        &gt;&gt;&gt; style_b = dict(alpha=1, lw=2.5, ls=&quot;solid&quot;, color=&quot;cornflowerblue&quot;, label=&quot;Jouvet&quot;)</span>
<span class="sd">        &gt;&gt;&gt; legend_style = dict(</span>
<span class="sd">        &gt;&gt;&gt;     title=&quot;Scorer&quot;, frameon=False, ncol=2, loc=&quot;lower center&quot;, bbox_to_anchor=(0.5, 0.9)</span>
<span class="sd">        &gt;&gt;&gt; )</span>
<span class="sd">        &gt;&gt;&gt; ax = ebe.plot_hypnograms(</span>
<span class="sd">        &gt;&gt;&gt;     sleep_id=session, ref_kwargs=style_a, obs_kwargs=style_b, legend=legend_style, ax=ax</span>
<span class="sd">        &gt;&gt;&gt; )</span>
<span class="sd">        &gt;&gt;&gt; acc = ebe.get_agreement().multiply(100).at[session, &quot;accuracy&quot;]</span>
<span class="sd">        &gt;&gt;&gt; ax.text(</span>
<span class="sd">        &gt;&gt;&gt;     0.01, 1, f&quot;Accuracy = {acc:.0f}%&quot;, ha=&quot;left&quot;, va=&quot;bottom&quot;, transform=ax.transAxes</span>
<span class="sd">        &gt;&gt;&gt; )</span>

<span class="sd">    When comparing only 2 hypnograms, use the :py:meth:`~yasa.Hynogram.evaluate` method:</span>

<span class="sd">    &gt;&gt;&gt; hypno_a = yasa.simulate_hypnogram(tib=90, scorer=&quot;RaterA&quot;, seed=8)</span>
<span class="sd">    &gt;&gt;&gt; hypno_b = hypno_a.simulate_similar(scorer=&quot;RaterB&quot;, seed=9)</span>
<span class="sd">    &gt;&gt;&gt; ebe = hypno_a.evaluate(hypno_b)</span>
<span class="sd">    &gt;&gt;&gt; ebe.get_confusion_matrix()</span>
<span class="sd">    RaterB  WAKE  N1  N2  N3</span>
<span class="sd">    RaterA</span>
<span class="sd">    WAKE      71   2  20   8</span>
<span class="sd">    N1         1   0   9   0</span>
<span class="sd">    N2        12   4  25   0</span>
<span class="sd">    N3        24   0   1   3</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="EpochByEpochAgreement.__init__"><a class="viewcode-back" href="../../generated/yasa.EpochByEpochAgreement.html#yasa.EpochByEpochAgreement.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ref_hyps</span><span class="p">,</span> <span class="n">obs_hyps</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">yasa.hypno</span> <span class="kn">import</span> <span class="n">Hypnogram</span>  <span class="c1"># Avoiding circular import, bc hypno imports this class</span>

        <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ref_hyps</span><span class="p">,</span> <span class="s2">&quot;__iter__&quot;</span><span class="p">),</span> <span class="s2">&quot;`ref_hyps` must be a an iterable&quot;</span>
        <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obs_hyps</span><span class="p">,</span> <span class="s2">&quot;__iter__&quot;</span><span class="p">),</span> <span class="s2">&quot;`obs_hyps` must be a an iterable&quot;</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">ref_hyps</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">(</span><span class="n">obs_hyps</span><span class="p">),</span> <span class="s2">&quot;`ref_hyps` and `obs_hyps` must be the same type&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref_hyps</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span>
            <span class="n">obs_hyps</span>
        <span class="p">),</span> <span class="s2">&quot;`ref_hyps` and `obs_hyps` must have the same number of hypnograms&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ref_hyps</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="c1"># If user provides dictionaries, split into sleep IDs and hypnograms</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="n">ref_hyps</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">==</span> <span class="n">obs_hyps</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="p">),</span> <span class="s2">&quot;keys in `ref_hyps` must be the same as keys in `obs_hyps`&quot;</span>
            <span class="n">sleep_ids</span><span class="p">,</span> <span class="n">ref_hyps</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">ref_hyps</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
            <span class="n">obs_hyps</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">obs_hyps</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Create hypnogram_ids</span>
            <span class="n">sleep_ids</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref_hyps</span><span class="p">)))</span>

        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">hyp</span><span class="p">,</span> <span class="n">Hypnogram</span><span class="p">)</span> <span class="k">for</span> <span class="n">hyp</span> <span class="ow">in</span> <span class="n">ref_hyps</span> <span class="o">+</span> <span class="n">obs_hyps</span>
        <span class="p">),</span> <span class="s2">&quot;`ref_hyps` and `obs_hyps` must only contain YASA hypnograms&quot;</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span>
            <span class="n">h</span><span class="o">.</span><span class="n">scorer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">ref_hyps</span> <span class="o">+</span> <span class="n">obs_hyps</span>
        <span class="p">),</span> <span class="s2">&quot;all hypnograms in `ref_hyps` and `obs_hyps` must have a scorer name&quot;</span>
        <span class="k">for</span> <span class="n">h1</span><span class="p">,</span> <span class="n">h2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">((</span><span class="n">ref_hyps</span> <span class="o">+</span> <span class="n">obs_hyps</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="n">ref_hyps</span> <span class="o">+</span> <span class="n">obs_hyps</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="k">assert</span> <span class="n">h1</span><span class="o">.</span><span class="n">freq</span> <span class="o">==</span> <span class="n">h2</span><span class="o">.</span><span class="n">freq</span><span class="p">,</span> <span class="s2">&quot;all hypnograms must have the same freq&quot;</span>
            <span class="k">assert</span> <span class="n">h1</span><span class="o">.</span><span class="n">labels</span> <span class="o">==</span> <span class="n">h2</span><span class="o">.</span><span class="n">labels</span><span class="p">,</span> <span class="s2">&quot;all hypnograms must have the same labels&quot;</span>
            <span class="k">assert</span> <span class="n">h1</span><span class="o">.</span><span class="n">mapping</span> <span class="o">==</span> <span class="n">h2</span><span class="o">.</span><span class="n">mapping</span><span class="p">,</span> <span class="s2">&quot;all hypnograms must have the same mapping&quot;</span>
            <span class="k">assert</span> <span class="n">h1</span><span class="o">.</span><span class="n">n_stages</span> <span class="o">==</span> <span class="n">h2</span><span class="o">.</span><span class="n">n_stages</span><span class="p">,</span> <span class="s2">&quot;all hypnograms must have the same n_stages&quot;</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span>
            <span class="n">h1</span><span class="o">.</span><span class="n">scorer</span> <span class="o">==</span> <span class="n">h2</span><span class="o">.</span><span class="n">scorer</span> <span class="k">for</span> <span class="n">h1</span><span class="p">,</span> <span class="n">h2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ref_hyps</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">ref_hyps</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="p">),</span> <span class="s2">&quot;all `ref_hyps` must have the same scorer&quot;</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span>
            <span class="n">h1</span><span class="o">.</span><span class="n">scorer</span> <span class="o">==</span> <span class="n">h2</span><span class="o">.</span><span class="n">scorer</span> <span class="k">for</span> <span class="n">h1</span><span class="p">,</span> <span class="n">h2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">obs_hyps</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">obs_hyps</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="p">),</span> <span class="s2">&quot;all `obs_hyps` must have the same scorer&quot;</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span>
            <span class="n">h1</span><span class="o">.</span><span class="n">scorer</span> <span class="o">!=</span> <span class="n">h2</span><span class="o">.</span><span class="n">scorer</span> <span class="k">for</span> <span class="n">h1</span><span class="p">,</span> <span class="n">h2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ref_hyps</span><span class="p">,</span> <span class="n">obs_hyps</span><span class="p">)</span>
        <span class="p">),</span> <span class="s2">&quot;each `ref_hyps` and `obs_hyps` pair must have unique scorers&quot;</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span>
            <span class="n">h1</span><span class="o">.</span><span class="n">n_epochs</span> <span class="o">==</span> <span class="n">h2</span><span class="o">.</span><span class="n">n_epochs</span> <span class="k">for</span> <span class="n">h1</span><span class="p">,</span> <span class="n">h2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ref_hyps</span><span class="p">,</span> <span class="n">obs_hyps</span><span class="p">)</span>
        <span class="p">),</span> <span class="s2">&quot;each `ref_hyps` and `obs_hyps` pair must have the same n_epochs&quot;</span>
        <span class="c1"># Convert ref_hyps and obs_hyps to dictionaries with sleep_id keys and hypnogram values</span>
        <span class="n">ref_hyps</span> <span class="o">=</span> <span class="p">{</span><span class="n">s</span><span class="p">:</span> <span class="n">h</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sleep_ids</span><span class="p">,</span> <span class="n">ref_hyps</span><span class="p">)}</span>
        <span class="n">obs_hyps</span> <span class="o">=</span> <span class="p">{</span><span class="n">s</span><span class="p">:</span> <span class="n">h</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sleep_ids</span><span class="p">,</span> <span class="n">obs_hyps</span><span class="p">)}</span>

        <span class="c1"># Merge all hypnograms into a single MultiIndexed dataframe</span>
        <span class="n">ref</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">({</span><span class="n">s</span><span class="p">:</span> <span class="n">h</span><span class="o">.</span><span class="n">as_int</span><span class="p">()},</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;sleep_id&quot;</span><span class="p">])</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">ref_hyps</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        <span class="n">obs</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">({</span><span class="n">s</span><span class="p">:</span> <span class="n">h</span><span class="o">.</span><span class="n">as_int</span><span class="p">()},</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;sleep_id&quot;</span><span class="p">])</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">obs_hyps</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">ref</span><span class="p">,</span> <span class="n">obs</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Generate some mapping dictionaries to be used later in class methods</span>
        <span class="n">skm_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>  <span class="c1"># all unique YASA integer codes in this hypno</span>
        <span class="n">skm2yasa_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">l</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">skm_labels</span><span class="p">)}</span>  <span class="c1"># skm order to YASA integers</span>
        <span class="n">yasa2yasa_map</span> <span class="o">=</span> <span class="n">ref_hyps</span><span class="p">[</span><span class="n">sleep_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">mapping_int</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># YASA integer to YASA string</span>

        <span class="c1"># Set attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sleep_ids</span> <span class="o">=</span> <span class="n">sleep_ids</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ref_hyps</span> <span class="o">=</span> <span class="n">ref_hyps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_obs_hyps</span> <span class="o">=</span> <span class="n">obs_hyps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ref_scorer</span> <span class="o">=</span> <span class="n">ref_hyps</span><span class="p">[</span><span class="n">sleep_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">scorer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_obs_scorer</span> <span class="o">=</span> <span class="n">obs_hyps</span><span class="p">[</span><span class="n">sleep_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">scorer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_skm_labels</span> <span class="o">=</span> <span class="n">skm_labels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_skm2yasa_map</span> <span class="o">=</span> <span class="n">skm2yasa_map</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_yasa2yasa_map</span> <span class="o">=</span> <span class="n">yasa2yasa_map</span></div>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># TODO v0.8: Keep only the text between &lt; and &gt;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;s&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_sleeps</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;&lt;EpochByEpochAgreement | Observed hypnogram</span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="s2"> scored by </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">obs_scorer</span><span class="si">}</span><span class="s2"> &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;evaluated against reference hypnogram</span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="s2"> scored by </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_scorer</span><span class="si">}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_sleeps</span><span class="si">}</span><span class="s2"> sleep session</span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="s2">&gt;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot; - Use `.get_agreement()` to get agreement measures as a pandas DataFrame or Series</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot; - Use `.plot_hypnograms()` to plot two overlaid hypnograms</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;See the online documentation for more details.&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A :py:class:`pandas.DataFrame` including all hypnograms.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_sleeps</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The number of unique sleep sessions.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sleep_ids</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ref_scorer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The name of the reference scorer.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ref_scorer</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">obs_scorer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The name of the observed scorer.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obs_scorer</span>

<div class="viewcode-block" id="EpochByEpochAgreement.multi_scorer"><a class="viewcode-back" href="../../generated/yasa.EpochByEpochAgreement.html#yasa.EpochByEpochAgreement.multi_scorer">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">multi_scorer</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">scorers</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute multiple agreement scores from a 2-column dataframe (an optional 3rd column may</span>
<span class="sd">        contain sample weights).</span>

<span class="sd">        This function offers convenience when calculating multiple agreement scores using</span>
<span class="sd">        :py:meth:`pandas.DataFrame.groupby.apply`. Scikit-learn doesn&#39;t include a function that</span>
<span class="sd">        returns multiple scores, and the GroupBy implementation of ``apply`` in pandas does not</span>
<span class="sd">        accept multiple functions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        df : :py:class:`pandas.DataFrame`</span>
<span class="sd">            A :py:class:`~pandas.DataFrame` with 2 columns and length of *n_samples*.</span>
<span class="sd">            The first column contains reference values and second column contains observed values.</span>
<span class="sd">            If a third column, it must contain sample weights to be passed to underlying</span>
<span class="sd">            :py:mod:`sklearn.metrics` functions as ``sample_weight`` where applicable.</span>
<span class="sd">        scorers : dictionary</span>
<span class="sd">            The scorers to be used for evaluating agreement. A dictionary with scorer names (str) as</span>
<span class="sd">            keys and functions as values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        scores : dict</span>
<span class="sd">            A dictionary with scorer names (``str``) as keys and scores (``float``) as values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">),</span> <span class="s2">&quot;`df` must be a pandas DataFrame&quot;</span>
        <span class="k">assert</span> <span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="s2">&quot;`df` must have either 2 or 3 columns&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scorers</span><span class="p">,</span> <span class="nb">dict</span><span class="p">),</span> <span class="s2">&quot;`scorers` must be a dictionary&quot;</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">callable</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">scorers</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">),</span> <span class="s2">&quot;Each key of `scorers` must be a string, and each value must be a callable function&quot;</span>
        <span class="k">if</span> <span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">true</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">df</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">true</span><span class="p">,</span> <span class="n">pred</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">df</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>  <span class="c1"># Same as (df[&quot;col1&quot;], df[&quot;col2&quot;]) but teensy bit faster</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="p">{</span><span class="n">s</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">true</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">scorers</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">return</span> <span class="n">scores</span></div>

<div class="viewcode-block" id="EpochByEpochAgreement.get_agreement"><a class="viewcode-back" href="../../generated/yasa.EpochByEpochAgreement.html#yasa.EpochByEpochAgreement.get_agreement">[docs]</a>    <span class="k">def</span> <span class="nf">get_agreement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scorers</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a :py:class:`pandas.DataFrame` of weighted (i.e., averaged) agreement scores.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        self : :py:class:`~yasa.evaluation.EpochByEvaluation`</span>
<span class="sd">            A :py:class:`~yasa.evaluation.EpochByEvaluation` instance.</span>
<span class="sd">        sample_weight : None or :py:class:`pandas.Series`</span>
<span class="sd">            Sample weights passed to underlying :py:mod:`sklearn.metrics` functions where possible.</span>
<span class="sd">            If a :py:class:`pandas.Series`, the index must match exactly that of</span>
<span class="sd">            :py:attr:`~yasa.Hypnogram.data`.</span>
<span class="sd">        scorers : None, list, or dictionary</span>
<span class="sd">            The scorers to be used for evaluating agreement. If None (default), default scorers are</span>
<span class="sd">            used. If a list, the list must contain strings that represent metrics from the sklearn</span>
<span class="sd">            metrics module (e.g., ``accuracy``, ``precision``). If more customization is desired, a</span>
<span class="sd">            dictionary can be passed with scorer names (str) as keys and custom functions as values.</span>
<span class="sd">            The custom functions should take 3 positional arguments (true values, predicted values,</span>
<span class="sd">            and sample weights).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        agreement : :py:class:`pandas.DataFrame`</span>
<span class="sd">            A :py:class:`~pandas.DataFrame` with agreement metrics as columns and sessions as rows.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">sample_weight</span><span class="p">,</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)</span>
        <span class="p">),</span> <span class="s2">&quot;`sample_weight` must be None or pandas Series&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scorers</span><span class="p">,</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">dict</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scorers</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">scorers</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scorers</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">callable</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">scorers</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">scorers</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Create dictionary of default scorer functions</span>
            <span class="n">scorers</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;accuracy&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">w</span><span class="p">:</span> <span class="n">skm</span><span class="o">.</span><span class="n">accuracy_score</span><span class="p">(</span>
                    <span class="n">t</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="n">w</span>
                <span class="p">),</span>
                <span class="s2">&quot;balanced_acc&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">w</span><span class="p">:</span> <span class="n">skm</span><span class="o">.</span><span class="n">balanced_accuracy_score</span><span class="p">(</span>
                    <span class="n">t</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">adjusted</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="n">w</span>
                <span class="p">),</span>
                <span class="s2">&quot;kappa&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">w</span><span class="p">:</span> <span class="n">skm</span><span class="o">.</span><span class="n">cohen_kappa_score</span><span class="p">(</span>
                    <span class="n">t</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="n">w</span>
                <span class="p">),</span>
                <span class="s2">&quot;mcc&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">w</span><span class="p">:</span> <span class="n">skm</span><span class="o">.</span><span class="n">matthews_corrcoef</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="n">w</span><span class="p">),</span>
                <span class="s2">&quot;precision&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">w</span><span class="p">:</span> <span class="n">skm</span><span class="o">.</span><span class="n">precision_score</span><span class="p">(</span>
                    <span class="n">t</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s2">&quot;weighted&quot;</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="n">zero_division</span><span class="o">=</span><span class="mi">0</span>
                <span class="p">),</span>
                <span class="s2">&quot;recall&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">w</span><span class="p">:</span> <span class="n">skm</span><span class="o">.</span><span class="n">recall_score</span><span class="p">(</span>
                    <span class="n">t</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s2">&quot;weighted&quot;</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="n">zero_division</span><span class="o">=</span><span class="mi">0</span>
                <span class="p">),</span>
                <span class="s2">&quot;f1&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">w</span><span class="p">:</span> <span class="n">skm</span><span class="o">.</span><span class="n">f1_score</span><span class="p">(</span>
                    <span class="n">t</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s2">&quot;weighted&quot;</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="n">zero_division</span><span class="o">=</span><span class="mi">0</span>
                <span class="p">),</span>
            <span class="p">}</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scorers</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="c1"># Convert the list to a dictionary of sklearn scorers</span>
            <span class="n">scorers</span> <span class="o">=</span> <span class="p">{</span><span class="n">s</span><span class="p">:</span> <span class="n">skm</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="s2">_scorer&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">scorers</span><span class="p">}</span>
        <span class="c1"># Make a copy of data since weights series might be added to it</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">sample_weight</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">sample_weight</span><span class="o">.</span><span class="n">index</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="p">(</span>
                <span class="s2">&quot;If not `None`, `sample_weight` Series must be a pandas Series with the same index &quot;</span>
                <span class="s2">&quot;as `self.data`&quot;</span>
            <span class="p">)</span>
            <span class="c1"># Add weights as a third column for multi_scorer to use</span>
            <span class="n">df</span><span class="p">[</span><span class="s2">&quot;weights&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sample_weight</span>
        <span class="c1"># Get individual-level averaged/weighted agreement scores</span>
        <span class="n">agreement</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">multi_scorer</span><span class="p">,</span> <span class="n">scorers</span><span class="o">=</span><span class="n">scorers</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)</span>
        <span class="c1"># Set attribute for later access</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_agreement</span> <span class="o">=</span> <span class="n">agreement</span>
        <span class="c1"># Convert to Series if just one session being evaluated</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_sleeps</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">agreement</span> <span class="o">=</span> <span class="n">agreement</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s2">&quot;agreement&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">agreement</span></div>

<div class="viewcode-block" id="EpochByEpochAgreement.get_agreement_bystage"><a class="viewcode-back" href="../../generated/yasa.EpochByEpochAgreement.html#yasa.EpochByEpochAgreement.get_agreement_bystage">[docs]</a>    <span class="k">def</span> <span class="nf">get_agreement_bystage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a :py:class:`pandas.DataFrame` of unweighted (i.e., one-vs-rest) agreement scores.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        self : :py:class:`~yasa.evaluation.EpochByEvaluation`</span>
<span class="sd">            A :py:class:`~yasa.evaluation.EpochByEvaluation` instance.</span>
<span class="sd">        beta : float</span>
<span class="sd">            See :py:func:`sklearn.metrics.precision_recall_fscore_support`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        agreement : :py:class:`pandas.DataFrame`</span>
<span class="sd">            A :py:class:`~pandas.DataFrame` with agreement metrics as columns and a</span>
<span class="sd">            :py:class:`~pandas.MultiIndex` with session and sleep stage as rows.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">scorer</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">skm</span><span class="o">.</span><span class="n">precision_recall_fscore_support</span><span class="p">(</span>
                <span class="o">*</span><span class="n">df</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_skm_labels</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">zero_division</span><span class="o">=</span><span class="mi">0</span>
            <span class="p">)</span>

        <span class="n">agreement</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
            <span class="c1"># Get precision, recall, f1, and support for each individual sleep session</span>
            <span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">scorer</span><span class="p">)</span>
            <span class="c1"># Unpack arrays</span>
            <span class="o">.</span><span class="n">explode</span><span class="p">()</span>
            <span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)</span>
            <span class="c1"># Add metric labels column and prepend it to index, creating MultiIndex</span>
            <span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">metric</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;precision&quot;</span><span class="p">,</span> <span class="s2">&quot;recall&quot;</span><span class="p">,</span> <span class="s2">&quot;fbeta&quot;</span><span class="p">,</span> <span class="s2">&quot;support&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_sleeps</span><span class="p">)</span>
            <span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;metric&quot;</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># Convert stage column names to string labels</span>
            <span class="o">.</span><span class="n">rename_axis</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="s2">&quot;stage&quot;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_skm2yasa_map</span><span class="p">)</span>
            <span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_yasa2yasa_map</span><span class="p">)</span>
            <span class="c1"># Remove all-zero columns (i.e., stages that were not present in the hypnogram)</span>
            <span class="o">.</span><span class="n">pipe</span><span class="p">(</span><span class="k">lambda</span> <span class="n">df</span><span class="p">:</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">df</span><span class="o">.</span><span class="n">any</span><span class="p">()])</span>
            <span class="c1"># Reshape so metrics are columns</span>
            <span class="o">.</span><span class="n">stack</span><span class="p">()</span>
            <span class="o">.</span><span class="n">unstack</span><span class="p">(</span><span class="s2">&quot;metric&quot;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">rename_axis</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
            <span class="c1"># Swap MultiIndex levels and sort so stages are in standard YASA order</span>
            <span class="o">.</span><span class="n">swaplevel</span><span class="p">()</span>
            <span class="o">.</span><span class="n">sort_index</span><span class="p">(</span>
                <span class="n">level</span><span class="o">=</span><span class="s2">&quot;stage&quot;</span><span class="p">,</span>
                <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">y</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_yasa2yasa_map</span><span class="o">.</span><span class="n">values</span><span class="p">())</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">y</span><span class="p">)),</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="c1"># Set attribute for later access</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_agreement_bystage</span> <span class="o">=</span> <span class="n">agreement</span>
        <span class="c1"># Remove the MultiIndex if just one session being evaluated</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_sleeps</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">agreement</span> <span class="o">=</span> <span class="n">agreement</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">agreement</span></div>

<div class="viewcode-block" id="EpochByEpochAgreement.get_confusion_matrix"><a class="viewcode-back" href="../../generated/yasa.EpochByEpochAgreement.html#yasa.EpochByEpochAgreement.get_confusion_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">get_confusion_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sleep_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">agg_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a ``ref_hyp``/``obs_hyp``confusion matrix from either a single session or all</span>
<span class="sd">        sessions concatenated together.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        self : :py:class:`yasa.EpochByEpochAgreement`</span>
<span class="sd">            A :py:class:`yasa.EpochByEpochAgreement` instance.</span>
<span class="sd">        sleep_id : None or a valid sleep ID</span>
<span class="sd">            If None (default), cross-tabulation is derived from the entire group dataset.</span>
<span class="sd">            If a valid sleep ID, cross-tabulation is derived using only the reference and observed</span>
<span class="sd">            scored hypnograms from that sleep session.</span>
<span class="sd">        agg_func : None or str</span>
<span class="sd">            If None (default), group results returns a :py:class:`~pandas.DataFrame` complete with</span>
<span class="sd">            all individual session results. If not None, group results returns a</span>
<span class="sd">            :py:class:`~pandas.DataFrame` aggregated across sessions where ``agg_func`` is passed as</span>
<span class="sd">            ``func`` parameter in :py:meth:`pandas.DataFrame.groupby.agg`. For example, set</span>
<span class="sd">            ``agg_func=&quot;sum&quot;`` to get a single confusion matrix across all epochs that does not take</span>
<span class="sd">            session into account.</span>
<span class="sd">        **kwargs : key, value pairs</span>
<span class="sd">            Additional keyword arguments are passed to :py:func:`sklearn.metrics.confusion_matrix`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        conf_matr : :py:class:`pandas.DataFrame`</span>
<span class="sd">            A confusion matrix with stages from the reference scorer as indices and stages from the</span>
<span class="sd">            test scorer as columns.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import yasa</span>
<span class="sd">        &gt;&gt;&gt; ref_hyps = [yasa.simulate_hypnogram(tib=90, scorer=&quot;Rater1&quot;, seed=i) for i in range(3)]</span>
<span class="sd">        &gt;&gt;&gt; obs_hyps = [h.simulate_similar(scorer=&quot;Rater2&quot;, seed=i) for i, h in enumerate(ref_hyps)]</span>
<span class="sd">        &gt;&gt;&gt; ebe = yasa.EpochByEpochAgreement(ref_hyps, obs_hyps)</span>
<span class="sd">        &gt;&gt;&gt; ebe.get_confusion_matrix(sleep_id=2)</span>
<span class="sd">        Rater2  WAKE  N1  N2  N3  REM</span>
<span class="sd">        Rater1</span>
<span class="sd">        WAKE       1   2  23   0    0</span>
<span class="sd">        N1         0   9  13   0    0</span>
<span class="sd">        N2         0   6  71   0    0</span>
<span class="sd">        N3         0  13  42   0    0</span>
<span class="sd">        REM        0   0   0   0    0</span>

<span class="sd">        &gt;&gt;&gt; ebe.get_confusion_matrix()</span>
<span class="sd">        Rater2           WAKE  N1  N2  N3  REM</span>
<span class="sd">        sleep_id Rater1</span>
<span class="sd">        1        WAKE      30   0   3   0   35</span>
<span class="sd">                 N1         3   2   7   0    0</span>
<span class="sd">                 N2        21  12   7   0    4</span>
<span class="sd">                 N3         0   0   0   0    0</span>
<span class="sd">                 REM        2   8  29   0   17</span>
<span class="sd">        2        WAKE       1   2  23   0    0</span>
<span class="sd">                 N1         0   9  13   0    0</span>
<span class="sd">                 N2         0   6  71   0    0</span>
<span class="sd">                 N3         0  13  42   0    0</span>
<span class="sd">                 REM        0   0   0   0    0</span>
<span class="sd">        3        WAKE      16   0   7  19   19</span>
<span class="sd">                 N1         0   7   2   0    5</span>
<span class="sd">                 N2         0  10  12   7    5</span>
<span class="sd">                 N3         0   0  16  11    0</span>
<span class="sd">                 REM        0  15  11  18    0</span>

<span class="sd">        &gt;&gt;&gt; ebe.get_confusion_matrix(agg_func=&quot;sum&quot;)</span>
<span class="sd">        Rater2  WAKE  N1  N2  N3  REM</span>
<span class="sd">        Rater1</span>
<span class="sd">        WAKE      47   2  33  19   54</span>
<span class="sd">        N1         3  18  22   0    5</span>
<span class="sd">        N2        21  28  90   7    9</span>
<span class="sd">        N3         0  13  58  11    0</span>
<span class="sd">        REM        2  23  40  18   17</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">sleep_id</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">sleep_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sleep_ids</span>
        <span class="p">),</span> <span class="s2">&quot;`sleep_id` must be None or a valid sleep ID&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">agg_func</span><span class="p">,</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="nb">str</span><span class="p">)),</span> <span class="s2">&quot;`agg_func` must be None or a str&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_sleeps</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">sleep_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="n">agg_func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">),</span> <span class="s2">&quot;`agg_func` must be None if plotting a single session.&quot;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;labels&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skm_labels</span><span class="p">}</span> <span class="o">|</span> <span class="n">kwargs</span>
        <span class="c1"># Generate a DataFrame with a confusion matrix for each session</span>
        <span class="c1">#   Seems easier to just generate this whole thing and then either</span>
        <span class="c1">#   extract a single one or aggregate across them all, depending on user request</span>
        <span class="n">confusion_matrices</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
            <span class="c1"># Get confusion matrix for each individual sleep session</span>
            <span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">df</span><span class="p">:</span> <span class="n">skm</span><span class="o">.</span><span class="n">confusion_matrix</span><span class="p">(</span><span class="o">*</span><span class="n">df</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
            <span class="c1"># Expand results matrix out from single cell</span>
            <span class="o">.</span><span class="n">explode</span><span class="p">()</span>
            <span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)</span>
            <span class="c1"># Convert to MultiIndex with reference scorer as new level</span>
            <span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_scorer</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skm_labels</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_sleeps</span><span class="p">})</span>
            <span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_scorer</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="o">.</span><span class="n">rename_axis</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">obs_scorer</span><span class="p">)</span>
            <span class="c1"># Convert sleep stage columns and indices to strings</span>
            <span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_skm2yasa_map</span><span class="p">)</span>
            <span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_yasa2yasa_map</span><span class="p">)</span>
            <span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_skm2yasa_map</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_scorer</span><span class="p">)</span>
            <span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_yasa2yasa_map</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_scorer</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_sleeps</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># If just one session, use the only session ID as the key, for simplified returned df</span>
            <span class="n">sleep_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sleep_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">sleep_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">agg_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">mat</span> <span class="o">=</span> <span class="n">confusion_matrices</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mat</span> <span class="o">=</span> <span class="n">confusion_matrices</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_scorer</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="n">agg_func</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mat</span> <span class="o">=</span> <span class="n">confusion_matrices</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sleep_id</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">mat</span></div>

<div class="viewcode-block" id="EpochByEpochAgreement.get_sleep_stats"><a class="viewcode-back" href="../../generated/yasa.EpochByEpochAgreement.html#yasa.EpochByEpochAgreement.get_sleep_stats">[docs]</a>    <span class="k">def</span> <span class="nf">get_sleep_stats</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a :py:class:`pandas.DataFrame` of sleep statistics for each hypnogram derived from</span>
<span class="sd">        both reference and observed scorers.</span>

<span class="sd">        .. seealso:: :py:meth:`yasa.Hypnogram.sleep_statistics`</span>

<span class="sd">        .. seealso:: :py:class:`yasa.SleepStatsAgreement`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        self : :py:class:`yasa.EpochByEpochAgreement`</span>
<span class="sd">            A :py:class:`yasa.EpochByEpochAgreement` instance.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sstats : :py:class:`pandas.DataFrame`</span>
<span class="sd">            A :py:class:`~pandas.DataFrame` with sleep statistics as columns and two rows for each</span>
<span class="sd">            individual (one for reference scorer and another for test scorer).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get all sleep statistics</span>
        <span class="n">ref_sstats</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="n">s</span><span class="p">:</span> <span class="n">h</span><span class="o">.</span><span class="n">sleep_statistics</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">h</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ref_hyps</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>
        <span class="n">obs_sstats</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="n">s</span><span class="p">:</span> <span class="n">h</span><span class="o">.</span><span class="n">sleep_statistics</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">h</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obs_hyps</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>
        <span class="c1"># Reshape and name axis</span>
        <span class="n">ref_sstats</span> <span class="o">=</span> <span class="n">ref_sstats</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">rename_axis</span><span class="p">(</span><span class="s2">&quot;sleep_id&quot;</span><span class="p">)</span>
        <span class="n">obs_sstats</span> <span class="o">=</span> <span class="n">obs_sstats</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">rename_axis</span><span class="p">(</span><span class="s2">&quot;sleep_id&quot;</span><span class="p">)</span>
        <span class="c1"># Convert to MultiIndex with new scorer level</span>
        <span class="n">ref_sstats</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_scorer</span><span class="p">:</span> <span class="n">ref_sstats</span><span class="p">},</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;scorer&quot;</span><span class="p">])</span>
        <span class="n">obs_sstats</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">obs_scorer</span><span class="p">:</span> <span class="n">obs_sstats</span><span class="p">},</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;scorer&quot;</span><span class="p">])</span>
        <span class="c1"># Concatenate into one DataFrame</span>
        <span class="n">sstats</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">ref_sstats</span><span class="p">,</span> <span class="n">obs_sstats</span><span class="p">])</span>
        <span class="c1"># Remove the MultiIndex if just one session being evaluated</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_sleeps</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">sstats</span> <span class="o">=</span> <span class="n">sstats</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sstats</span></div>

<div class="viewcode-block" id="EpochByEpochAgreement.plot_hypnograms"><a class="viewcode-back" href="../../generated/yasa.EpochByEpochAgreement.html#yasa.EpochByEpochAgreement.plot_hypnograms">[docs]</a>    <span class="k">def</span> <span class="nf">plot_hypnograms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sleep_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">legend</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ref_kwargs</span><span class="o">=</span><span class="p">{},</span> <span class="n">obs_kwargs</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot;Plot the two hypnograms of one session overlapping on the same axis.</span>

<span class="sd">        .. seealso:: :py:func:`yasa.plot_hypnogram`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        self : :py:class:`yasa.EpochByEpochAgreement`</span>
<span class="sd">            A :py:class:`yasa.EpochByEpochAgreement` instance.</span>
<span class="sd">        sleep_id : a valid sleep ID or None</span>
<span class="sd">            The sleep session to plot. If multiple sessions are included in the</span>
<span class="sd">            :py:class:`~yasa.EpochByEpochAgreement` instance, a ``sleep_id`` must be provided. If</span>
<span class="sd">            only one session is present, ``None`` (default) will plot the two hypnograms of the</span>
<span class="sd">            only session.</span>
<span class="sd">        legend : bool or dict</span>
<span class="sd">            If True (default) or a dictionary, a legend is added. If a dictionary, all key/value</span>
<span class="sd">            pairs are passed as keyword arguments to the :py:func:`matplotlib.pyplot.legend` call.</span>
<span class="sd">        ax : :py:class:`matplotlib.axes.Axes` or None</span>
<span class="sd">            Axis on which to draw the plot, optional.</span>
<span class="sd">        ref_kwargs : dict</span>
<span class="sd">            Keyword arguments passed to :py:func:`yasa.plot_hypnogram` when plotting the reference</span>
<span class="sd">            hypnogram.</span>
<span class="sd">        obs_kwargs : dict</span>
<span class="sd">            Keyword arguments passed to :py:func:`yasa.plot_hypnogram` when plotting the observed</span>
<span class="sd">            hypnogram.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ax : :py:class:`matplotlib.axes.Axes`</span>
<span class="sd">            Matplotlib Axes</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        .. plot::</span>

<span class="sd">            &gt;&gt;&gt; from yasa import simulate_hypnogram</span>
<span class="sd">            &gt;&gt;&gt; hyp = simulate_hypnogram(scorer=&quot;Anthony&quot;, seed=19)</span>
<span class="sd">            &gt;&gt;&gt; ax = hyp.evaluate(hyp.simulate_similar(scorer=&quot;Alan&quot;, seed=68)).plot_hypnograms()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">sleep_id</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">sleep_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sleep_ids</span>
        <span class="p">),</span> <span class="s2">&quot;`sleep_id` must be None or a valid sleep ID&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">legend</span><span class="p">,</span> <span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)),</span> <span class="s2">&quot;`legend` must be True, False, or a dictionary&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ref_kwargs</span><span class="p">,</span> <span class="nb">dict</span><span class="p">),</span> <span class="s2">&quot;`ref_kwargs` must be a dictionary&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obs_kwargs</span><span class="p">,</span> <span class="nb">dict</span><span class="p">),</span> <span class="s2">&quot;`obs_kwargs` must be a dictionary&quot;</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="s2">&quot;ax&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ref_kwargs</span> <span class="o">|</span> <span class="n">obs_kwargs</span>
        <span class="p">),</span> <span class="s2">&quot;&#39;ax&#39; can&#39;t be supplied to `ref_kwargs` or `obs_kwargs`, use the `ax` keyword instead&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="p">(</span><span class="n">sleep_id</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_sleeps</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span>
            <span class="s2">&quot;Multi-session plotting is not currently supported. `sleep_id` must not be None when &quot;</span>
            <span class="s2">&quot;multiple sessions are present&quot;</span>
        <span class="p">)</span>
        <span class="c1"># Select the session hypnograms to plot</span>
        <span class="k">if</span> <span class="n">sleep_id</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_sleeps</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">ref_hyp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ref_hyps</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_sleep_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">obs_hyp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obs_hyps</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_sleep_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ref_hyp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ref_hyps</span><span class="p">[</span><span class="n">sleep_id</span><span class="p">]</span>
            <span class="n">obs_hyp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obs_hyps</span><span class="p">[</span><span class="n">sleep_id</span><span class="p">]</span>
        <span class="c1"># Set default plotting kwargs and merge with user kwargs</span>
        <span class="n">plot_ref_kwargs</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;label&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_scorer</span><span class="p">,</span>
            <span class="s2">&quot;highlight&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;color&quot;</span><span class="p">:</span> <span class="s2">&quot;black&quot;</span><span class="p">,</span>
            <span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="mf">0.8</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="n">plot_obs_kwargs</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;label&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs_scorer</span><span class="p">,</span>
            <span class="s2">&quot;highlight&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;color&quot;</span><span class="p">:</span> <span class="s2">&quot;green&quot;</span><span class="p">,</span>
            <span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="mf">0.8</span><span class="p">,</span>
            <span class="s2">&quot;ls&quot;</span><span class="p">:</span> <span class="s2">&quot;dashed&quot;</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="n">plot_ref_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">ref_kwargs</span><span class="p">)</span>
        <span class="n">plot_obs_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">obs_kwargs</span><span class="p">)</span>
        <span class="c1"># Draw the hypnograms</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">ref_hyp</span><span class="o">.</span><span class="n">plot_hypnogram</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="o">**</span><span class="n">plot_ref_kwargs</span><span class="p">)</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">obs_hyp</span><span class="o">.</span><span class="n">plot_hypnogram</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="o">**</span><span class="n">plot_obs_kwargs</span><span class="p">)</span>
        <span class="c1"># Add legend if desired</span>
        <span class="k">if</span> <span class="n">legend</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">legend</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="o">**</span><span class="n">legend</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">ax</span></div>

<div class="viewcode-block" id="EpochByEpochAgreement.summary"><a class="viewcode-back" href="../../generated/yasa.EpochByEpochAgreement.html#yasa.EpochByEpochAgreement.summary">[docs]</a>    <span class="k">def</span> <span class="nf">summary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">by_stage</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return group-level agreement scores.</span>

<span class="sd">        Default aggregated measures are</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        self : :py:class:`~yasa.evaluation.EpochByEpochAgreement`</span>
<span class="sd">            A :py:class:`~yasa.evaluation.EpochByEpochAgreement` instance.</span>
<span class="sd">        by_stage : bool</span>
<span class="sd">            If ``False`` (default), ``summary`` will include agreement scores derived from</span>
<span class="sd">            average-based metrics. If ``True``, returned ``summary`` :py:class:`~pandas.DataFrame`</span>
<span class="sd">            will include agreement scores for each sleep stage, derived from one-vs-rest metrics.</span>
<span class="sd">        **kwargs : key, value pairs</span>
<span class="sd">            Additional keyword arguments are passed to :py:meth:`pandas.DataFrame.groupby.agg`.</span>
<span class="sd">            This can be used to customize the descriptive statistics returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        summary : :py:class:`pandas.DataFrame`</span>
<span class="sd">            A :py:class:`pandas.DataFrame` summarizing agreement scores across the entire dataset</span>
<span class="sd">            with descriptive statistics.</span>

<span class="sd">            &gt;&gt;&gt; ebe = yasa.EpochByEpochAgreement(...)</span>
<span class="sd">            &gt;&gt;&gt; agreement = ebe.get_agreement()</span>
<span class="sd">            &gt;&gt;&gt; ebe.summary()</span>

<span class="sd">            This will give a :py:class:`~pandas.DataFrame` where each row is an agreement metric and</span>
<span class="sd">            each column is a descriptive statistic (e.g., mean, standard deviation).</span>
<span class="sd">            To control the descriptive statistics included as columns:</span>

<span class="sd">            &gt;&gt;&gt; ebe.summary(func=[&quot;count&quot;, &quot;mean&quot;, &quot;sem&quot;])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_sleeps</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Summary scores can not be computed with only one hypnogram pair.&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">by_stage</span><span class="p">,</span> <span class="nb">bool</span><span class="p">),</span> <span class="s2">&quot;`by_stage` must be True or False&quot;</span>
        <span class="k">if</span> <span class="n">by_stage</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_agreement_bystage&quot;</span>
            <span class="p">),</span> <span class="s2">&quot;Must run `self.get_agreement_bystage` before obtaining by_stage summary results.&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_agreement&quot;</span>
            <span class="p">),</span> <span class="s2">&quot;Must run `self.get_agreement` before obtaining summary results.&quot;</span>

        <span class="c1"># Create a function for getting mean absolute deviation</span>
        <span class="k">def</span> <span class="nf">mad</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">df</span> <span class="o">-</span> <span class="n">df</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

        <span class="c1"># Merge default and user kwargs</span>
        <span class="n">agg_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;func&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">mad</span><span class="p">,</span> <span class="s2">&quot;mean&quot;</span><span class="p">,</span> <span class="s2">&quot;std&quot;</span><span class="p">,</span> <span class="s2">&quot;min&quot;</span><span class="p">,</span> <span class="s2">&quot;median&quot;</span><span class="p">,</span> <span class="s2">&quot;max&quot;</span><span class="p">]}</span> <span class="o">|</span> <span class="n">kwargs</span>
        <span class="k">if</span> <span class="n">by_stage</span><span class="p">:</span>
            <span class="n">summary</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">agreement_bystage</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;stage&quot;</span><span class="p">)</span>
                <span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="o">**</span><span class="n">agg_kwargs</span><span class="p">)</span>
                <span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="o">.</span><span class="n">rename_axis</span><span class="p">([</span><span class="s2">&quot;stage&quot;</span><span class="p">,</span> <span class="s2">&quot;metric&quot;</span><span class="p">])</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">summary</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_agreement</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="o">**</span><span class="n">agg_kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">rename_axis</span><span class="p">(</span><span class="s2">&quot;metric&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">summary</span></div></div>


<span class="c1">################################################################################</span>
<span class="c1"># SLEEP STATISTICS</span>
<span class="c1">################################################################################</span>


<div class="viewcode-block" id="SleepStatsAgreement"><a class="viewcode-back" href="../../generated/yasa.SleepStatsAgreement.html#yasa.SleepStatsAgreement">[docs]</a><span class="k">class</span> <span class="nc">SleepStatsAgreement</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate agreement between sleep statistics reported by two different scorers.</span>
<span class="sd">    Evaluation includes bias and limits of agreement (as well as both their confidence intervals),</span>
<span class="sd">    various plotting options, and calibration functions for correcting biased values from the</span>
<span class="sd">    observed scorer.</span>

<span class="sd">    Features include:</span>
<span class="sd">    * Get summary calculations of bias, limits of agreement, and their confidence intervals.</span>
<span class="sd">    * Test statistical assumptions of bias, limits of agreement, and their confidence intervals,</span>
<span class="sd">    and apply corrective procedures when the assumptions are not met.</span>
<span class="sd">    * Get bias and limits of agreement in a string-formatted table.</span>
<span class="sd">    * Calibrate new data to correct for biases in observed data.</span>
<span class="sd">    * Return individual calibration functions.</span>
<span class="sd">    * Visualize discrepancies for outlier inspection.</span>
<span class="sd">    * Visualize Bland-Altman plots.</span>

<span class="sd">    .. seealso:: :py:meth:`yasa.Hypnogram.sleep_statistics`</span>

<span class="sd">    .. versionadded:: 0.7.0</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ref_data : :py:class:`pandas.DataFrame`</span>
<span class="sd">        A :py:class:`pandas.DataFrame` with sleep statistics from the reference scorer.</span>
<span class="sd">        Rows are unique observations and columns are unique sleep statistics.</span>
<span class="sd">    obs_data : :py:class:`pandas.DataFrame`</span>
<span class="sd">        A :py:class:`pandas.DataFrame` with sleep statistics from the observed scorer.</span>
<span class="sd">        Rows are unique observations and columns are unique sleep statistics.</span>
<span class="sd">        Shape, index, and columns must be identical to ``ref_data``.</span>
<span class="sd">    ref_scorer : str</span>
<span class="sd">        Name of the reference scorer.</span>
<span class="sd">    obs_scorer : str</span>
<span class="sd">        Name of the observed scorer.</span>
<span class="sd">    agreement : float</span>
<span class="sd">        Multiple of the standard deviation to plot agreement limits. The default is 1.96, which</span>
<span class="sd">        corresponds to a 95% confidence interval if the differences are normally distributed.</span>

<span class="sd">        .. note:: ``agreement`` gets adjusted for regression-modeled limits of agreement.</span>
<span class="sd">    confidence : float</span>
<span class="sd">        The percentage confidence interval for the confidence intervals that are applied to bias and</span>
<span class="sd">        limits of agreement. The same confidence interval percentage is applied to both standard and</span>
<span class="sd">        bootstrapped confidence intervals.</span>
<span class="sd">    alpha : float</span>
<span class="sd">        Alpha cutoff used for all assumption tests.</span>
<span class="sd">    verbose : bool or str</span>
<span class="sd">        Verbose level. Default (False) will only print warning and error messages. The logging</span>
<span class="sd">        levels are &#39;debug&#39;, &#39;info&#39;, &#39;warning&#39;, &#39;error&#39;, and &#39;critical&#39;. For most users the choice is</span>
<span class="sd">        between &#39;info&#39; (or ``verbose=True``) and warning (``verbose=False``).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Sleep statistics that are identical between scorers are removed from analysis.</span>

<span class="sd">    Many steps here are influenced by guidelines proposed in Menghini et al., 2021 [Menghini2021]_.</span>
<span class="sd">    See https://sri-human-sleep.github.io/sleep-trackers-performance/AnalyticalPipeline_v1.0.0.html</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [Menghini2021] Menghini, L., Cellini, N., Goldstone, A., Baker, F. C., &amp; de Zambotti, M.</span>
<span class="sd">                      (2021). A standardized framework for testing the performance of sleep-tracking</span>
<span class="sd">                      technology: step-by-step guidelines and open-source code. SLEEP, 44(2),</span>
<span class="sd">                      zsaa170. https://doi.org/10.1093/sleep/zsaa170</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">    &gt;&gt;&gt; import yasa</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Generate fake reference and observed datasets with similar sleep statistics</span>
<span class="sd">    &gt;&gt;&gt; ref_scorer = &quot;Henri&quot;</span>
<span class="sd">    &gt;&gt;&gt; obs_scorer = &quot;Piron&quot;</span>
<span class="sd">    &gt;&gt;&gt; ref_hyps = [yasa.simulate_hypnogram(tib=600, scorer=ref_scorer, seed=i) for i in range(20)]</span>
<span class="sd">    &gt;&gt;&gt; obs_hyps = [h.simulate_similar(scorer=obs_scorer, seed=i) for i, h in enumerate(ref_hyps)]</span>
<span class="sd">    &gt;&gt;&gt; # Generate sleep statistics from hypnograms using EpochByEpochAgreement</span>
<span class="sd">    &gt;&gt;&gt; eea = yasa.EpochByEpochAgreement(ref_hyps, obs_hyps)</span>
<span class="sd">    &gt;&gt;&gt; sstats = eea.get_sleep_stats()</span>
<span class="sd">    &gt;&gt;&gt; ref_sstats = sstats.loc[ref_scorer]</span>
<span class="sd">    &gt;&gt;&gt; obs_sstats = sstats.loc[obs_scorer]</span>
<span class="sd">    &gt;&gt;&gt; # Create SleepStatsAgreement instance</span>
<span class="sd">    &gt;&gt;&gt; ssa = yasa.SleepStatsAgreement(ref_sstats, obs_sstats)</span>
<span class="sd">    &gt;&gt;&gt; ssa.summary().round(1).head(3)</span>
<span class="sd">    variable   bias_intercept             ...   uloa_parm</span>
<span class="sd">    interval           center lower upper ...      center lower upper</span>
<span class="sd">    sleep_stat                            ...</span>
<span class="sd">    %N1                  -5.4 -13.9   3.2 ...         6.1   3.7   8.5</span>
<span class="sd">    %N2                 -27.3 -49.1  -5.6 ...        12.4   7.2  17.6</span>
<span class="sd">    %N3                  -9.1 -23.8   5.5 ...        20.4  12.6  28.3</span>

<span class="sd">    &gt;&gt;&gt; ssa.get_table().head(3)[[&quot;bias&quot;, &quot;loa&quot;]]</span>
<span class="sd">                          bias                            loa</span>
<span class="sd">    sleep_stat</span>
<span class="sd">    %N1                   0.25  Bias  2.46 * (-0.00 + 1.00x)</span>
<span class="sd">    %N2         -27.34 + 0.55x   Bias  2.46 * (0.00 + 1.00x)</span>
<span class="sd">    %N3                   1.38   Bias  2.46 * (0.00 + 1.00x)</span>

<span class="sd">    &gt;&gt;&gt; ssa.assumptions.head(3)</span>
<span class="sd">                unbiased  normal  constant_bias  homoscedastic</span>
<span class="sd">    sleep_stat</span>
<span class="sd">    %N1             True    True           True          False</span>
<span class="sd">    %N2             True    True          False          False</span>
<span class="sd">    %N3             True    True           True          False</span>

<span class="sd">    &gt;&gt;&gt; ssa.auto_methods.head(3)</span>
<span class="sd">                bias   loa    ci</span>
<span class="sd">    sleep_stat</span>
<span class="sd">    %N1         parm  regr  parm</span>
<span class="sd">    %N2         regr  regr  parm</span>
<span class="sd">    %N3         parm  regr  parm</span>

<span class="sd">    &gt;&gt;&gt; ssa.get_table(bias_method=&quot;parm&quot;, loa_method=&quot;parm&quot;).head(3)[[&quot;bias&quot;, &quot;loa&quot;]]</span>
<span class="sd">                 bias            loa</span>
<span class="sd">    sleep_stat</span>
<span class="sd">    %N1          0.25    -5.55, 6.06</span>
<span class="sd">    %N2         -0.23  -12.87, 12.40</span>
<span class="sd">    %N3          1.38  -17.67, 20.44</span>

<span class="sd">    &gt;&gt;&gt; new_hyps = [h.simulate_similar(scorer=&quot;Kelly&quot;, seed=i) for i, h in enumerate(obs_hyps)]</span>
<span class="sd">    &gt;&gt;&gt; new_sstats = pd.Series(new_hyps).map(lambda h: h.sleep_statistics()).apply(pd.Series)</span>
<span class="sd">    &gt;&gt;&gt; new_sstats = new_sstats[[&quot;N1&quot;, &quot;TST&quot;, &quot;WASO&quot;]]</span>
<span class="sd">    &gt;&gt;&gt; new_sstats.round(1).head(5)</span>
<span class="sd">         N1    TST   WASO</span>
<span class="sd">    0  42.5  439.5  147.5</span>
<span class="sd">    1  84.0  550.0   38.5</span>
<span class="sd">    2  53.5  489.0  103.0</span>
<span class="sd">    3  57.0  469.5  120.0</span>
<span class="sd">    4  71.0  531.0   69.0</span>

<span class="sd">    &gt;&gt;&gt; new_stats_calibrated = ssa.calibrate_stats(new_sstats, bias_method=&quot;auto&quot;)</span>
<span class="sd">    &gt;&gt;&gt; new_stats_calibrated.round(1).head(5)</span>
<span class="sd">         N1    TST   WASO</span>
<span class="sd">    0  42.9  433.8  150.0</span>
<span class="sd">    1  84.4  544.2   41.0</span>
<span class="sd">    2  53.9  483.2  105.5</span>
<span class="sd">    3  57.4  463.8  122.5</span>
<span class="sd">    4  71.4  525.2   71.5</span>

<span class="sd">    .. plot::</span>

<span class="sd">        &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">        &gt;&gt;&gt; ax = ssa.plot_discrepancies_heatmap()</span>
<span class="sd">        &gt;&gt;&gt; ax.set_title(&quot;Sleep statistic discrepancies&quot;)</span>
<span class="sd">        &gt;&gt;&gt; plt.tight_layout()</span>

<span class="sd">    .. plot::</span>

<span class="sd">        &gt;&gt;&gt; ssa.plot_blandaltman()</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="SleepStatsAgreement.__init__"><a class="viewcode-back" href="../../generated/yasa.SleepStatsAgreement.html#yasa.SleepStatsAgreement.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ref_data</span><span class="p">,</span>
        <span class="n">obs_data</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">ref_scorer</span><span class="o">=</span><span class="s2">&quot;Reference&quot;</span><span class="p">,</span>
        <span class="n">obs_scorer</span><span class="o">=</span><span class="s2">&quot;Observed&quot;</span><span class="p">,</span>
        <span class="n">agreement</span><span class="o">=</span><span class="mf">1.96</span><span class="p">,</span>
        <span class="n">confidence</span><span class="o">=</span><span class="mf">0.95</span><span class="p">,</span>
        <span class="n">alpha</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">bootstrap_kwargs</span><span class="o">=</span><span class="p">{},</span>
    <span class="p">):</span>

        <span class="n">restricted_bootstrap_kwargs</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;confidence_level&quot;</span><span class="p">,</span> <span class="s2">&quot;vectorized&quot;</span><span class="p">,</span> <span class="s2">&quot;paired&quot;</span><span class="p">]</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ref_data</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">),</span> <span class="s2">&quot;`ref_data` must be a pandas DataFrame&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obs_data</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">),</span> <span class="s2">&quot;`obs_data` must be a pandas DataFrame&quot;</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span>
            <span class="n">ref_data</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">obs_data</span><span class="o">.</span><span class="n">index</span>
        <span class="p">),</span> <span class="s2">&quot;`ref_data` and `obs_data` index values must be identical&quot;</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">ref_data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">obs_data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span>
        <span class="p">),</span> <span class="s2">&quot;`ref_data` and `obs_data` index names must be identical&quot;</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span>
            <span class="n">ref_data</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">obs_data</span><span class="o">.</span><span class="n">columns</span>
        <span class="p">),</span> <span class="s2">&quot;`ref_data` and `obs_data` column values must be identical&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ref_scorer</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="s2">&quot;`ref_scorer` must be a string&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obs_scorer</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="s2">&quot;`obs_scorer` must be a string&quot;</span>
        <span class="k">assert</span> <span class="n">ref_scorer</span> <span class="o">!=</span> <span class="n">obs_scorer</span><span class="p">,</span> <span class="s2">&quot;`ref_scorer` and `obs_scorer` must be unique&quot;</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">agreement</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">))</span> <span class="ow">and</span> <span class="n">agreement</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="p">),</span> <span class="s2">&quot;`agreement` must be a number greater than 0&quot;</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">confidence</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">))</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">alpha</span> <span class="o">&lt;</span> <span class="mi">1</span>
        <span class="p">),</span> <span class="s2">&quot;`confidence` must be a number between 0 and 1&quot;</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">))</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">alpha</span> <span class="o">&lt;=</span> <span class="mi">1</span>
        <span class="p">),</span> <span class="s2">&quot;`alpha` must be a number between 0 and 1 inclusive&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bootstrap_kwargs</span><span class="p">,</span> <span class="nb">dict</span><span class="p">),</span> <span class="s2">&quot;`bootstrap_kwargs` must be a dictionary&quot;</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span>
            <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">restricted_bootstrap_kwargs</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">bootstrap_kwargs</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;None of </span><span class="si">{</span><span class="n">restricted_bootstrap_kwargs</span><span class="si">}</span><span class="s2"> can be set by the user&quot;</span>

        <span class="c1"># If `ref_data` and `obs_data` indices are unnamed, name them</span>
        <span class="n">session_key</span> <span class="o">=</span> <span class="s2">&quot;session_id&quot;</span> <span class="k">if</span> <span class="n">ref_data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">ref_data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span>
        <span class="n">ref_data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">obs_data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">session_key</span>

        <span class="c1"># Reshape to long format DataFrame with 2 columns (observed, reference) and MultiIndex</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">obs_data</span><span class="p">,</span> <span class="n">ref_data</span><span class="p">],</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="n">obs_scorer</span><span class="p">,</span> <span class="n">ref_scorer</span><span class="p">],</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;scorer&quot;</span><span class="p">])</span>
            <span class="o">.</span><span class="n">melt</span><span class="p">(</span><span class="n">var_name</span><span class="o">=</span><span class="s2">&quot;sleep_stat&quot;</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="o">.</span><span class="n">pivot_table</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;sleep_stat&quot;</span><span class="p">,</span> <span class="n">session_key</span><span class="p">],</span> <span class="n">columns</span><span class="o">=</span><span class="s2">&quot;scorer&quot;</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="s2">&quot;value&quot;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">rename_axis</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
            <span class="o">.</span><span class="n">sort_index</span><span class="p">()</span>
        <span class="p">)</span>

        <span class="c1"># Get scorer differences (i.e., observed minus reference)</span>
        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;difference&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">obs_scorer</span><span class="p">]</span> <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="n">ref_scorer</span><span class="p">]</span>

        <span class="c1"># Remove sleep statistics that have no differences between scorers</span>
        <span class="n">stats_rm</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;sleep_stat&quot;</span><span class="p">)[</span><span class="s2">&quot;difference&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">any</span><span class="p">()</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="o">~</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="n">stats_rm</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">stats_rm</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Removed </span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="s2"> from evaluation because all scorings were identical.&quot;</span><span class="p">)</span>

        <span class="c1"># Create grouper and n_sessions variables for convenience</span>
        <span class="n">grouper</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;sleep_stat&quot;</span><span class="p">)</span>
        <span class="n">n_sessions</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="n">session_key</span><span class="p">)</span><span class="o">.</span><span class="n">nunique</span><span class="p">()</span>

        <span class="c1">########################################################################</span>
        <span class="c1"># Generate parametric Bias and LoA for all sleep stats</span>
        <span class="c1">########################################################################</span>
        <span class="c1"># Parametric Bias</span>
        <span class="n">parm_vals</span> <span class="o">=</span> <span class="n">grouper</span><span class="p">[</span><span class="s2">&quot;difference&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">.</span><span class="n">to_frame</span><span class="p">(</span><span class="s2">&quot;bias_parm&quot;</span><span class="p">)</span>
        <span class="c1"># Parametric LoA</span>
        <span class="n">parm_vals</span><span class="p">[</span><span class="s2">&quot;lloa_parm&quot;</span><span class="p">],</span> <span class="n">parm_vals</span><span class="p">[</span><span class="s2">&quot;uloa_parm&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span>
            <span class="o">*</span><span class="n">grouper</span><span class="p">[</span><span class="s2">&quot;difference&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_arr_to_loa</span><span class="p">,</span> <span class="n">agreement</span><span class="o">=</span><span class="n">agreement</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1">########################################################################</span>
        <span class="c1"># Generate standard CIs for parametric Bias and LoA for all sleep stats</span>
        <span class="c1">########################################################################</span>
        <span class="c1"># Get critical t and standard error used to calculate parametric CIs for parametric Bias/LoA</span>
        <span class="n">t_parm</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">ppf</span><span class="p">((</span><span class="mi">1</span> <span class="o">+</span> <span class="n">confidence</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">n_sessions</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">sem</span> <span class="o">=</span> <span class="n">grouper</span><span class="p">[</span><span class="s2">&quot;difference&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sem</span><span class="p">(</span><span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Parametric CIs for parametric Bias and LoA</span>
        <span class="n">parm_ci</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="s2">&quot;bias_parm-lower&quot;</span><span class="p">:</span> <span class="n">parm_vals</span><span class="p">[</span><span class="s2">&quot;bias_parm&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">sem</span> <span class="o">*</span> <span class="n">t_parm</span><span class="p">,</span>
                <span class="s2">&quot;bias_parm-upper&quot;</span><span class="p">:</span> <span class="n">parm_vals</span><span class="p">[</span><span class="s2">&quot;bias_parm&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">sem</span> <span class="o">*</span> <span class="n">t_parm</span><span class="p">,</span>
                <span class="s2">&quot;lloa_parm-lower&quot;</span><span class="p">:</span> <span class="n">parm_vals</span><span class="p">[</span><span class="s2">&quot;lloa_parm&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">sem</span> <span class="o">*</span> <span class="n">t_parm</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span>
                <span class="s2">&quot;lloa_parm-upper&quot;</span><span class="p">:</span> <span class="n">parm_vals</span><span class="p">[</span><span class="s2">&quot;lloa_parm&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">sem</span> <span class="o">*</span> <span class="n">t_parm</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span>
                <span class="s2">&quot;uloa_parm-lower&quot;</span><span class="p">:</span> <span class="n">parm_vals</span><span class="p">[</span><span class="s2">&quot;uloa_parm&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">sem</span> <span class="o">*</span> <span class="n">t_parm</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span>
                <span class="s2">&quot;uloa_parm-upper&quot;</span><span class="p">:</span> <span class="n">parm_vals</span><span class="p">[</span><span class="s2">&quot;uloa_parm&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">sem</span> <span class="o">*</span> <span class="n">t_parm</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span>
            <span class="p">}</span>
        <span class="p">)</span>

        <span class="c1">########################################################################</span>
        <span class="c1"># Generate regression/modeled (slope and intercept) Bias and LoA for all sleep stats</span>
        <span class="c1">########################################################################</span>
        <span class="c1"># Run regression used to (a) model bias and (b) test for proportional/constant bias</span>
        <span class="n">bias_regr</span> <span class="o">=</span> <span class="n">grouper</span><span class="p">[[</span><span class="n">ref_scorer</span><span class="p">,</span> <span class="s2">&quot;difference&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_linregr_dict</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)</span>
        <span class="c1"># Get absolute residuals from this regression bc they are used in the next regression</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="s2">&quot;sleep_stat&quot;</span><span class="p">)</span>
        <span class="n">slopes</span> <span class="o">=</span> <span class="n">bias_regr</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="s2">&quot;slope&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">intercepts</span> <span class="o">=</span> <span class="n">bias_regr</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="s2">&quot;intercept&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">predicted_values</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">ref_scorer</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span> <span class="o">*</span> <span class="n">slopes</span> <span class="o">+</span> <span class="n">intercepts</span>
        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;residuals&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">obs_scorer</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span> <span class="o">-</span> <span class="n">predicted_values</span>
        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;residuals_abs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;residuals&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span>
        <span class="c1"># Run regression used to (a) model LoA and (b) test for heteroscedasticity/homoscedasticity</span>
        <span class="n">loa_regr</span> <span class="o">=</span> <span class="n">grouper</span><span class="p">[[</span><span class="n">ref_scorer</span><span class="p">,</span> <span class="s2">&quot;residuals_abs&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_linregr_dict</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)</span>
        <span class="c1"># Stack the two regression dataframes together</span>
        <span class="n">regr</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">({</span><span class="s2">&quot;bias&quot;</span><span class="p">:</span> <span class="n">bias_regr</span><span class="p">,</span> <span class="s2">&quot;loa&quot;</span><span class="p">:</span> <span class="n">loa_regr</span><span class="p">},</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1">########################################################################</span>
        <span class="c1"># Generate parametric CIs for regression/modeled Bias and LoA for all sleep stats</span>
        <span class="c1">########################################################################</span>
        <span class="c1"># Get critical t used used to calculate parametric CIs for regression Bias/LoA</span>
        <span class="n">t_regr</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">ppf</span><span class="p">((</span><span class="mi">1</span> <span class="o">+</span> <span class="n">confidence</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">n_sessions</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># dof=n-2 for regression</span>
        <span class="c1"># Parametric CIs for modeled Bias and LoA</span>
        <span class="n">regr_ci</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="s2">&quot;intercept-lower&quot;</span><span class="p">:</span> <span class="n">regr</span><span class="p">[</span><span class="s2">&quot;intercept&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">regr</span><span class="p">[</span><span class="s2">&quot;intercept_stderr&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">t_regr</span><span class="p">,</span>
                <span class="s2">&quot;intercept-upper&quot;</span><span class="p">:</span> <span class="n">regr</span><span class="p">[</span><span class="s2">&quot;intercept&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">regr</span><span class="p">[</span><span class="s2">&quot;intercept_stderr&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">t_regr</span><span class="p">,</span>
                <span class="s2">&quot;slope-lower&quot;</span><span class="p">:</span> <span class="n">regr</span><span class="p">[</span><span class="s2">&quot;slope&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">regr</span><span class="p">[</span><span class="s2">&quot;stderr&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">t_regr</span><span class="p">,</span>
                <span class="s2">&quot;slope-upper&quot;</span><span class="p">:</span> <span class="n">regr</span><span class="p">[</span><span class="s2">&quot;slope&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">regr</span><span class="p">[</span><span class="s2">&quot;stderr&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">t_regr</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="p">)</span>

        <span class="c1">########################################################################</span>
        <span class="c1"># Test all statistical assumptions</span>
        <span class="c1">########################################################################</span>
        <span class="n">assumptions</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="s2">&quot;unbiased&quot;</span><span class="p">:</span> <span class="p">(</span>
                    <span class="n">grouper</span><span class="p">[</span><span class="s2">&quot;difference&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">sps</span><span class="o">.</span><span class="n">ttest_1samp</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">pvalue</span><span class="p">)</span><span class="o">.</span><span class="n">ge</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
                <span class="p">),</span>
                <span class="s2">&quot;normal&quot;</span><span class="p">:</span> <span class="n">grouper</span><span class="p">[</span><span class="s2">&quot;difference&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">sps</span><span class="o">.</span><span class="n">shapiro</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">pvalue</span><span class="p">)</span><span class="o">.</span><span class="n">ge</span><span class="p">(</span><span class="n">alpha</span><span class="p">),</span>
                <span class="s2">&quot;constant_bias&quot;</span><span class="p">:</span> <span class="n">bias_regr</span><span class="p">[</span><span class="s2">&quot;pvalue&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">ge</span><span class="p">(</span><span class="n">alpha</span><span class="p">),</span>
                <span class="s2">&quot;homoscedastic&quot;</span><span class="p">:</span> <span class="n">loa_regr</span><span class="p">[</span><span class="s2">&quot;pvalue&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">ge</span><span class="p">(</span><span class="n">alpha</span><span class="p">),</span>
            <span class="p">}</span>
        <span class="p">)</span>

        <span class="c1">########################################################################</span>
        <span class="c1"># Setting attributes</span>
        <span class="c1">########################################################################</span>

        <span class="c1"># Merge the parametric and regression values for Bias and LoA</span>
        <span class="n">regr_vals</span> <span class="o">=</span> <span class="n">regr</span><span class="o">.</span><span class="n">unstack</span><span class="p">(</span><span class="mi">0</span><span class="p">)[[</span><span class="s2">&quot;slope&quot;</span><span class="p">,</span> <span class="s2">&quot;intercept&quot;</span><span class="p">]]</span>
        <span class="n">regr_vals</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">regr_vals</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">swaplevel</span><span class="p">()</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">)</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">parm_vals</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">regr_vals</span><span class="p">)</span><span class="o">.</span><span class="n">rename_axis</span><span class="p">(</span><span class="s2">&quot;variable&quot;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Merge the two CI dataframes for easier access</span>
        <span class="n">regr_ci</span> <span class="o">=</span> <span class="n">regr_ci</span><span class="o">.</span><span class="n">unstack</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">regr_ci</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">regr_ci</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">swaplevel</span><span class="p">()</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">)</span>
        <span class="n">ci</span> <span class="o">=</span> <span class="n">parm_ci</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">regr_ci</span><span class="p">)</span>
        <span class="n">ci</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_tuples</span><span class="p">(</span>
            <span class="n">tuples</span><span class="o">=</span><span class="n">ci</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="n">expand</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
            <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;variable&quot;</span><span class="p">,</span> <span class="s2">&quot;interval&quot;</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="n">empty_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span><span class="o">.</span><span class="n">reindex_like</span><span class="p">(</span><span class="n">ci</span><span class="p">)</span>
        <span class="n">ci</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">({</span><span class="s2">&quot;parm&quot;</span><span class="p">:</span> <span class="n">ci</span><span class="p">,</span> <span class="s2">&quot;boot&quot;</span><span class="p">:</span> <span class="n">empty_df</span><span class="p">},</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;ci_method&quot;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">ci</span> <span class="o">=</span> <span class="n">ci</span><span class="o">.</span><span class="n">sort_index</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Sort MultiIndex columns for cleanliness</span>

        <span class="c1"># Set attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_agreement</span> <span class="o">=</span> <span class="n">agreement</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_confidence</span> <span class="o">=</span> <span class="n">confidence</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bootstrap_kwargs</span> <span class="o">=</span> <span class="n">bootstrap_kwargs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_sessions</span> <span class="o">=</span> <span class="n">n_sessions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ref_scorer</span> <span class="o">=</span> <span class="n">ref_scorer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_obs_scorer</span> <span class="o">=</span> <span class="n">obs_scorer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assumptions</span> <span class="o">=</span> <span class="n">assumptions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_regr</span> <span class="o">=</span> <span class="n">regr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vals</span> <span class="o">=</span> <span class="n">vals</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ci</span> <span class="o">=</span> <span class="n">ci</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bias_method_opts</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;parm&quot;</span><span class="p">,</span> <span class="s2">&quot;regr&quot;</span><span class="p">,</span> <span class="s2">&quot;auto&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_loa_method_opts</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;parm&quot;</span><span class="p">,</span> <span class="s2">&quot;regr&quot;</span><span class="p">,</span> <span class="s2">&quot;auto&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ci_method_opts</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;parm&quot;</span><span class="p">,</span> <span class="s2">&quot;boot&quot;</span><span class="p">,</span> <span class="s2">&quot;auto&quot;</span><span class="p">]</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ref_scorer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The name of the reference scorer.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ref_scorer</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">obs_scorer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The name of the observed scorer.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obs_scorer</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_sessions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The number of sessions.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_sessions</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A long-format :py:class:`pandas.DataFrame` containing all raw sleep statistics from</span>
<span class="sd">        ``ref_data`` and ``obs_data``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;difference&quot;</span><span class="p">,</span> <span class="s2">&quot;residuals&quot;</span><span class="p">,</span> <span class="s2">&quot;residuals_abs&quot;</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sleep_statistics</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of all sleep statistics included in the agreement analyses.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="s2">&quot;sleep_stat&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">assumptions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A :py:class:`pandas.DataFrame` containing boolean values indicating the pass/fail status</span>
<span class="sd">        of all statistical tests performed to test assumptions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_assumptions</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">auto_methods</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A :py:class:`pandas.DataFrame` containing the methods applied when ``&#39;auto&#39;`` is selected.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">assumptions</span><span class="p">[</span><span class="s2">&quot;constant_bias&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">({</span><span class="kc">True</span><span class="p">:</span> <span class="s2">&quot;parm&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">:</span> <span class="s2">&quot;regr&quot;</span><span class="p">})</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s2">&quot;bias&quot;</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">assumptions</span><span class="p">[</span><span class="s2">&quot;homoscedastic&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">({</span><span class="kc">True</span><span class="p">:</span> <span class="s2">&quot;parm&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">:</span> <span class="s2">&quot;regr&quot;</span><span class="p">})</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s2">&quot;loa&quot;</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">assumptions</span><span class="p">[</span><span class="s2">&quot;normal&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">({</span><span class="kc">True</span><span class="p">:</span> <span class="s2">&quot;parm&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">:</span> <span class="s2">&quot;boot&quot;</span><span class="p">})</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s2">&quot;ci&quot;</span><span class="p">),</span>
            <span class="p">],</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># TODO v0.8: Keep only the text between &lt; and &gt;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;&lt;SleepStatsAgreement | Observed scorer (&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">obs_scorer</span><span class="si">}</span><span class="s2">&#39;) evaluated against &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;reference scorer (&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_scorer</span><span class="si">}</span><span class="s2">&#39;), </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_sessions</span><span class="si">}</span><span class="s2"> sleep sessions&gt;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot; - Use `.summary()` to get a dataframe of bias and limits of agreement for each sleep &quot;</span>
            <span class="s2">&quot;statistic</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot; - Use `.plot_blandaltman()` to get a Bland-Altman-plot grid for sleep statistics</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;See the online documentation for more details.&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>

    <span class="c1">############################################################################</span>
    <span class="c1"># Define some utility functions, mostly to aid with the use of df.apply and stats.bootstrap</span>
    <span class="c1">############################################################################</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_arr_to_loa</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">agreement</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a tuple with lower and upper limits of agreement.&quot;&quot;&quot;</span>
        <span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">bound</span> <span class="o">=</span> <span class="n">agreement</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mean</span> <span class="o">-</span> <span class="n">bound</span><span class="p">,</span> <span class="n">mean</span> <span class="o">+</span> <span class="n">bound</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_linregr_dict</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A wrapper around :py:func:`scipy.stats.linregress` that returns a dictionary instead of a</span>
<span class="sd">        named tuple. In the normally returned object, ``intercept_stderr`` is an extra field that is</span>
<span class="sd">        not included when converting the named tuple, so this allows it to be included when using</span>
<span class="sd">        something like groupby.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">regr</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">linregress</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;slope&quot;</span><span class="p">:</span> <span class="n">regr</span><span class="o">.</span><span class="n">slope</span><span class="p">,</span>
            <span class="s2">&quot;intercept&quot;</span><span class="p">:</span> <span class="n">regr</span><span class="o">.</span><span class="n">intercept</span><span class="p">,</span>
            <span class="s2">&quot;rvalue&quot;</span><span class="p">:</span> <span class="n">regr</span><span class="o">.</span><span class="n">rvalue</span><span class="p">,</span>
            <span class="s2">&quot;pvalue&quot;</span><span class="p">:</span> <span class="n">regr</span><span class="o">.</span><span class="n">pvalue</span><span class="p">,</span>
            <span class="s2">&quot;stderr&quot;</span><span class="p">:</span> <span class="n">regr</span><span class="o">.</span><span class="n">stderr</span><span class="p">,</span>
            <span class="s2">&quot;intercept_stderr&quot;</span><span class="p">:</span> <span class="n">regr</span><span class="o">.</span><span class="n">intercept_stderr</span><span class="p">,</span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="nf">_generate_bootstrap_ci</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sleep_stats</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Internal method to generate bootstrapped confidence intervals for bias and LoA.</span>
<span class="sd">        This operates in-place by concatenating bootstrapped CIs to existing parametric CIs.</span>
<span class="sd">        Note that parametric CIs are generated by default during init (bc they are quicker).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sleep_stats : list</span>
<span class="sd">            A list of sleep statistics to bootstrap confidence intervals for.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sleep_stats</span><span class="p">,</span> <span class="nb">list</span><span class="p">),</span> <span class="s2">&quot;`sleep_stats` must be a list&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">sleep_stats</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">sleep_stats</span><span class="p">)),</span> <span class="s2">&quot;elements of `sleep_stats` must be unique&quot;</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="n">sleep_stats</span>
        <span class="p">),</span> <span class="s2">&quot;all elements of `sleep_stats` must be strings&quot;</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span>
            <span class="n">ss</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sleep_statistics</span> <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="n">sleep_stats</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;all elements of `sleep_stats` must be one of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">sleep_statistics</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="c1"># Update bootstrap keyword arguments with defaults</span>
        <span class="n">bs_kwargs</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;n_resamples&quot;</span><span class="p">:</span> <span class="mi">1000</span><span class="p">,</span>
            <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="s2">&quot;BCa&quot;</span><span class="p">,</span>
            <span class="s2">&quot;confidence_level&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_confidence</span><span class="p">,</span>  <span class="c1"># should not change from parametric level</span>
            <span class="s2">&quot;vectorized&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>  <span class="c1"># should stay False, bc of how the custom get_vars function works</span>
            <span class="s2">&quot;paired&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>  <span class="c1"># should stay True, especially if method is BCa</span>
        <span class="p">}</span> <span class="o">|</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bootstrap_kwargs</span>

        <span class="k">def</span> <span class="nf">get_vars</span><span class="p">(</span><span class="n">ref_arr</span><span class="p">,</span> <span class="n">diff_arr</span><span class="p">,</span> <span class="n">rabs_arr</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;A function to get all variables at once and avoid redundant stats.bootstrap calls.&quot;&quot;&quot;</span>
            <span class="n">bias_parm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">diff_arr</span><span class="p">)</span>
            <span class="n">lloa_parm</span><span class="p">,</span> <span class="n">uloa_parm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arr_to_loa</span><span class="p">(</span><span class="n">diff_arr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_agreement</span><span class="p">)</span>
            <span class="n">bias_slope</span><span class="p">,</span> <span class="n">bias_inter</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">linregress</span><span class="p">(</span><span class="n">ref_arr</span><span class="p">,</span> <span class="n">diff_arr</span><span class="p">)[:</span><span class="mi">2</span><span class="p">]</span>
            <span class="c1"># Note this is NOT recalculating residuals each time for the next regression</span>
            <span class="n">loa_slope</span><span class="p">,</span> <span class="n">loa_inter</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">linregress</span><span class="p">(</span><span class="n">ref_arr</span><span class="p">,</span> <span class="n">rabs_arr</span><span class="p">)[:</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">bias_parm</span><span class="p">,</span> <span class="n">lloa_parm</span><span class="p">,</span> <span class="n">uloa_parm</span><span class="p">,</span> <span class="n">bias_inter</span><span class="p">,</span> <span class="n">bias_slope</span><span class="p">,</span> <span class="n">loa_inter</span><span class="p">,</span> <span class="n">loa_slope</span>

        <span class="c1"># !! Column order MUST match the order of arrays boot_stats expects as INPUT</span>
        <span class="c1"># !! Variable order MUST match the order of floats boot_stats returns as OUTPUT</span>
        <span class="n">interval_order</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;lower&quot;</span><span class="p">,</span> <span class="s2">&quot;upper&quot;</span><span class="p">]</span>
        <span class="n">column_order</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Reference&quot;</span><span class="p">,</span> <span class="s2">&quot;difference&quot;</span><span class="p">,</span> <span class="s2">&quot;residuals_abs&quot;</span><span class="p">]</span>
        <span class="n">variable_order</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;bias_parm&quot;</span><span class="p">,</span>
            <span class="s2">&quot;lloa_parm&quot;</span><span class="p">,</span>
            <span class="s2">&quot;uloa_parm&quot;</span><span class="p">,</span>
            <span class="s2">&quot;bias_intercept&quot;</span><span class="p">,</span>
            <span class="s2">&quot;bias_slope&quot;</span><span class="p">,</span>
            <span class="s2">&quot;loa_intercept&quot;</span><span class="p">,</span>
            <span class="s2">&quot;loa_slope&quot;</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="n">boot_ci</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
                <span class="n">sleep_stats</span><span class="p">,</span> <span class="n">column_order</span>
            <span class="p">]</span>  <span class="c1"># Extract the relevant sleep stats and columns</span>
            <span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;sleep_stat&quot;</span><span class="p">)</span>  <span class="c1"># Group so the bootstrapping is applied once to each sleep stat</span>
            <span class="c1"># Apply the bootstrap function, where tuple(df.to_numpy().T) convert the 3 columns</span>
            <span class="c1"># of the passed dataframe to a tuple of 3 1D arrays</span>
            <span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">df</span><span class="p">:</span> <span class="n">sps</span><span class="o">.</span><span class="n">bootstrap</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="n">get_vars</span><span class="p">,</span> <span class="o">**</span><span class="n">bs_kwargs</span><span class="p">))</span>
            <span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">res</span><span class="p">:</span> <span class="n">res</span><span class="o">.</span><span class="n">confidence_interval</span><span class="p">)</span>  <span class="c1"># Pull high/low CIs out of the results object</span>
            <span class="o">.</span><span class="n">explode</span><span class="p">()</span>  <span class="c1"># Break high and low CIs into separate rows</span>
            <span class="o">.</span><span class="n">to_frame</span><span class="p">(</span><span class="s2">&quot;value&quot;</span><span class="p">)</span>  <span class="c1"># Convert to dataframe and name column</span>
            <span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">interval</span><span class="o">=</span><span class="n">interval_order</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">sleep_stats</span><span class="p">))</span>  <span class="c1"># Add a column indicating interval</span>
            <span class="o">.</span><span class="n">explode</span><span class="p">(</span><span class="s2">&quot;value&quot;</span><span class="p">)</span>  <span class="c1"># Break low CI variables and high CI variables out of arrays</span>
            <span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">variable</span><span class="o">=</span><span class="n">variable_order</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">sleep_stats</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># Add column indicating variabl</span>
            <span class="o">.</span><span class="n">pivot</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;variable&quot;</span><span class="p">,</span> <span class="s2">&quot;interval&quot;</span><span class="p">],</span> <span class="n">values</span><span class="o">=</span><span class="s2">&quot;value&quot;</span><span class="p">)</span>  <span class="c1"># Go long to wide format</span>
            <span class="o">.</span><span class="n">sort_index</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Sort MultiIndex columns for cleanliness</span>
        <span class="p">)</span>
        <span class="c1"># Merge with existing CI dataframe</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ci</span><span class="p">[</span><span class="s2">&quot;boot&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ci</span><span class="p">[</span><span class="s2">&quot;boot&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">boot_ci</span><span class="p">)</span>

<div class="viewcode-block" id="SleepStatsAgreement.get_table"><a class="viewcode-back" href="../../generated/yasa.SleepStatsAgreement.html#yasa.SleepStatsAgreement.get_table">[docs]</a>    <span class="k">def</span> <span class="nf">get_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bias_method</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="n">loa_method</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="n">ci_method</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="n">fstrings</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a :py:class:`~pandas.DataFrame` with bias, loa, bias_ci, loa_ci as string equations.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bias_method : str</span>
<span class="sd">            If ``&#39;parm&#39;`` (i.e., parametric), bias is always represented as the mean difference</span>
<span class="sd">            (observed minus reference).</span>
<span class="sd">            If ``&#39;regr&#39;`` (i.e., regression), bias is always represented as a regression equation.</span>
<span class="sd">            If ``&#39;auto&#39;`` (default), bias is represented as a regression equation for sleep</span>
<span class="sd">            statistics where the score differences are proportionally biased and as the mean</span>
<span class="sd">            difference otherwise.</span>
<span class="sd">        loa_method : str</span>
<span class="sd">            If ``&#39;parm&#39;`` (i.e., parametric), limits of agreement are always represented as</span>
<span class="sd">            bias +/- 1.96 standard deviations (where 1.96 can be adjusted through the ``agreement``</span>
<span class="sd">            parameter).</span>
<span class="sd">            If ``&#39;regr&#39;`` (i.e., regression), limits of agreement are always represented as a</span>
<span class="sd">            regression equation.</span>
<span class="sd">            If ``&#39;auto&#39;`` (default), limits of agreement are represented as a regression equation</span>
<span class="sd">            for sleep statistics where the score differences are proportionally biased and as</span>
<span class="sd">            bias +/- 1.96 standard deviation otherwise.</span>
<span class="sd">        ci_method : str</span>
<span class="sd">            If ``&#39;parm&#39;`` (i.e., parametric), confidence intervals are always represented using a</span>
<span class="sd">            standard t-distribution.</span>
<span class="sd">            If ``&#39;boot&#39;`` (i.e., bootstrap), confidence intervals are always represented using a</span>
<span class="sd">            bootstrap resampling procedure.</span>
<span class="sd">            If  ``&#39;auto&#39;`` (default), confidence intervals are represented using a bootstrap</span>
<span class="sd">            resampling procedure for sleep statistics where the distribution of score differences is</span>
<span class="sd">            non-normal and using a standard t-distribution otherwise.</span>
<span class="sd">        fstrings : dict</span>
<span class="sd">            Optional custom strings for formatting cells.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        table : :py:class:`pandas.DataFrame`</span>
<span class="sd">            A :py:class:`~pandas.DataFrame` of string representations for bias, limits of agreement,</span>
<span class="sd">            and their confidence intervals for all sleep statistics.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bias_method</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="s2">&quot;`bias_method` must be a string&quot;</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">bias_method</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bias_method_opts</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;`bias_method` must be one of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_bias_method_opts</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loa_method</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="s2">&quot;`loa_method` must be a string&quot;</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">loa_method</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loa_method_opts</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;`loa_method` must be one of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_loa_method_opts</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fstrings</span><span class="p">,</span> <span class="nb">dict</span><span class="p">),</span> <span class="s2">&quot;`fstrings` must be a dictionary&quot;</span>
        <span class="c1"># Agreement gets adjusted when LoA is modeled</span>
        <span class="n">loa_regr_agreement</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_agreement</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">fstrings</span><span class="p">:</span>
            <span class="n">fstrings</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;bias_parm&quot;</span><span class="p">:</span> <span class="s2">&quot;</span><span class="si">{bias_parm_center:.2f}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="s2">&quot;bias_regr&quot;</span><span class="p">:</span> <span class="s2">&quot;</span><span class="si">{bias_intercept_center:.2f}</span><span class="s2"> + </span><span class="si">{bias_slope_center:.2f}</span><span class="s2">x&quot;</span><span class="p">,</span>
                <span class="s2">&quot;loa_parm&quot;</span><span class="p">:</span> <span class="s2">&quot;</span><span class="si">{lloa_parm_center:.2f}</span><span class="s2">, </span><span class="si">{uloa_parm_center:.2f}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="s2">&quot;loa_regr&quot;</span><span class="p">:</span> <span class="p">(</span>
                    <span class="s2">&quot;Bias </span><span class="se">\u00B1</span><span class="s2"> </span><span class="si">{loa_regr_agreement:.2f}</span><span class="s2"> &quot;</span>
                    <span class="s2">&quot;* (</span><span class="si">{loa_intercept_center:.2f}</span><span class="s2"> + </span><span class="si">{loa_slope_center:.2f}</span><span class="s2">x)&quot;</span>
                <span class="p">),</span>
                <span class="s2">&quot;bias_parm_ci&quot;</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;[</span><span class="si">{bias_parm_lower:.2f}</span><span class="s2">, </span><span class="si">{bias_parm_upper:.2f}</span><span class="s2">]&quot;</span><span class="p">),</span>
                <span class="s2">&quot;bias_regr_ci&quot;</span><span class="p">:</span> <span class="p">(</span>
                    <span class="s2">&quot;[</span><span class="si">{bias_intercept_lower:.2f}</span><span class="s2">, </span><span class="si">{bias_intercept_upper:.2f}</span><span class="s2">], &quot;</span>
                    <span class="s2">&quot;[</span><span class="si">{bias_slope_lower:.2f}</span><span class="s2">, </span><span class="si">{bias_slope_upper:.2f}</span><span class="s2">]&quot;</span>
                <span class="p">),</span>
                <span class="s2">&quot;loa_parm_ci&quot;</span><span class="p">:</span> <span class="p">(</span>
                    <span class="s2">&quot;[</span><span class="si">{lloa_parm_lower:.2f}</span><span class="s2">, </span><span class="si">{lloa_parm_upper:.2f}</span><span class="s2">], &quot;</span>
                    <span class="s2">&quot;[</span><span class="si">{uloa_parm_lower:.2f}</span><span class="s2">, </span><span class="si">{uloa_parm_upper:.2f}</span><span class="s2">]&quot;</span>
                <span class="p">),</span>
                <span class="s2">&quot;loa_regr_ci&quot;</span><span class="p">:</span> <span class="p">(</span>
                    <span class="s2">&quot;[</span><span class="si">{loa_intercept_lower:.2f}</span><span class="s2">, </span><span class="si">{loa_intercept_upper:.2f}</span><span class="s2">], &quot;</span>
                    <span class="s2">&quot;[</span><span class="si">{loa_slope_lower:.2f}</span><span class="s2">, </span><span class="si">{loa_slope_upper:.2f}</span><span class="s2">]&quot;</span>
                <span class="p">),</span>
            <span class="p">}</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">summary</span><span class="p">(</span><span class="n">ci_method</span><span class="o">=</span><span class="n">ci_method</span><span class="p">)</span>
        <span class="n">values</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">)</span>  <span class="c1"># Convert MultiIndex columns to Index</span>
        <span class="c1"># Add a column of regr agreement so it can be used as variable</span>
        <span class="n">values</span><span class="p">[</span><span class="s2">&quot;loa_regr_agreement&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">loa_regr_agreement</span>

        <span class="k">def</span> <span class="nf">format_all_str</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">fstrings_dict</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">var</span><span class="p">:</span> <span class="n">fstr</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">row</span><span class="p">)</span> <span class="k">for</span> <span class="n">var</span><span class="p">,</span> <span class="n">fstr</span> <span class="ow">in</span> <span class="n">fstrings_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="n">all_strings</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">format_all_str</span><span class="p">,</span> <span class="n">fstrings_dict</span><span class="o">=</span><span class="n">fstrings</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bias_method</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span><span class="p">:</span>
            <span class="n">bias_parm_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">auto_methods</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s2">&quot;bias == &#39;parm&#39;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">bias_method</span> <span class="o">==</span> <span class="s2">&quot;parm&quot;</span><span class="p">:</span>
            <span class="n">bias_parm_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sleep_statistics</span>
        <span class="k">elif</span> <span class="n">bias_method</span> <span class="o">==</span> <span class="s2">&quot;regr&quot;</span><span class="p">:</span>
            <span class="n">bias_parm_idx</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">loa_method</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span><span class="p">:</span>
            <span class="n">loa_parm_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">auto_methods</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s2">&quot;loa == &#39;parm&#39;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">loa_method</span> <span class="o">==</span> <span class="s2">&quot;parm&quot;</span><span class="p">:</span>
            <span class="n">loa_parm_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sleep_statistics</span>
        <span class="k">elif</span> <span class="n">loa_method</span> <span class="o">==</span> <span class="s2">&quot;regr&quot;</span><span class="p">:</span>
            <span class="n">loa_parm_idx</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">bias_regr_idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">ss</span> <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sleep_statistics</span> <span class="k">if</span> <span class="n">ss</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">bias_parm_idx</span><span class="p">]</span>
        <span class="n">loa_regr_idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">ss</span> <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sleep_statistics</span> <span class="k">if</span> <span class="n">ss</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">loa_parm_idx</span><span class="p">]</span>
        <span class="n">bias_parm</span> <span class="o">=</span> <span class="n">all_strings</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">bias_parm_idx</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;bias_parm&quot;</span><span class="p">,</span> <span class="s2">&quot;bias_parm_ci&quot;</span><span class="p">]]</span>
        <span class="n">bias_regr</span> <span class="o">=</span> <span class="n">all_strings</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">bias_regr_idx</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;bias_regr&quot;</span><span class="p">,</span> <span class="s2">&quot;bias_regr_ci&quot;</span><span class="p">]]</span>
        <span class="n">bias_parm</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">bias_parm</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;_parm&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">bias_regr</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">bias_parm</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;_regr&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">bias</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">bias_parm</span><span class="p">,</span> <span class="n">bias_regr</span><span class="p">])</span>
        <span class="n">loa_parm</span> <span class="o">=</span> <span class="n">all_strings</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">loa_parm_idx</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;loa_parm&quot;</span><span class="p">,</span> <span class="s2">&quot;loa_parm_ci&quot;</span><span class="p">]]</span>
        <span class="n">loa_regr</span> <span class="o">=</span> <span class="n">all_strings</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">loa_regr_idx</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;loa_regr&quot;</span><span class="p">,</span> <span class="s2">&quot;loa_regr_ci&quot;</span><span class="p">]]</span>
        <span class="n">loa_parm</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">loa_parm</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;_parm&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">loa_regr</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">loa_regr</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;_regr&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">loa</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">loa_parm</span><span class="p">,</span> <span class="n">loa_regr</span><span class="p">])</span>
        <span class="n">table</span> <span class="o">=</span> <span class="n">bias</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">loa</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="s2">&quot;1:1&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">sort_index</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">table</span></div>

<div class="viewcode-block" id="SleepStatsAgreement.summary"><a class="viewcode-back" href="../../generated/yasa.SleepStatsAgreement.html#yasa.SleepStatsAgreement.summary">[docs]</a>    <span class="k">def</span> <span class="nf">summary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ci_method</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a :py:class:`~pandas.DataFrame` that includes all calculated metrics:</span>
<span class="sd">        * Parametric bias</span>
<span class="sd">        * Parametric lower and upper limits of agreement</span>
<span class="sd">        * Regression intercept and slope for modeled bias</span>
<span class="sd">        * Regression intercept and slope for modeled limits of agreement</span>
<span class="sd">        * Lower and upper confidence intervals for all metrics</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ci_method : str</span>
<span class="sd">            If ``&#39;parm&#39;`` (i.e., parametric), confidence intervals are always represented using a</span>
<span class="sd">            standard t-distribution.</span>
<span class="sd">            If ``&#39;boot&#39;`` (i.e., bootstrap), confidence intervals are always represented using a</span>
<span class="sd">            bootstrap resampling procedure.</span>
<span class="sd">            If  ``&#39;auto&#39;`` (default), confidence intervals are represented using a bootstrap</span>
<span class="sd">            resampling procedure for sleep statistics where the distribution of score differences is</span>
<span class="sd">            non-normal and using a standard t-distribution otherwise.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        summary : :py:class:`pandas.DataFrame`</span>
<span class="sd">            A :py:class:`~pandas.DataFrame` of string representations for bias, limits of agreement,</span>
<span class="sd">            and their confidence intervals for all sleep statistics.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ci_method</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="s2">&quot;`ci_method` must be a string&quot;</span>
        <span class="k">assert</span> <span class="n">ci_method</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ci_method_opts</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;`ci_method` must be in </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_ci_method_opts</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="c1"># Make sure relevant sleep statistics have bootstrapped CIs, and generate them if not</span>
        <span class="k">if</span> <span class="n">ci_method</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;boot&quot;</span><span class="p">,</span> <span class="s2">&quot;auto&quot;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">ci_method</span> <span class="o">==</span> <span class="s2">&quot;boot&quot;</span><span class="p">:</span>
                <span class="n">sleep_stats_to_boot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sleep_statistics</span>
            <span class="k">elif</span> <span class="n">ci_method</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span><span class="p">:</span>
                <span class="n">sleep_stats_to_boot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">auto_methods</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s2">&quot;ci == &#39;boot&#39;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="c1"># Remove any sleep stats already bootstrapped CIs (eg if &quot;boot&quot; is callaed after &quot;auto&quot;)</span>
            <span class="n">sleep_stats_booted</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ci</span><span class="p">[</span><span class="s2">&quot;boot&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">index</span>
            <span class="n">sleep_stats_to_boot</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sleep_stats_to_boot</span> <span class="k">if</span> <span class="n">s</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sleep_stats_booted</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">sleep_stats_to_boot</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_generate_bootstrap_ci</span><span class="p">(</span><span class="n">sleep_stats</span><span class="o">=</span><span class="n">sleep_stats_to_boot</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ci_method</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span><span class="p">:</span>
            <span class="n">parm_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">auto_methods</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s2">&quot;ci == &#39;parm&#39;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
            <span class="n">boot_idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">ss</span> <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sleep_statistics</span> <span class="k">if</span> <span class="n">ss</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">parm_idx</span><span class="p">]</span>
            <span class="n">parm_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ci</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">parm_idx</span><span class="p">,</span> <span class="s2">&quot;parm&quot;</span><span class="p">]</span>
            <span class="n">boot_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ci</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">boot_idx</span><span class="p">,</span> <span class="s2">&quot;boot&quot;</span><span class="p">]</span>
            <span class="n">ci_vals</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">parm_vals</span><span class="p">,</span> <span class="n">boot_vals</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ci_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ci</span><span class="p">[</span><span class="n">ci_method</span><span class="p">]</span>
        <span class="c1"># Add an extra level to values columns, indicating they are the center interval</span>
        <span class="n">centr_vals</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">({</span><span class="s2">&quot;center&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vals</span><span class="p">},</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;interval&quot;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">swaplevel</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">summary</span> <span class="o">=</span> <span class="n">centr_vals</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">ci_vals</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="s2">&quot;1:1&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">summary</span><span class="o">.</span><span class="n">sort_index</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="SleepStatsAgreement.calibrate"><a class="viewcode-back" href="../../generated/yasa.SleepStatsAgreement.html#yasa.SleepStatsAgreement.calibrate">[docs]</a>    <span class="k">def</span> <span class="nf">calibrate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">bias_method</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="n">adjust_all</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calibrate a :py:class:`~pandas.DataFrame` of sleep statistics from a new scorer based on</span>
<span class="sd">        observed biases in ``obs_data``/``obs_scorer``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : :py:class:`pandas.DataFrame`</span>
<span class="sd">            A :py:class:`pandas.DataFrame` with sleep statistics from an observed scorer.</span>
<span class="sd">            Rows are unique observations and columns are unique sleep statistics.</span>
<span class="sd">        bias_method : str</span>
<span class="sd">            If ``&#39;parm&#39;``, sleep statistics are always adjusted based on parametric bias.</span>
<span class="sd">            If ``&#39;regr&#39;``, sleep statistics are always adjusted based on regression-modeled bias.</span>
<span class="sd">            If ``&#39;auto&#39;`` (default), bias sleep statistics are adjusted by either ``&#39;parm&#39;`` or</span>
<span class="sd">            ``&#39;regr&#39;``, depending on assumption violations.</span>

<span class="sd">            .. seealso:: :py:meth:`~yasa.SleepStatsAgreement.summary`</span>

<span class="sd">        adjust_all: bool</span>
<span class="sd">            If False (default), only adjust values for sleep statistics that showed a statistically</span>
<span class="sd">            significant bias in the ``obs_data``. If True, adjust values for all sleep statistics.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        calibrated_data : :py:class:`pandas.DataFrame`</span>
<span class="sd">            A :py:class:`~pandas.DataFrame` with calibrated sleep statistics.</span>

<span class="sd">        .. seealso:: :py:meth:`~yasa.SleepStatsAgreement.calibrate`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">),</span> <span class="s2">&quot;`data` must be a pandas DataFrame&quot;</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span>
            <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sleep_statistics</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">data</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;all columns of `data` must be valid sleep statistics: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">sleep_statistics</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bias_method</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="s2">&quot;`bias_method` must be a string&quot;</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">bias_method</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bias_method_opts</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;`bias_method` must be one of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_bias_method_opts</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">adjust_all</span><span class="p">,</span> <span class="nb">bool</span><span class="p">),</span> <span class="s2">&quot;`adjust_all` must be True or False&quot;</span>
        <span class="n">parm_adjusted</span> <span class="o">=</span> <span class="n">data</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vals</span><span class="p">[</span><span class="s2">&quot;bias_parm&quot;</span><span class="p">]</span>
        <span class="n">regr_adjusted</span> <span class="o">=</span> <span class="n">data</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vals</span><span class="p">[</span><span class="s2">&quot;bias_slope&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vals</span><span class="p">[</span><span class="s2">&quot;bias_intercept&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">bias_method</span> <span class="o">==</span> <span class="s2">&quot;parm&quot;</span><span class="p">:</span>
            <span class="n">calibrated_data</span> <span class="o">=</span> <span class="n">parm_adjusted</span>
        <span class="k">elif</span> <span class="n">bias_method</span> <span class="o">==</span> <span class="s2">&quot;regr&quot;</span><span class="p">:</span>
            <span class="n">calibrated_data</span> <span class="o">=</span> <span class="n">regr_adjusted</span>
        <span class="k">elif</span> <span class="n">bias_method</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span><span class="p">:</span>
            <span class="n">parm_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">auto_methods</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s2">&quot;bias == &#39;parm&#39;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
            <span class="n">regr_idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">ss</span> <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sleep_statistics</span> <span class="k">if</span> <span class="n">ss</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">parm_idx</span><span class="p">]</span>
            <span class="n">calibrated_data</span> <span class="o">=</span> <span class="n">parm_adjusted</span><span class="p">[</span><span class="n">parm_idx</span><span class="p">]</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">regr_adjusted</span><span class="p">[</span><span class="n">regr_idx</span><span class="p">])</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">adjust_all</span><span class="p">:</span>
            <span class="c1"># Put the raw values back for sleep stats that don&#39;t show statistical bias</span>
            <span class="n">unbiased_sstats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">assumptions</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s2">&quot;unbiased == True&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
            <span class="n">calibrated_data</span><span class="p">[</span><span class="n">unbiased_sstats</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">unbiased_sstats</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">calibrated_data</span></div>

<div class="viewcode-block" id="SleepStatsAgreement.get_calibration_func"><a class="viewcode-back" href="../../generated/yasa.SleepStatsAgreement.html#yasa.SleepStatsAgreement.get_calibration_func">[docs]</a>    <span class="k">def</span> <span class="nf">get_calibration_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sleep_stat</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a function for calibrating a specific sleep statistic, based on observed biases in</span>
<span class="sd">        ``obs_data``/``obs_scorer``.</span>

<span class="sd">        .. seealso:: :py:meth:`~yasa.SleepStatsAgreement.calibrate`</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; ssa = yasa.SleepStatsAgreement(...)</span>
<span class="sd">        &gt;&gt;&gt; calibrate_rem = ssa.get_calibration_func(&quot;REM&quot;)</span>
<span class="sd">        &gt;&gt;&gt; new_obs_rem_vals = np.array([50, 40, 30, 20])</span>
<span class="sd">        &gt;&gt;&gt; calibrate_rem(new_obs_rem_vals)</span>
<span class="sd">        &gt;&gt;&gt; calibrate_rem(new_obs_rem_vals)</span>
<span class="sd">        array([50, 40, 30, 20])</span>
<span class="sd">        &gt;&gt;&gt; calibrate_rem(new_obs_rem_vals, bias_test=False)</span>
<span class="sd">        array([42.825, 32.825, 22.825, 12.825])</span>
<span class="sd">        &gt;&gt;&gt; calibrate_rem(new_obs_rem_vals, bias_test=False, method=&quot;regr&quot;)</span>
<span class="sd">        array([ -9.33878878,  -9.86815607, -10.39752335, -10.92689064])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sleep_stat</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="s2">&quot;`sleep_stat` must be a string&quot;</span>
        <span class="k">assert</span> <span class="n">sleep_stat</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sleep_statistics</span><span class="p">,</span> <span class="s2">&quot;`sleep_stat` must be a valid sleep statistic&quot;</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;bias_parm&quot;</span><span class="p">,</span> <span class="s2">&quot;bias_slope&quot;</span><span class="p">,</span> <span class="s2">&quot;bias_intercept&quot;</span><span class="p">]</span>
        <span class="n">parm</span><span class="p">,</span> <span class="n">slope</span><span class="p">,</span> <span class="n">intercept</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vals</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sleep_stat</span><span class="p">,</span> <span class="n">columns</span><span class="p">]</span>
        <span class="n">auto_method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">auto_methods</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">sleep_stat</span><span class="p">,</span> <span class="s2">&quot;bias&quot;</span><span class="p">]</span>
        <span class="n">not_biased</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">assumptions</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">sleep_stat</span><span class="p">,</span> <span class="s2">&quot;unbiased&quot;</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">calibration_func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="n">adjust_all</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Calibrate values for sleep statistic.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            x : array</span>
<span class="sd">                Values to be calibrated</span>
<span class="sd">            method: str</span>
<span class="sd">                Method of bias calculation for calibration (``&#39;parm&#39;``, ``&#39;regr&#39;``, or ``&#39;auto&#39;``).</span>
<span class="sd">            adjust_all : bool</span>
<span class="sd">                If False, only adjust sleep stat if observed bias was statistically significant.</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            x_calibrated : :py:class:`numpy.array`</span>
<span class="sd">                An array of calibrated x values.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">method</span> <span class="o">=</span> <span class="n">auto_method</span> <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span> <span class="k">else</span> <span class="n">method</span>
            <span class="k">if</span> <span class="n">not_biased</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">adjust_all</span><span class="p">:</span>  <span class="c1"># Return input if sleep stat is not statstclly biased</span>
                <span class="k">return</span> <span class="n">x</span>
            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;parm&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">parm</span>
            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;regr&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">slope</span> <span class="o">+</span> <span class="n">intercept</span>

        <span class="k">return</span> <span class="n">calibration_func</span></div></div>
</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
      
    </p>
    <p>
        &copy; Copyright 2018-2024, Dr. Raphael Vallat, Center for Human Sleep Science, UC Berkeley.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.4.0.<br/>
    </p>
  </div>
</footer>
  </body>
</html>