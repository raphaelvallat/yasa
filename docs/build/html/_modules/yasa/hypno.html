<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>yasa.hypno &#8212; yasa 0.6.5 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/bootstrap-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-bootstrap.5fd3999ee7762ccc51105388f4a9d115.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../../_static/js/jquery-1.12.4.min.js"></script>
<script type="text/javascript" src="../../_static/js/jquery-fix.js"></script>
<script type="text/javascript" src="../../_static/bootstrap-3.4.1/js/bootstrap.min.js"></script>
<script type="text/javascript" src="../../_static/bootstrap-sphinx.js"></script>

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../index.html"><span><img src="../../_static/yasa_128x128.png"></span>
          yasa</a>
        <span class="navbar-text navbar-version pull-left"><b>0.6.5</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../../api.html">API</a></li>
                <li><a href="../../quickstart.html">Quickstart</a></li>
                <li><a href="../../faq.html">FAQ</a></li>
                <li><a href="../../changelog.html">What's new</a></li>
                <li><a href="../../contributing.html">Contribute</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"></ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <h1>Source code for yasa.hypno</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Hypnogram-related functions and class.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">mne</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="c1"># import warnings</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">yasa.io</span> <span class="kn">import</span> <span class="n">set_log_level</span>
<span class="kn">from</span> <span class="nn">yasa.plotting</span> <span class="kn">import</span> <span class="n">plot_hypnogram</span>
<span class="kn">from</span> <span class="nn">yasa.sleepstats</span> <span class="kn">import</span> <span class="n">transition_matrix</span>
<span class="kn">from</span> <span class="nn">yasa.evaluation</span> <span class="kn">import</span> <span class="n">EpochByEpochAgreement</span>
<span class="kn">from</span> <span class="nn">pandas.api.types</span> <span class="kn">import</span> <span class="n">CategoricalDtype</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;Hypnogram&quot;</span><span class="p">,</span>
    <span class="s2">&quot;hypno_str_to_int&quot;</span><span class="p">,</span>
    <span class="s2">&quot;hypno_int_to_str&quot;</span><span class="p">,</span>
    <span class="s2">&quot;hypno_upsample_to_sf&quot;</span><span class="p">,</span>
    <span class="s2">&quot;hypno_upsample_to_data&quot;</span><span class="p">,</span>
    <span class="s2">&quot;hypno_find_periods&quot;</span><span class="p">,</span>
    <span class="s2">&quot;load_profusion_hypno&quot;</span><span class="p">,</span>
    <span class="s2">&quot;simulate_hypnogram&quot;</span><span class="p">,</span>
<span class="p">]</span>


<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;yasa&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="Hypnogram"><a class="viewcode-back" href="../../generated/yasa.Hypnogram.html#yasa.Hypnogram">[docs]</a><span class="k">class</span> <span class="nc">Hypnogram</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Experimental class for manipulating hypnogram in YASA (dev).</span>

<span class="sd">    Starting with v0.7, YASA will take a more object-oriented approach to hypnograms. That is,</span>
<span class="sd">    hypnograms are now stored as a class (aka object), which comes with its own attributes and</span>
<span class="sd">    functions. Furthermore, YASA does not allow integer values to define the stages anymore.</span>
<span class="sd">    Instead, users must pass an array of strings with the actual stage names</span>
<span class="sd">    (e.g. [&quot;WAKE&quot;, &quot;WAKE&quot;, &quot;N1&quot;, ..., &quot;REM&quot;, &quot;REM&quot;]).</span>

<span class="sd">    .. versionadded:: 0.7.0</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    values : array_like</span>
<span class="sd">        A vector of stage values, represented as strings. See some examples below:</span>

<span class="sd">        * 2-stages hypnogram (Wake/Sleep): ``[&quot;W&quot;, &quot;S&quot;, &quot;S&quot;, &quot;W&quot;, &quot;S&quot;]``</span>
<span class="sd">        * 3-stages (Wake/NREM/REM): ``pd.Series([&quot;WAKE&quot;, &quot;NREM&quot;, &quot;NREM&quot;, &quot;REM&quot;, &quot;REM&quot;])``</span>
<span class="sd">        * 4-stages (Wake/Light/Deep/REM): ``np.array([&quot;Wake&quot;, &quot;Light&quot;, &quot;Deep&quot;, &quot;Deep&quot;])``</span>
<span class="sd">        * 5-stages (default): ``[&quot;N1&quot;, &quot;N1&quot;, &quot;N2&quot;, &quot;N3&quot;, &quot;N2&quot;, &quot;REM&quot;, &quot;W&quot;]``</span>

<span class="sd">        Artefacts (&quot;Art&quot;) and unscored (&quot;Uns&quot;) epochs are always allowed regardless of the</span>
<span class="sd">        number of stages in the hypnogram.</span>

<span class="sd">        .. note:: Abbreviated or full spellings for the stages are allowed, as well as</span>
<span class="sd">            lower/upper/mixed case. Internally, YASA will convert the stages to to full spelling</span>
<span class="sd">            and uppercase (e.g. &quot;w&quot; -&gt; &quot;WAKE&quot;).</span>
<span class="sd">    n_stages : int</span>
<span class="sd">        Whether ``values`` comes from a 2, 3, 4 or 5-stages hypnogram. Default is 5 stages, meaning</span>
<span class="sd">        that the following sleep stages are allowed: N1, N2, N3, REM, WAKE.</span>
<span class="sd">    freq : str</span>
<span class="sd">        A pandas frequency string indicating the frequency resolution of the hypnogram. Default is</span>
<span class="sd">        &quot;30s&quot; meaning that each value in the hypnogram represents a 30-seconds epoch.</span>
<span class="sd">        Examples: &quot;1min&quot;, &quot;10s&quot;, &quot;15min&quot;. A full list of accepted values can be found at</span>
<span class="sd">        https://pandas.pydata.org/docs/user_guide/timeseries.html#timeseries-offset-aliases</span>

<span class="sd">        ``freq`` will be passed to the :py:func:`pandas.date_range` function to create the time</span>
<span class="sd">        index of the hypnogram.</span>
<span class="sd">    start : str or datetime</span>
<span class="sd">        An optional string indicating the starting datetime of the hypnogram</span>
<span class="sd">        (e.g. &quot;2022-12-15 22:30:00&quot;). If ``start`` is specified and valid, the index of the</span>
<span class="sd">        hypnogram will be a :py:class:`pandas.DatetimeIndex`. Otherwise it will be a</span>
<span class="sd">        :py:class:`pandas.RangeIndex`, indicating the epoch number.</span>
<span class="sd">    scorer : str</span>
<span class="sd">        An optional string indicating the scorer name. If specified, this will be set as the name</span>
<span class="sd">        of the :py:class:`pandas.Series`, otherwise the name will be set to &quot;Stage&quot;.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Create a 2-stages hypnogram</span>

<span class="sd">    &gt;&gt;&gt; from yasa import Hypnogram</span>
<span class="sd">    &gt;&gt;&gt; values = [&quot;W&quot;, &quot;W&quot;, &quot;W&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;W&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;]</span>
<span class="sd">    &gt;&gt;&gt; hyp = Hypnogram(values, n_stages=2)</span>
<span class="sd">    &gt;&gt;&gt; hyp</span>
<span class="sd">    &lt;Hypnogram | 12 epochs x 30s (6.00 minutes), 2 stages&gt;</span>
<span class="sd">     - Use `.hypno` to get the string values as a pandas.Series</span>
<span class="sd">     - Use `.as_int()` to get the integer values as a pandas.Series</span>
<span class="sd">     - Use `.plot_hypnogram()` to plot the hypnogram</span>
<span class="sd">    See the online documentation for more details.</span>

<span class="sd">    We can access the actual values, which are stored as a :py:class:`pandas.Series`, with:</span>

<span class="sd">    &gt;&gt;&gt; hyp.hypno</span>
<span class="sd">    Epoch</span>
<span class="sd">    0      WAKE</span>
<span class="sd">    1      WAKE</span>
<span class="sd">    2      WAKE</span>
<span class="sd">    3     SLEEP</span>
<span class="sd">    4     SLEEP</span>
<span class="sd">    5     SLEEP</span>
<span class="sd">    6     SLEEP</span>
<span class="sd">    7     SLEEP</span>
<span class="sd">    8      WAKE</span>
<span class="sd">    9     SLEEP</span>
<span class="sd">    10    SLEEP</span>
<span class="sd">    11    SLEEP</span>
<span class="sd">    Name: Stage, dtype: category</span>
<span class="sd">    Categories (4, object): [&#39;WAKE&#39;, &#39;SLEEP&#39;, &#39;ART&#39;, &#39;UNS&#39;]</span>

<span class="sd">    &gt;&gt;&gt; # Number of epochs in the hypnogram</span>
<span class="sd">    &gt;&gt;&gt; hyp.n_epochs</span>
<span class="sd">    12</span>

<span class="sd">    &gt;&gt;&gt; # Total duration of the hypnogram, in minutes (12 epochs * 30 seconds = 6 minutes)</span>
<span class="sd">    &gt;&gt;&gt; hyp.duration</span>
<span class="sd">    6.0</span>

<span class="sd">    &gt;&gt;&gt; # Default mapping from strings to integers. Can be changed with `hyp.mapping = {}`</span>
<span class="sd">    &gt;&gt;&gt; hyp.mapping</span>
<span class="sd">    {&#39;WAKE&#39;: 0, &#39;SLEEP&#39;: 1, &#39;ART&#39;: -1, &#39;UNS&#39;: -2}</span>

<span class="sd">    &gt;&gt;&gt; # Get the hypnogram Series integer values</span>
<span class="sd">    &gt;&gt;&gt; hyp.as_int()</span>
<span class="sd">    Epoch</span>
<span class="sd">    0     0</span>
<span class="sd">    1     0</span>
<span class="sd">    2     0</span>
<span class="sd">    3     1</span>
<span class="sd">    4     1</span>
<span class="sd">    5     1</span>
<span class="sd">    6     1</span>
<span class="sd">    7     1</span>
<span class="sd">    8     0</span>
<span class="sd">    9     1</span>
<span class="sd">    10    1</span>
<span class="sd">    11    1</span>
<span class="sd">    Name: Stage, dtype: int16</span>

<span class="sd">    &gt;&gt;&gt; # Calculate the summary sleep statistics</span>
<span class="sd">    &gt;&gt;&gt; hyp.sleep_statistics()</span>
<span class="sd">    {&#39;TIB&#39;: 6.0,</span>
<span class="sd">     &#39;SPT&#39;: 4.5,</span>
<span class="sd">     &#39;WASO&#39;: 0.5,</span>
<span class="sd">     &#39;TST&#39;: 4.0,</span>
<span class="sd">     &#39;SE&#39;: 66.6667,</span>
<span class="sd">     &#39;SME&#39;: 88.8889,</span>
<span class="sd">     &#39;SFI&#39;: 7.5,</span>
<span class="sd">     &#39;SOL&#39;: 1.5,</span>
<span class="sd">     &#39;SOL_5min&#39;: nan,</span>
<span class="sd">     &#39;WAKE&#39;: 2.0}</span>

<span class="sd">    &gt;&gt;&gt; # Get the state-transition matrix</span>
<span class="sd">    &gt;&gt;&gt; counts, probs = hyp.transition_matrix()</span>
<span class="sd">    &gt;&gt;&gt; counts</span>
<span class="sd">    To Stage    WAKE  SLEEP</span>
<span class="sd">    From Stage</span>
<span class="sd">    WAKE           2      2</span>
<span class="sd">    SLEEP          1      6</span>

<span class="sd">    All these methods and properties are also valid with a 5-stages hypnogram. In the example below,</span>
<span class="sd">    we use the :py:func:`yasa.simulate_hypnogram` to generate a plausible 5-stages hypnogram with a</span>
<span class="sd">    30-seconds resolution. A random seed is specified to ensure that we get reproducible results.</span>
<span class="sd">    Lastly, we set an actual start time to the hypnogram. As a result, the index of the resulting</span>
<span class="sd">    hypnogram is a :py:class:`pandas.DatetimeIndex`.</span>

<span class="sd">    &gt;&gt;&gt; from yasa import simulate_hypnogram</span>
<span class="sd">    &gt;&gt;&gt; hyp = simulate_hypnogram(</span>
<span class="sd">    ...     tib=500, n_stages=5, start=&quot;2022-12-15 22:30:00&quot;, scorer=&quot;S1&quot;, seed=42)</span>
<span class="sd">    &gt;&gt;&gt; hyp</span>
<span class="sd">    &lt;Hypnogram | 1000 epochs x 30s (500.00 minutes), 5 stages, scored by S1&gt;</span>
<span class="sd">     - Use `.hypno` to get the string values as a pandas.Series</span>
<span class="sd">     - Use `.as_int()` to get the integer values as a pandas.Series</span>
<span class="sd">     - Use `.plot_hypnogram()` to plot the hypnogram</span>
<span class="sd">    See the online documentation for more details.</span>

<span class="sd">    &gt;&gt;&gt; hyp.hypno</span>
<span class="sd">    Time</span>
<span class="sd">    2022-12-15 22:30:00    WAKE</span>
<span class="sd">    2022-12-15 22:30:30    WAKE</span>
<span class="sd">    2022-12-15 22:31:00    WAKE</span>
<span class="sd">    2022-12-15 22:31:30    WAKE</span>
<span class="sd">    2022-12-15 22:32:00    WAKE</span>
<span class="sd">                        ...</span>
<span class="sd">    2022-12-16 06:47:30      N2</span>
<span class="sd">    2022-12-16 06:48:00      N2</span>
<span class="sd">    2022-12-16 06:48:30      N2</span>
<span class="sd">    2022-12-16 06:49:00      N2</span>
<span class="sd">    2022-12-16 06:49:30      N2</span>
<span class="sd">    Freq: 30S, Name: S1, Length: 1000, dtype: category</span>
<span class="sd">    Categories (7, object): [&#39;WAKE&#39;, &#39;N1&#39;, &#39;N2&#39;, &#39;N3&#39;, &#39;REM&#39;, &#39;ART&#39;, &#39;UNS&#39;]</span>

<span class="sd">    The summary sleep statistics will include more items with a 5-stages hypnogram than a 2-stages</span>
<span class="sd">    hypnogram, i.e. the amount and percentage of each sleep stage, the REM latency, etc.</span>

<span class="sd">    &gt;&gt;&gt; hyp.sleep_statistics()</span>
<span class="sd">    {&#39;TIB&#39;: 500.0,</span>
<span class="sd">     &#39;SPT&#39;: 497.5,</span>
<span class="sd">     &#39;WASO&#39;: 79.5,</span>
<span class="sd">     &#39;TST&#39;: 418.0,</span>
<span class="sd">     &#39;SE&#39;: 83.6,</span>
<span class="sd">     &#39;SME&#39;: 84.0201,</span>
<span class="sd">     &#39;SFI&#39;: 0.7177,</span>
<span class="sd">     &#39;SOL&#39;: 2.5,</span>
<span class="sd">     &#39;SOL_5min&#39;: 2.5,</span>
<span class="sd">     &#39;Lat_REM&#39;: 67.0,</span>
<span class="sd">     &#39;WAKE&#39;: 82.0,</span>
<span class="sd">     &#39;N1&#39;: 69.0,</span>
<span class="sd">     &#39;N2&#39;: 247.0,</span>
<span class="sd">     &#39;N3&#39;: 64.5,</span>
<span class="sd">     &#39;REM&#39;: 37.5,</span>
<span class="sd">     &#39;%N1&#39;: 16.5072,</span>
<span class="sd">     &#39;%N2&#39;: 59.0909,</span>
<span class="sd">     &#39;%N3&#39;: 15.4306,</span>
<span class="sd">     &#39;%REM&#39;: 8.9713}</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Hypnogram.__init__"><a class="viewcode-back" href="../../generated/yasa.Hypnogram.html#yasa.Hypnogram.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">n_stages</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="s2">&quot;30s&quot;</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scorer</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">values</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)</span>
        <span class="p">),</span> <span class="s2">&quot;`values` must be a list, numpy.array or pandas.Series&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n_stages</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="s2">&quot;`n_stages` must be an integer between 2 and 5.&quot;</span>
        <span class="k">assert</span> <span class="n">n_stages</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="s2">&quot;`n_stages` must be an integer between 2 and 5.&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="s2">&quot;`freq` must be a pandas frequency string.&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">start</span><span class="p">,</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="nb">str</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">)</span>
        <span class="p">),</span> <span class="s2">&quot;`start` must be either None, a string or a pandas.Timestamp.&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">scorer</span><span class="p">,</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="p">),</span> <span class="s2">&quot;`scorer` must be either None, or a string or an integer.&quot;</span>
        <span class="k">if</span> <span class="n">n_stages</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">accepted</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;W&quot;</span><span class="p">,</span> <span class="s2">&quot;WAKE&quot;</span><span class="p">,</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;SLEEP&quot;</span><span class="p">,</span> <span class="s2">&quot;ART&quot;</span><span class="p">,</span> <span class="s2">&quot;UNS&quot;</span><span class="p">]</span>
            <span class="n">mapping</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;WAKE&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;SLEEP&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;ART&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;UNS&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">2</span><span class="p">}</span>
        <span class="k">elif</span> <span class="n">n_stages</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">accepted</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;WAKE&quot;</span><span class="p">,</span> <span class="s2">&quot;W&quot;</span><span class="p">,</span> <span class="s2">&quot;NREM&quot;</span><span class="p">,</span> <span class="s2">&quot;REM&quot;</span><span class="p">,</span> <span class="s2">&quot;R&quot;</span><span class="p">,</span> <span class="s2">&quot;ART&quot;</span><span class="p">,</span> <span class="s2">&quot;UNS&quot;</span><span class="p">]</span>
            <span class="n">mapping</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;WAKE&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;NREM&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;REM&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s2">&quot;ART&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;UNS&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">2</span><span class="p">}</span>
        <span class="k">elif</span> <span class="n">n_stages</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">accepted</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;WAKE&quot;</span><span class="p">,</span> <span class="s2">&quot;W&quot;</span><span class="p">,</span> <span class="s2">&quot;LIGHT&quot;</span><span class="p">,</span> <span class="s2">&quot;DEEP&quot;</span><span class="p">,</span> <span class="s2">&quot;REM&quot;</span><span class="p">,</span> <span class="s2">&quot;R&quot;</span><span class="p">,</span> <span class="s2">&quot;ART&quot;</span><span class="p">,</span> <span class="s2">&quot;UNS&quot;</span><span class="p">]</span>
            <span class="n">mapping</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;WAKE&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;LIGHT&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;DEEP&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;REM&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s2">&quot;ART&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;UNS&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">2</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">accepted</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;WAKE&quot;</span><span class="p">,</span> <span class="s2">&quot;W&quot;</span><span class="p">,</span> <span class="s2">&quot;N1&quot;</span><span class="p">,</span> <span class="s2">&quot;N2&quot;</span><span class="p">,</span> <span class="s2">&quot;N3&quot;</span><span class="p">,</span> <span class="s2">&quot;REM&quot;</span><span class="p">,</span> <span class="s2">&quot;R&quot;</span><span class="p">,</span> <span class="s2">&quot;ART&quot;</span><span class="p">,</span> <span class="s2">&quot;UNS&quot;</span><span class="p">]</span>
            <span class="n">mapping</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;WAKE&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;N1&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;N2&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;N3&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;REM&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s2">&quot;ART&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;UNS&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">2</span><span class="p">}</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">([</span><span class="n">val</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="ow">in</span> <span class="n">accepted</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]),</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">values</span><span class="p">)</span><span class="si">}</span><span class="s2"> do not match the accepted values for a </span><span class="si">{</span><span class="n">n_stages</span><span class="si">}</span><span class="s2"> stages &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;hypnogram: </span><span class="si">{</span><span class="n">accepted</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">):</span>
            <span class="c1"># Make sure to remove index if the input is a pandas.Series</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">hypno</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">values</span><span class="p">)</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">scorer</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">hypno</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Stage&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">hypno</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">scorer</span>
        <span class="c1"># Combine accepted values</span>
        <span class="n">map_accepted</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;S&quot;</span><span class="p">:</span> <span class="s2">&quot;SLEEP&quot;</span><span class="p">,</span> <span class="s2">&quot;W&quot;</span><span class="p">:</span> <span class="s2">&quot;WAKE&quot;</span><span class="p">,</span> <span class="s2">&quot;R&quot;</span><span class="p">:</span> <span class="s2">&quot;REM&quot;</span><span class="p">}</span>
        <span class="n">hypno</span> <span class="o">=</span> <span class="n">hypno</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">map_accepted</span><span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">accepted</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">map_accepted</span><span class="p">)</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="c1"># Change dtype of series to &quot;categorical&quot; (reduces memory)</span>
        <span class="n">cat_dtype</span> <span class="o">=</span> <span class="n">CategoricalDtype</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">ordered</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">hypno</span> <span class="o">=</span> <span class="n">hypno</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">cat_dtype</span><span class="p">)</span>
        <span class="c1"># Create Index</span>
        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">hypno</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="n">hypno</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">hypno</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Time&quot;</span>
            <span class="n">timedelta</span> <span class="o">=</span> <span class="n">hypno</span><span class="o">.</span><span class="n">index</span> <span class="o">-</span> <span class="n">hypno</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fake_dt</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="s2">&quot;2022-12-03 00:00:00&quot;</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="n">hypno</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">hypno</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Epoch&quot;</span>
            <span class="n">timedelta</span> <span class="o">=</span> <span class="n">fake_dt</span> <span class="o">-</span> <span class="n">fake_dt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Set attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hypno</span> <span class="o">=</span> <span class="n">hypno</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_epochs</span> <span class="o">=</span> <span class="n">hypno</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span> <span class="o">=</span> <span class="n">freq</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sampling_frequency</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_start</span> <span class="o">=</span> <span class="n">start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_timedelta</span> <span class="o">=</span> <span class="n">timedelta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_duration</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_epochs</span> <span class="o">/</span> <span class="p">(</span><span class="mi">60</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sampling_frequency</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_stages</span> <span class="o">=</span> <span class="n">n_stages</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span> <span class="o">=</span> <span class="n">labels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mapping</span> <span class="o">=</span> <span class="n">mapping</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scorer</span> <span class="o">=</span> <span class="n">scorer</span></div>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># TODO v0.8: Keep only the text between &lt; and &gt;</span>
        <span class="n">text_scorer</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;, scored by </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">scorer</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scorer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;&lt;Hypnogram | </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_epochs</span><span class="si">}</span><span class="s2"> epochs x </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">duration</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> minutes), &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_stages</span><span class="si">}</span><span class="s2"> stages</span><span class="si">{</span><span class="n">text_scorer</span><span class="si">}</span><span class="s2">&gt;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot; - Use `.hypno` to get the string values as a pandas.Series</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot; - Use `.as_int()` to get the integer values as a pandas.Series</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot; - Use `.plot_hypnogram()` to plot the hypnogram</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;See the online documentation for more details.&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">text_scorer</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;, scored by </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">scorer</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scorer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;&lt;Hypnogram | </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_epochs</span><span class="si">}</span><span class="s2"> epochs x </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">duration</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> minutes), &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_stages</span><span class="si">}</span><span class="s2"> stages</span><span class="si">{</span><span class="n">text_scorer</span><span class="si">}</span><span class="s2">&gt;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot; - Use `.hypno` to get the string values as a pandas.Series</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot; - Use `.as_int()` to get the integer values as a pandas.Series</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot; - Use `.plot_hypnogram()` to plot the hypnogram</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;See the online documentation for more details.&quot;</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">hypno</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The hypnogram values, stored in a :py:class:`pandas.Series`. To reduce memory usage, the</span>
<span class="sd">        stages are stored as categories (:py:class:`pandas.Categorical`). ``hypno``</span>
<span class="sd">        inherits all the methods of a standard :py:class:`pandas.Series`, e.g. ``.describe()``,</span>
<span class="sd">        ``.unique()``, ``.to_csv()``, and more.</span>

<span class="sd">        .. note:: ``print(Hypnogram)`` is a shortcut to ``print(Hypnogram.hypno)``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hypno</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_epochs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The number of epochs in the hypnogram.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_epochs</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">freq</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The frequency resolution of the hypnogram. Default is &#39;30s&#39;&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sampling_frequency</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The sampling frequency (Hz) of the hypnogram.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sampling_frequency</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The start date/time of the hypnogram. Default is None.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">timedelta</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A :py:class:`pandas.TimedeltaIndex` vector with the accumulated time difference of each</span>
<span class="sd">        epoch compared to the first epoch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_timedelta</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">duration</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Total duration of the hypnogram, expressed in minutes. AKA Time in Bed.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_duration</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_stages</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The number of allowed stages in the hypnogram. This is not the number of unique stages</span>
<span class="sd">        in the current hypnogram. This does not include Artefact and Unscored which are always</span>
<span class="sd">        allowed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_stages</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">labels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The allowed stage labels.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mapping</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A dictionary with the mapping from string to integer values.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mapping</span>

    <span class="nd">@mapping</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">mapping</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">map_dict</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">map_dict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">),</span> <span class="s2">&quot;`mapping` must be a dictionary, e.g. {&#39;WAKE&#39;: 0, ...}&quot;</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">([</span><span class="n">val</span> <span class="ow">in</span> <span class="n">map_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">hypno</span><span class="o">.</span><span class="n">unique</span><span class="p">()]),</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Some values in `hypno` (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">hypno</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span><span class="si">}</span><span class="s2">) are not in `map_dict` &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">map_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;ART&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">map_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">map_dict</span><span class="p">[</span><span class="s2">&quot;ART&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="s2">&quot;UNS&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">map_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">map_dict</span><span class="p">[</span><span class="s2">&quot;UNS&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mapping</span> <span class="o">=</span> <span class="n">map_dict</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mapping_int</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A dictionary with the mapping from integer to string values.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mapping</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">scorer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The scorer name.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scorer</span>

    <span class="c1"># CLASS METHODS BELOW</span>

<div class="viewcode-block" id="Hypnogram.as_annotations"><a class="viewcode-back" href="../../generated/yasa.Hypnogram.html#yasa.Hypnogram.as_annotations">[docs]</a>    <span class="k">def</span> <span class="nf">as_annotations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a pandas DataFrame summarizing epoch-level information.</span>

<span class="sd">        Column order and names are compliant with BIDS</span>
<span class="sd">        `events files</span>
<span class="sd">        &lt;https://bids-specification.readthedocs.io/en/stable/04-modality-specific-files/05-task-events.html&gt;`_</span>
<span class="sd">        and MNE `events/annotations dataframes</span>
<span class="sd">        &lt;https://mne.tools/stable/glossary.html#term-annotations&gt;`_.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        annotations : :py:class:`pandas.DataFrame`</span>
<span class="sd">            A dataframe containing epoch onset, duration, stage, etc.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from yasa import Hypnogram</span>
<span class="sd">        &gt;&gt;&gt; hyp = Hypnogram([&quot;W&quot;, &quot;W&quot;, &quot;LIGHT&quot;, &quot;LIGHT&quot;, &quot;DEEP&quot;, &quot;REM&quot;, &quot;WAKE&quot;], n_stages=4)</span>
<span class="sd">        &gt;&gt;&gt; hyp.as_annotations()</span>
<span class="sd">               onset  duration  value description</span>
<span class="sd">        epoch</span>
<span class="sd">        0        0.0      30.0      0        WAKE</span>
<span class="sd">        1       30.0      30.0      0        WAKE</span>
<span class="sd">        2       60.0      30.0      2       LIGHT</span>
<span class="sd">        3       90.0      30.0      2       LIGHT</span>
<span class="sd">        4      120.0      30.0      3        DEEP</span>
<span class="sd">        5      150.0      30.0      4         REM</span>
<span class="sd">        6      180.0      30.0      0        WAKE</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;onset&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">timedelta</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">(),</span>
            <span class="s2">&quot;duration&quot;</span><span class="p">:</span> <span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_frequency</span><span class="p">,</span>
            <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_int</span><span class="p">()</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span>
            <span class="s2">&quot;description&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">hypno</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span>
            <span class="s2">&quot;epoch&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_epochs</span><span class="p">),</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scorer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;scorer&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scorer</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;epoch&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Hypnogram.as_int"><a class="viewcode-back" href="../../generated/yasa.Hypnogram.html#yasa.Hypnogram.as_int">[docs]</a>    <span class="k">def</span> <span class="nf">as_int</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return hypnogram values as integers.</span>

<span class="sd">        The default mapping from string to integer is:</span>

<span class="sd">        * 2 stages: {&quot;WAKE&quot;: 0, &quot;SLEEP&quot;: 1, &quot;ART&quot;: -1, &quot;UNS&quot;: -2}</span>
<span class="sd">        * 3 stages: {&quot;WAKE&quot;: 0, &quot;NREM&quot;: 2, &quot;REM&quot;: 4, &quot;ART&quot;: -1, &quot;UNS&quot;: -2}</span>
<span class="sd">        * 4 stages: {&quot;WAKE&quot;: 0, &quot;LIGHT&quot;: 2, &quot;DEEP&quot;: 3, &quot;REM&quot;: 4, &quot;ART&quot;: -1, &quot;UNS&quot;: -2}</span>
<span class="sd">        * 5 stages: {&quot;WAKE&quot;: 0, &quot;N1&quot;: 1, &quot;N2&quot;: 2, &quot;N3&quot;: 3, &quot;REM&quot;: 4, &quot;ART&quot;: -1, &quot;UNS&quot;: -2}</span>

<span class="sd">        Users can define a custom mapping:</span>

<span class="sd">        &gt;&gt;&gt; hyp.mapping = {&quot;WAKE&quot;: 0, &quot;NREM&quot;: 1, &quot;REM&quot;: 2}</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Convert a 2-stages hypnogram to a pandas.Series of integers</span>

<span class="sd">        &gt;&gt;&gt; from yasa import Hypnogram</span>
<span class="sd">        &gt;&gt;&gt; hyp = Hypnogram([&quot;W&quot;, &quot;W&quot;, &quot;S&quot;, &quot;S&quot;, &quot;W&quot;, &quot;S&quot;], n_stages=2)</span>
<span class="sd">        &gt;&gt;&gt; hyp.as_int()</span>
<span class="sd">        Epoch</span>
<span class="sd">        0    0</span>
<span class="sd">        1    0</span>
<span class="sd">        2    1</span>
<span class="sd">        3    1</span>
<span class="sd">        4    0</span>
<span class="sd">        5    1</span>
<span class="sd">        Name: Stage, dtype: int16</span>

<span class="sd">        Same with a 4-stages hypnogram</span>

<span class="sd">        &gt;&gt;&gt; from yasa import Hypnogram</span>
<span class="sd">        &gt;&gt;&gt; hyp = Hypnogram([&quot;W&quot;, &quot;W&quot;, &quot;LIGHT&quot;, &quot;LIGHT&quot;, &quot;DEEP&quot;, &quot;REM&quot;, &quot;WAKE&quot;], n_stages=4)</span>
<span class="sd">        &gt;&gt;&gt; hyp.as_int()</span>
<span class="sd">        Epoch</span>
<span class="sd">        0    0</span>
<span class="sd">        1    0</span>
<span class="sd">        2    2</span>
<span class="sd">        3    2</span>
<span class="sd">        4    3</span>
<span class="sd">        5    4</span>
<span class="sd">        6    0</span>
<span class="sd">        Name: Stage, dtype: int16</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Return as int16 (-32768 to 32767) to reduce memory usage</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">hypno</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">rename_categories</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mapping</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span></div>

<div class="viewcode-block" id="Hypnogram.consolidate_stages"><a class="viewcode-back" href="../../generated/yasa.Hypnogram.html#yasa.Hypnogram.consolidate_stages">[docs]</a>    <span class="k">def</span> <span class="nf">consolidate_stages</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_n_stages</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reduce the number of stages in a hypnogram to match actigraphy or wearables.</span>

<span class="sd">        For example, a standard 5-stage hypnogram (W, N1, N2, N3, REM) could be consolidated</span>
<span class="sd">        to a hypnogram more common with actigraphy (e.g. 2-stages: [Wake, Sleep] or</span>
<span class="sd">        4-stages: [W, Light, Deep, REM]).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        self : :py:class:`yasa.Hypnogram`</span>
<span class="sd">            Hypnogram, assumed to be already cropped to time in bed (TIB, also referred to as</span>
<span class="sd">            Total Recording Time, i.e. &quot;lights out&quot; to &quot;lights on&quot;).</span>
<span class="sd">        new_n_stages : int</span>
<span class="sd">            Desired number of sleep stages. Must be lower than the current number of stages.</span>

<span class="sd">            - 5 stages - Wake, N1, N2, N3, REM</span>
<span class="sd">            - 4 stages - Wake, Light, Deep, REM</span>
<span class="sd">            - 3 stages - Wake, NREM, REM</span>
<span class="sd">            - 2 stages - Wake, Sleep</span>

<span class="sd">            .. note:: Unscored and Artefact are always allowed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hyp : :py:class:`yasa.Hypnogram`</span>
<span class="sd">            The consolidated Hypnogram object. This function returns a copy, i.e. the original</span>
<span class="sd">            hypnogram is not modified in place.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from yasa import Hypnogram</span>
<span class="sd">        &gt;&gt;&gt; hyp = Hypnogram([&quot;W&quot;, &quot;W&quot;, &quot;N1&quot;, &quot;N2&quot;, &quot;N2&quot;, &quot;N2&quot;, &quot;N2&quot;, &quot;W&quot;], n_stages=5)</span>
<span class="sd">        &gt;&gt;&gt; hyp_2s = hyp.consolidate_stages(2)</span>
<span class="sd">        &gt;&gt;&gt; print(hyp_2s)</span>
<span class="sd">        Epoch</span>
<span class="sd">        0     WAKE</span>
<span class="sd">        1     WAKE</span>
<span class="sd">        2    SLEEP</span>
<span class="sd">        3    SLEEP</span>
<span class="sd">        4    SLEEP</span>
<span class="sd">        5    SLEEP</span>
<span class="sd">        6    SLEEP</span>
<span class="sd">        7     WAKE</span>
<span class="sd">        Name: Stage, dtype: category</span>
<span class="sd">        Categories (4, object): [&#39;WAKE&#39;, &#39;SLEEP&#39;, &#39;ART&#39;, &#39;UNS&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_stages</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="s2">&quot;`self.n_stages` must be 3, 4, or 5&quot;</span>
        <span class="k">assert</span> <span class="n">new_n_stages</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="s2">&quot;`new_n_stages` must be 2, 3, or 4&quot;</span>
        <span class="k">assert</span> <span class="n">new_n_stages</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_stages</span><span class="p">,</span> <span class="s2">&quot;`new_n_stages` must be lower than `self.n_stages`&quot;</span>

        <span class="c1"># Change sleep codes where applicable.</span>
        <span class="k">if</span> <span class="n">new_n_stages</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># Consolidate all Sleep</span>
            <span class="n">mapping</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;N1&quot;</span><span class="p">:</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span>
                <span class="s2">&quot;N2&quot;</span><span class="p">:</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span>
                <span class="s2">&quot;N3&quot;</span><span class="p">:</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span>
                <span class="s2">&quot;REM&quot;</span><span class="p">:</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span>
                <span class="s2">&quot;LIGHT&quot;</span><span class="p">:</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span>
                <span class="s2">&quot;DEEP&quot;</span><span class="p">:</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span>
                <span class="s2">&quot;NREM&quot;</span><span class="p">:</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="k">elif</span> <span class="n">new_n_stages</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="c1"># Consolidate N1/N2/N3 or Light/Deep into NREM</span>
            <span class="n">mapping</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;N1&quot;</span><span class="p">:</span> <span class="s2">&quot;NREM&quot;</span><span class="p">,</span> <span class="s2">&quot;N2&quot;</span><span class="p">:</span> <span class="s2">&quot;NREM&quot;</span><span class="p">,</span> <span class="s2">&quot;N3&quot;</span><span class="p">:</span> <span class="s2">&quot;NREM&quot;</span><span class="p">,</span> <span class="s2">&quot;LIGHT&quot;</span><span class="p">:</span> <span class="s2">&quot;NREM&quot;</span><span class="p">,</span> <span class="s2">&quot;DEEP&quot;</span><span class="p">:</span> <span class="s2">&quot;NREM&quot;</span><span class="p">}</span>
        <span class="k">elif</span> <span class="n">new_n_stages</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="c1"># Consolidate N1/N2 into Light</span>
            <span class="n">mapping</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;N1&quot;</span><span class="p">:</span> <span class="s2">&quot;LIGHT&quot;</span><span class="p">,</span> <span class="s2">&quot;N2&quot;</span><span class="p">:</span> <span class="s2">&quot;LIGHT&quot;</span><span class="p">,</span> <span class="s2">&quot;N3&quot;</span><span class="p">:</span> <span class="s2">&quot;DEEP&quot;</span><span class="p">}</span>
        <span class="n">new_hyp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hypno</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">mapping</span><span class="p">)</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">Hypnogram</span><span class="p">(</span>
            <span class="n">values</span><span class="o">=</span><span class="n">new_hyp</span><span class="p">,</span>
            <span class="n">n_stages</span><span class="o">=</span><span class="n">new_n_stages</span><span class="p">,</span>
            <span class="n">freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">,</span>
            <span class="n">start</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">,</span>
            <span class="n">scorer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scorer</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Hypnogram.copy"><a class="viewcode-back" href="../../generated/yasa.Hypnogram.html#yasa.Hypnogram.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new copy of the current Hypnogram.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span>
            <span class="n">values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hypno</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span>
            <span class="n">n_stages</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_stages</span><span class="p">,</span>
            <span class="n">freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">,</span>
            <span class="n">start</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">,</span>
            <span class="n">scorer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scorer</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Hypnogram.evaluate"><a class="viewcode-back" href="../../generated/yasa.Hypnogram.html#yasa.Hypnogram.evaluate">[docs]</a>    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obs_hyp</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate agreement between two hypnograms of the same sleep session.</span>

<span class="sd">        For example, the reference hypnogram (i.e., ``self``) might be a manually-scored hypnogram</span>
<span class="sd">        and the reference hypnogram (i.e., ``ref_hyp``) might be a hypnogram from actigraphy, a</span>
<span class="sd">        wearable device, or an automated scorer (e.g., :py:meth:`yasa.SleepStaging.predict`).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        self : :py:class:`yasa.Hypnogram`</span>
<span class="sd">            Reference or ground-truth hypnogram.</span>
<span class="sd">        obs_hyp : :py:class:`yasa.Hypnogram`</span>
<span class="sd">            The observed or to-be-evaluated hypnogram.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ebe : :py:class:`yasa.EpochByEpochAgreement`</span>
<span class="sd">            See :py:class:`~yasa.EpochByEpochAgreement` documentation for more detail.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from yasa import simulate_hypnogram</span>
<span class="sd">        &gt;&gt;&gt; hyp_a = simulate_hypnogram(tib=90, scorer=&quot;AASM&quot;, seed=8)</span>
<span class="sd">        &gt;&gt;&gt; hyp_b = hyp_a.simulate_similar(scorer=&quot;YASA&quot;, seed=9)</span>
<span class="sd">        &gt;&gt;&gt; ebe = hyp_a.evaluate(hyp_b)</span>
<span class="sd">        &gt;&gt;&gt; ebe.get_agreement().round(3)</span>
<span class="sd">        accuracy        0.550</span>
<span class="sd">        balanced_acc    0.355</span>
<span class="sd">        kappa           0.227</span>
<span class="sd">        mcc             0.231</span>
<span class="sd">        precision       0.515</span>
<span class="sd">        recall          0.550</span>
<span class="sd">        fbeta           0.524</span>
<span class="sd">        Name: agreement, dtype: float64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">EpochByEpochAgreement</span><span class="p">([</span><span class="bp">self</span><span class="p">],</span> <span class="p">[</span><span class="n">obs_hyp</span><span class="p">])</span></div>

<div class="viewcode-block" id="Hypnogram.find_periods"><a class="viewcode-back" href="../../generated/yasa.Hypnogram.html#yasa.Hypnogram.find_periods">[docs]</a>    <span class="k">def</span> <span class="nf">find_periods</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="s2">&quot;5min&quot;</span><span class="p">,</span> <span class="n">equal_length</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find sequences of consecutive values exceeding a certain duration in hypnogram.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        self : :py:class:`yasa.Hypnogram`</span>
<span class="sd">            Hypnogram, assumed to be already cropped to time in bed (TIB, also referred to as</span>
<span class="sd">            Total Recording Time, i.e. &quot;lights out&quot; to &quot;lights on&quot;).</span>
<span class="sd">        threshold : str</span>
<span class="sd">            This function will only keep periods that exceed a certain duration (default &#39;5min&#39;),</span>
<span class="sd">            e.g. &#39;5min&#39;, &#39;15min&#39;, &#39;30sec&#39;, &#39;1hour&#39;. To disable thresholding, use &#39;0sec&#39;.</span>
<span class="sd">        equal_length : bool</span>
<span class="sd">            If True, the periods will all have the exact duration defined</span>
<span class="sd">            in threshold. That is, periods that are longer than the duration threshold will be</span>
<span class="sd">            divided into sub-periods of exactly the length of ``threshold``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        periods : :py:class:`pandas.DataFrame`</span>
<span class="sd">            Output dataframe</span>

<span class="sd">            * ``values`` : The value in hypno of the current period</span>
<span class="sd">            * ``start`` : The index of the start of the period in hypno</span>
<span class="sd">            * ``length`` : The duration of the period, in number of epochs</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Let&#39;s assume that we have an hypnogram where sleep = 1 and wake = 0, with one value</span>
<span class="sd">        per minute.</span>

<span class="sd">        &gt;&gt;&gt; from yasa import Hypnogram</span>
<span class="sd">        &gt;&gt;&gt; val = 11 * [&quot;W&quot;] + 3 * [&quot;S&quot;] + 2 * [&quot;W&quot;] + 9 * [&quot;S&quot;] + [&quot;W&quot;, &quot;W&quot;]</span>
<span class="sd">        &gt;&gt;&gt; hyp = Hypnogram(val, n_stages=2, freq=&quot;1min&quot;)</span>
<span class="sd">        &gt;&gt;&gt; hyp.find_periods(threshold=&quot;0min&quot;)</span>
<span class="sd">          values  start  length</span>
<span class="sd">        0   WAKE      0      11</span>
<span class="sd">        1  SLEEP     11       3</span>
<span class="sd">        2   WAKE     14       2</span>
<span class="sd">        3  SLEEP     16       9</span>
<span class="sd">        4   WAKE     25       2</span>

<span class="sd">        This gives us the start and duration of each sequence of consecutive values in the</span>
<span class="sd">        hypnogram. For example, the first row tells us that there is a sequence of 11 consecutive</span>
<span class="sd">        WAKE starting at the first index of hypno.</span>

<span class="sd">        Now, we may want to keep only periods that are longer than a specific threshold,</span>
<span class="sd">        for example 5 minutes:</span>

<span class="sd">        &gt;&gt;&gt; hyp.find_periods(threshold=&quot;5min&quot;)</span>
<span class="sd">          values  start  length</span>
<span class="sd">        0   WAKE      0      11</span>
<span class="sd">        1  SLEEP     16       9</span>

<span class="sd">        Only the two sequences that are longer than 5 minutes (11 minutes and 9 minutes</span>
<span class="sd">        respectively) are kept. Feel free to play around with different values of threshold!</span>

<span class="sd">        This function is not limited to binary arrays, e.g. a 5-stages hypnogram at 30-sec</span>
<span class="sd">        resolution:</span>

<span class="sd">        &gt;&gt;&gt; from yasa import simulate_hypnogram</span>
<span class="sd">        &gt;&gt;&gt; hyp = simulate_hypnogram(tib=30, seed=42)</span>
<span class="sd">        &gt;&gt;&gt; hyp.find_periods(threshold=&quot;2min&quot;)</span>
<span class="sd">          values  start  length</span>
<span class="sd">        0   WAKE      0       5</span>
<span class="sd">        1     N1      5       6</span>
<span class="sd">        2     N2     11      49</span>

<span class="sd">        Lastly, using ``equal_length=True`` will further divide the periods into segments of the</span>
<span class="sd">        same duration, i.e. the duration defined in ``threshold``:</span>

<span class="sd">        &gt;&gt;&gt; hyp.find_periods(threshold=&quot;5min&quot;, equal_length=True)</span>
<span class="sd">          values  start  length</span>
<span class="sd">        0     N2     11      10</span>
<span class="sd">        1     N2     21      10</span>
<span class="sd">        2     N2     31      10</span>
<span class="sd">        3     N2     41      10</span>

<span class="sd">        Here, the 24.5 minutes of consecutive N2 sleep (= 49 epochs) are divided into 4 periods of</span>
<span class="sd">        exactly 5 minute each. The remaining 4.5 minutes at the end of the hypnogram are removed</span>
<span class="sd">        because it is less than 5 minutes. In other words, the remainder of the division of a given</span>
<span class="sd">        segment by the desired duration is discarded.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">hypno_find_periods</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hypno</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_frequency</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span> <span class="n">equal_length</span><span class="o">=</span><span class="n">equal_length</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Hypnogram.plot_hypnogram"><a class="viewcode-back" href="../../generated/yasa.Hypnogram.html#yasa.Hypnogram.plot_hypnogram">[docs]</a>    <span class="k">def</span> <span class="nf">plot_hypnogram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot the hypnogram.</span>

<span class="sd">        .. seealso:: :py:func:`yasa.plot_hypnogram`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        **kwargs : dict</span>
<span class="sd">            Optional keyword arguments passed to :py:func:`yasa.plot_hypnogram`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ax : :py:class:`matplotlib.axes.Axes`</span>
<span class="sd">            Matplotlib Axes</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        .. plot::</span>

<span class="sd">            &gt;&gt;&gt; from yasa import simulate_hypnogram</span>
<span class="sd">            &gt;&gt;&gt; ax = simulate_hypnogram(tib=480, seed=88).plot_hypnogram(highlight=&quot;REM&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">plot_hypnogram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Hypnogram.simulate_similar"><a class="viewcode-back" href="../../generated/yasa.Hypnogram.html#yasa.Hypnogram.simulate_similar">[docs]</a>    <span class="k">def</span> <span class="nf">simulate_similar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Simulate a new hypnogram based on properties of the current hypnogram.</span>

<span class="sd">        .. seealso:: :py:func:`yasa.simulate_hypnogram`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        self : :py:class:`yasa.Hypnogram`</span>
<span class="sd">            Hypnogram, assumed to be already cropped to time in bed (TIB).</span>
<span class="sd">        **kwargs : dict</span>
<span class="sd">            Optional keyword arguments passed to :py:func:`yasa.simulate_hypnogram`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hyp : :py:class:`yasa.Hypnogram`</span>
<span class="sd">            A simulated hypnogram.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">        &gt;&gt;&gt; from yasa import Hypnogram</span>
<span class="sd">        &gt;&gt;&gt; hyp = Hypnogram(</span>
<span class="sd">        ...     [&quot;W&quot;, &quot;S&quot;, &quot;W&quot;], n_stages=2, freq=&quot;2min&quot;, scorer=&quot;Human&quot;).upsample(&quot;30s&quot;)</span>
<span class="sd">        &gt;&gt;&gt; shyp = hyp.simulate_similar(scorer=&quot;Simulated&quot;, seed=6)</span>
<span class="sd">        &gt;&gt;&gt; df = pd.concat([hyp.hypno, shyp.hypno], axis=1)</span>
<span class="sd">        &gt;&gt;&gt; print(df)</span>
<span class="sd">               Human Simulated</span>
<span class="sd">        Epoch</span>
<span class="sd">        0       WAKE      WAKE</span>
<span class="sd">        1       WAKE      WAKE</span>
<span class="sd">        2       WAKE      WAKE</span>
<span class="sd">        3       WAKE      WAKE</span>
<span class="sd">        4      SLEEP     SLEEP</span>
<span class="sd">        5      SLEEP     SLEEP</span>
<span class="sd">        6      SLEEP     SLEEP</span>
<span class="sd">        7      SLEEP     SLEEP</span>
<span class="sd">        8       WAKE     SLEEP</span>
<span class="sd">        9       WAKE     SLEEP</span>
<span class="sd">        10      WAKE     SLEEP</span>
<span class="sd">        11      WAKE      WAKE</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="s2">&quot;n_stages&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="s2">&quot;freq&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">,</span> <span class="p">(</span>
            <span class="s2">&quot;`n_stages` and `freq` cannot be included as additional `**kwargs` &quot;</span>
            <span class="s2">&quot;because they must match properties of the current Hypnogram.&quot;</span>
        <span class="p">)</span>
        <span class="n">simulate_hypnogram_kwargs</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;tib&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">duration</span><span class="p">,</span>
            <span class="s2">&quot;n_stages&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_stages</span><span class="p">,</span>
            <span class="s2">&quot;freq&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">,</span>
            <span class="s2">&quot;trans_probas&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">transition_matrix</span><span class="p">()[</span><span class="mi">1</span><span class="p">],</span>
            <span class="s2">&quot;start&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">,</span>
            <span class="s2">&quot;scorer&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">scorer</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="n">simulate_hypnogram_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">simulate_hypnogram</span><span class="p">(</span><span class="o">**</span><span class="n">simulate_hypnogram_kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Hypnogram.sleep_statistics"><a class="viewcode-back" href="../../generated/yasa.Hypnogram.html#yasa.Hypnogram.sleep_statistics">[docs]</a>    <span class="k">def</span> <span class="nf">sleep_statistics</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute standard sleep statistics from an hypnogram.</span>

<span class="sd">        This function supports a 2, 3, 4 or 5-stages hypnogram.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        self : :py:class:`yasa.Hypnogram`</span>
<span class="sd">            Hypnogram, assumed to be already cropped to time in bed (TIB, also referred to as</span>
<span class="sd">            Total Recording Time, i.e. &quot;lights out&quot; to &quot;lights on&quot;).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        stats : dict</span>
<span class="sd">            Summary sleep statistics.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        All values except SE, SME, SFI and the percentage of each stage are expressed in minutes.</span>
<span class="sd">        YASA follows the AASM guidelines to calculate these parameters:</span>

<span class="sd">        * Time in Bed (TIB): total duration of the hypnogram.</span>
<span class="sd">        * Sleep Period Time (SPT): duration from first to last period of sleep.</span>
<span class="sd">        * Wake After Sleep Onset (WASO): duration of wake periods within SPT.</span>
<span class="sd">        * Total Sleep Time (TST): total sleep duration in SPT.</span>
<span class="sd">        * Sleep Onset Latency (SOL): Latency to first epoch of any sleep.</span>
<span class="sd">        * SOL 5min: Latency to 5 minutes of persistent sleep (any stage).</span>
<span class="sd">        * REM latency: latency to first REM sleep.</span>
<span class="sd">        * Sleep Efficiency (SE): TST / TIB * 100 (%).</span>
<span class="sd">        * Sleep Maintenance Efficiency (SME): TST / SPT * 100 (%).</span>
<span class="sd">        * Sleep Fragmentation Index: number of transitions from sleep to wake / hours of TST</span>
<span class="sd">        * Sleep stages amount and proportion of TST</span>

<span class="sd">        .. warning::</span>
<span class="sd">            Artefact and Unscored epochs are excluded from the calculation of the</span>
<span class="sd">            total sleep time (TST). TST is calculated as the sum of all REM and NREM sleep in SPT.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            The definition of REM latency in the AASM scoring manual differs from the REM latency</span>
<span class="sd">            reported here. The former uses the time from first epoch of sleep, while YASA uses the</span>
<span class="sd">            time from the beginning of the recording. The AASM definition of the REM latency can be</span>
<span class="sd">            found with `SOL - Lat_REM`.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        * Iber (2007). The AASM manual for the scoring of sleep and associated events: rules,</span>
<span class="sd">          terminology and technical specifications. American Academy of Sleep Medicine.</span>

<span class="sd">        * Silber et al. (2007). `The visual scoring of sleep in adults</span>
<span class="sd">          &lt;https://www.ncbi.nlm.nih.gov/pubmed/17557422&gt;`_. Journal of Clinical</span>
<span class="sd">          Sleep Medicine, 3(2), 121-131.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Sleep statistics for a 2-stage hypnogram with a resolution of 15-seconds</span>

<span class="sd">        &gt;&gt;&gt; from yasa import Hypnogram</span>
<span class="sd">        &gt;&gt;&gt; # Generate a fake hypnogram, where &quot;S&quot; = Sleep, &quot;W&quot; = Wake</span>
<span class="sd">        &gt;&gt;&gt; values = 10 * [&quot;W&quot;] + 40 * [&quot;S&quot;] + 5 * [&quot;W&quot;] + 40 * [&quot;S&quot;] + 9 * [&quot;W&quot;]</span>
<span class="sd">        &gt;&gt;&gt; hyp = Hypnogram(values, freq=&quot;15s&quot;, n_stages=2)</span>
<span class="sd">        &gt;&gt;&gt; hyp.sleep_statistics()</span>
<span class="sd">        {&#39;TIB&#39;: 26.0,</span>
<span class="sd">        &#39;SPT&#39;: 21.25,</span>
<span class="sd">        &#39;WASO&#39;: 1.25,</span>
<span class="sd">        &#39;TST&#39;: 20.0,</span>
<span class="sd">        &#39;SE&#39;: 76.9231,</span>
<span class="sd">        &#39;SME&#39;: 94.1176,</span>
<span class="sd">        &#39;SFI&#39;: 1.5,</span>
<span class="sd">        &#39;SOL&#39;: 2.5,</span>
<span class="sd">        &#39;SOL_5min&#39;: 2.5,</span>
<span class="sd">        &#39;WAKE&#39;: 6.0}</span>

<span class="sd">        Sleep statistics for a 5-stages hypnogram</span>

<span class="sd">        &gt;&gt;&gt; from yasa import simulate_hypnogram</span>
<span class="sd">        &gt;&gt;&gt; # Generate a 8 hr (= 480 minutes) 5-stages hypnogram with a 30-seconds resolution</span>
<span class="sd">        &gt;&gt;&gt; hyp = simulate_hypnogram(tib=480, seed=42)</span>
<span class="sd">        &gt;&gt;&gt; hyp.sleep_statistics()</span>
<span class="sd">        {&#39;TIB&#39;: 480.0,</span>
<span class="sd">        &#39;SPT&#39;: 477.5,</span>
<span class="sd">        &#39;WASO&#39;: 79.5,</span>
<span class="sd">        &#39;TST&#39;: 398.0,</span>
<span class="sd">        &#39;SE&#39;: 82.9167,</span>
<span class="sd">        &#39;SME&#39;: 83.3508,</span>
<span class="sd">        &#39;SFI&#39;: 0.7538,</span>
<span class="sd">        &#39;SOL&#39;: 2.5,</span>
<span class="sd">        &#39;SOL_5min&#39;: 2.5,</span>
<span class="sd">        &#39;Lat_REM&#39;: 67.0,</span>
<span class="sd">        &#39;WAKE&#39;: 82.0,</span>
<span class="sd">        &#39;N1&#39;: 67.0,</span>
<span class="sd">        &#39;N2&#39;: 240.5,</span>
<span class="sd">        &#39;N3&#39;: 53.0,</span>
<span class="sd">        &#39;REM&#39;: 37.5,</span>
<span class="sd">        &#39;%N1&#39;: 16.8342,</span>
<span class="sd">        &#39;%N2&#39;: 60.4271,</span>
<span class="sd">        &#39;%N3&#39;: 13.3166,</span>
<span class="sd">        &#39;%REM&#39;: 9.4221}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hypno</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hypno</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_epochs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Hypnogram is empty!&quot;</span>
        <span class="n">all_sleep</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;SLEEP&quot;</span><span class="p">,</span> <span class="s2">&quot;N1&quot;</span><span class="p">,</span> <span class="s2">&quot;N2&quot;</span><span class="p">,</span> <span class="s2">&quot;N3&quot;</span><span class="p">,</span> <span class="s2">&quot;NREM&quot;</span><span class="p">,</span> <span class="s2">&quot;REM&quot;</span><span class="p">,</span> <span class="s2">&quot;LIGHT&quot;</span><span class="p">,</span> <span class="s2">&quot;DEEP&quot;</span><span class="p">]</span>
        <span class="n">all_non_sleep</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;WAKE&quot;</span><span class="p">,</span> <span class="s2">&quot;ART&quot;</span><span class="p">,</span> <span class="s2">&quot;UNS&quot;</span><span class="p">]</span>
        <span class="n">stats</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># TIB, first and last sleep</span>
        <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;TIB&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_epochs</span>
        <span class="n">idx_sleep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">hypno</span><span class="p">,</span> <span class="n">all_non_sleep</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx_sleep</span><span class="p">):</span>
            <span class="n">first_sleep</span><span class="p">,</span> <span class="n">last_sleep</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_epochs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">first_sleep</span> <span class="o">=</span> <span class="n">idx_sleep</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">last_sleep</span> <span class="o">=</span> <span class="n">idx_sleep</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Crop to SPT</span>
        <span class="n">hypno_s</span> <span class="o">=</span> <span class="n">hypno</span><span class="p">[</span><span class="n">first_sleep</span> <span class="p">:</span> <span class="p">(</span><span class="n">last_sleep</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;SPT&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hypno_s</span><span class="o">.</span><span class="n">size</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx_sleep</span><span class="p">)</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;WASO&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hypno_s</span><span class="p">[</span><span class="n">hypno_s</span> <span class="o">==</span> <span class="s2">&quot;WAKE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx_sleep</span><span class="p">)</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="c1"># Before YASA v0.5.0, TST was calculated as SPT - WASO, meaning that Art</span>
        <span class="c1"># and Unscored epochs were included. TST is now restrained to sleep stages.</span>
        <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;TST&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hypno_s</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">hypno_s</span><span class="p">,</span> <span class="n">all_sleep</span><span class="p">)]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Sleep efficiency and fragmentation</span>
        <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;SE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;TST&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;TIB&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;SPT&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;SME&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;SFI&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Sleep maintenance efficiency</span>
            <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;SME&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;TST&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;SPT&quot;</span><span class="p">]</span>
            <span class="c1"># SFI is the ratio of the number of transitions from sleep into Wake to TST (hours)</span>
            <span class="c1"># The original definition included transitions into Wake or N1.</span>
            <span class="n">counts</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transition_matrix</span><span class="p">()</span>
            <span class="n">n_trans_to_wake</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                <span class="n">counts</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">counts</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">all_sleep</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">counts</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;WAKE&quot;</span><span class="p">])</span>
                <span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
            <span class="p">)</span>
            <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;SFI&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_trans_to_wake</span> <span class="o">/</span> <span class="p">(</span><span class="n">stats</span><span class="p">[</span><span class="s2">&quot;TST&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="mi">3600</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_frequency</span><span class="p">))</span>

        <span class="c1"># Sleep stage latencies -- only relevant if hypno is cropped to TIB</span>
        <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;SOL&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">first_sleep</span> <span class="k">if</span> <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;TST&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">sleep_periods</span> <span class="o">=</span> <span class="n">hypno_find_periods</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">hypno</span><span class="p">,</span> <span class="n">all_sleep</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_frequency</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="s2">&quot;5min&quot;</span>
        <span class="p">)</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s2">&quot;values == True&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sleep_periods</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;SOL_5min&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sleep_periods</span><span class="p">[</span><span class="s2">&quot;start&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;SOL_5min&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="k">if</span> <span class="s2">&quot;REM&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">:</span>
            <span class="c1"># Question: should we add latencies for other stage too?</span>
            <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;Lat_REM&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">hypno</span> <span class="o">==</span> <span class="s2">&quot;REM&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="k">if</span> <span class="s2">&quot;REM&quot;</span> <span class="ow">in</span> <span class="n">hypno</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="c1"># Duration of each stage</span>
        <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">st</span> <span class="o">==</span> <span class="s2">&quot;SLEEP&quot;</span><span class="p">:</span>
                <span class="c1"># SLEEP == TST</span>
                <span class="k">continue</span>
            <span class="n">stats</span><span class="p">[</span><span class="n">st</span><span class="p">]</span> <span class="o">=</span> <span class="n">hypno</span><span class="p">[</span><span class="n">hypno</span> <span class="o">==</span> <span class="n">st</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>

        <span class="c1"># Remove ART and UNS if they are empty</span>
        <span class="k">if</span> <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;ART&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">stats</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;ART&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;UNS&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">stats</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;UNS&quot;</span><span class="p">)</span>

        <span class="c1"># Convert to minutes</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">stats</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;SE&quot;</span><span class="p">,</span> <span class="s2">&quot;SME&quot;</span><span class="p">]:</span>
                <span class="k">continue</span>
            <span class="n">stats</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span> <span class="o">/</span> <span class="p">(</span><span class="mi">60</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_frequency</span><span class="p">)</span>

        <span class="c1"># Proportion of each sleep stages</span>
        <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="n">all_sleep</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">st</span> <span class="ow">in</span> <span class="n">stats</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;TST&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">stats</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;%</span><span class="si">{</span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">stats</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;%</span><span class="si">{</span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">stats</span><span class="p">[</span><span class="n">st</span><span class="p">]</span> <span class="o">/</span> <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;TST&quot;</span><span class="p">]</span>

        <span class="c1"># Round to 4 decimals</span>
        <span class="n">stats</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">stats</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">return</span> <span class="n">stats</span></div>

<div class="viewcode-block" id="Hypnogram.transition_matrix"><a class="viewcode-back" href="../../generated/yasa.Hypnogram.html#yasa.Hypnogram.transition_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">transition_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a state-transition matrix from an hypnogram.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        self : :py:class:`yasa.Hypnogram`</span>
<span class="sd">            Hypnogram, assumed to be already cropped to time in bed (TIB, also referred to as</span>
<span class="sd">            Total Recording Time, i.e. &quot;lights out&quot; to &quot;lights on&quot;). For best results, the</span>
<span class="sd">            hypnogram should not contain any artefact or unscored epochs.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        counts : :py:class:`pandas.DataFrame`</span>
<span class="sd">            Counts transition matrix (number of transitions from stage A to stage B). The</span>
<span class="sd">            pre-transition states are the rows and the post-transition states are the columns.</span>
<span class="sd">        probs : :py:class:`pandas.DataFrame`</span>
<span class="sd">            Conditional probability transition matrix, i.e. given that current state is A, what is</span>
<span class="sd">            the probability that the next state is B. ``probs`` is a `right stochastic matrix</span>
<span class="sd">            &lt;https://en.wikipedia.org/wiki/Stochastic_matrix&gt;`_, i.e. each row sums to 1.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from yasa import Hypnogram, simulate_hypnogram</span>
<span class="sd">        &gt;&gt;&gt; # Generate a 8 hr (= 480 minutes) 5-stages hypnogram with a 30-seconds resolution</span>
<span class="sd">        &gt;&gt;&gt; hyp = simulate_hypnogram(tib=480, seed=42)</span>
<span class="sd">        &gt;&gt;&gt; counts, probs = hyp.transition_matrix()</span>
<span class="sd">        &gt;&gt;&gt; counts</span>
<span class="sd">        To Stage    WAKE  N1   N2  N3  REM</span>
<span class="sd">        From Stage</span>
<span class="sd">        WAKE         153  11    0   0    0</span>
<span class="sd">        N1             6  99   29   0    0</span>
<span class="sd">        N2             3  16  447  10    5</span>
<span class="sd">        N3             1   3    4  96    1</span>
<span class="sd">        REM            0   5    1   0   69</span>

<span class="sd">        &gt;&gt;&gt; probs.round(3)</span>
<span class="sd">        To Stage     WAKE     N1     N2     N3   REM</span>
<span class="sd">        From Stage</span>
<span class="sd">        WAKE        0.933  0.067  0.000  0.000  0.00</span>
<span class="sd">        N1          0.045  0.739  0.216  0.000  0.00</span>
<span class="sd">        N2          0.006  0.033  0.929  0.021  0.01</span>
<span class="sd">        N3          0.010  0.029  0.038  0.914  0.01</span>
<span class="sd">        REM         0.000  0.067  0.013  0.000  0.92</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">counts</span><span class="p">,</span> <span class="n">probs</span> <span class="o">=</span> <span class="n">transition_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">as_int</span><span class="p">())</span>
        <span class="n">counts</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">counts</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mapping_int</span><span class="p">)</span>
        <span class="n">counts</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">counts</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mapping_int</span><span class="p">)</span>
        <span class="n">probs</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">probs</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mapping_int</span><span class="p">)</span>
        <span class="n">probs</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">probs</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mapping_int</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">counts</span><span class="p">,</span> <span class="n">probs</span></div>

<div class="viewcode-block" id="Hypnogram.upsample"><a class="viewcode-back" href="../../generated/yasa.Hypnogram.html#yasa.Hypnogram.upsample">[docs]</a>    <span class="k">def</span> <span class="nf">upsample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_freq</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Upsample hypnogram to a higher frequency.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        self : :py:class:`yasa.Hypnogram`</span>
<span class="sd">            Hypnogram, assumed to be already cropped to time in bed (TIB, also referred to as</span>
<span class="sd">            Total Recording Time, i.e. &quot;lights out&quot; to &quot;lights on&quot;). For best results, the</span>
<span class="sd">            hypnogram should not contain any artefact or unscored epochs.</span>
<span class="sd">        new_freq : str</span>
<span class="sd">            Frequency is defined with a pandas frequency string, e.g. &quot;10s&quot; or &quot;1min&quot;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hyp : :py:class:`yasa.Hypnogram`</span>
<span class="sd">            The upsampled Hypnogram object. This function returns a copy, i.e. the original</span>
<span class="sd">            hypnogram is not modified in place.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Create a 30-sec hypnogram</span>

<span class="sd">        &gt;&gt;&gt; from yasa import Hypnogram</span>
<span class="sd">        &gt;&gt;&gt; hyp = Hypnogram([&quot;W&quot;, &quot;W&quot;, &quot;S&quot;, &quot;S&quot;, &quot;W&quot;], n_stages=2, start=&quot;2022-12-23 23:00&quot;)</span>
<span class="sd">        &gt;&gt;&gt; hyp.hypno</span>
<span class="sd">        Time</span>
<span class="sd">        2022-12-23 23:00:00     WAKE</span>
<span class="sd">        2022-12-23 23:00:30     WAKE</span>
<span class="sd">        2022-12-23 23:01:00    SLEEP</span>
<span class="sd">        2022-12-23 23:01:30    SLEEP</span>
<span class="sd">        2022-12-23 23:02:00     WAKE</span>
<span class="sd">        Freq: 30S, Name: Stage, dtype: category</span>
<span class="sd">        Categories (4, object): [&#39;WAKE&#39;, &#39;SLEEP&#39;, &#39;ART&#39;, &#39;UNS&#39;]</span>

<span class="sd">        Upsample to a 15-seconds resolution</span>

<span class="sd">        &gt;&gt;&gt; hyp_up = hyp.upsample(&quot;15s&quot;)</span>
<span class="sd">        &gt;&gt;&gt; hyp_up.hypno</span>
<span class="sd">        Time</span>
<span class="sd">        2022-12-23 23:00:00     WAKE</span>
<span class="sd">        2022-12-23 23:00:15     WAKE</span>
<span class="sd">        2022-12-23 23:00:30     WAKE</span>
<span class="sd">        2022-12-23 23:00:45     WAKE</span>
<span class="sd">        2022-12-23 23:01:00    SLEEP</span>
<span class="sd">        2022-12-23 23:01:15    SLEEP</span>
<span class="sd">        2022-12-23 23:01:30    SLEEP</span>
<span class="sd">        2022-12-23 23:01:45    SLEEP</span>
<span class="sd">        2022-12-23 23:02:00     WAKE</span>
<span class="sd">        2022-12-23 23:02:15     WAKE</span>
<span class="sd">        Freq: 15S, Name: Stage, dtype: category</span>
<span class="sd">        Categories (4, object): [&#39;WAKE&#39;, &#39;SLEEP&#39;, &#39;ART&#39;, &#39;UNS&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span><span class="n">new_freq</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">),</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;The upsampling `new_freq` (</span><span class="si">{</span><span class="n">new_freq</span><span class="si">}</span><span class="s2">) must be higher than the current frequency of &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;hypnogram </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hypno</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">):</span>
            <span class="c1"># Upsampling should extend the last epoch, e.g.</span>
            <span class="c1"># - 30-sec: last epoch at 07:20:30</span>
            <span class="c1"># - 10-sec: last epoch should be 07:20:50 and not 07:20:30 otherwise we&#39;re losing 20 sec</span>
            <span class="n">hyp_extend</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hypno</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">hyp_extend</span> <span class="o">=</span> <span class="n">hyp_extend</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span>
                <span class="n">hyp_extend</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">union</span><span class="p">([</span><span class="n">hyp_extend</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">)])</span>
            <span class="p">)</span><span class="o">.</span><span class="n">ffill</span><span class="p">()</span>
            <span class="n">new_hyp</span> <span class="o">=</span> <span class="n">hyp_extend</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">new_freq</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s2">&quot;start&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">ffill</span><span class="p">()</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">hyp_extend</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hypno</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">hyp_extend</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timedelta</span>
            <span class="n">hyp_extend</span> <span class="o">=</span> <span class="n">hyp_extend</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span>
                <span class="n">hyp_extend</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">union</span><span class="p">([</span><span class="n">hyp_extend</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">)])</span>
            <span class="p">)</span><span class="o">.</span><span class="n">ffill</span><span class="p">()</span>
            <span class="n">new_hyp</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">hyp_extend</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">new_freq</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s2">&quot;start&quot;</span><span class="p">)</span>
                <span class="o">.</span><span class="n">ffill</span><span class="p">()</span>
                <span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">new_hyp</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Epoch&quot;</span>
        <span class="k">return</span> <span class="n">Hypnogram</span><span class="p">(</span>
            <span class="n">values</span><span class="o">=</span><span class="n">new_hyp</span><span class="p">,</span>
            <span class="n">n_stages</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_stages</span><span class="p">,</span>
            <span class="n">freq</span><span class="o">=</span><span class="n">new_freq</span><span class="p">,</span>
            <span class="n">start</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">,</span>
            <span class="n">scorer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scorer</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Hypnogram.upsample_to_data"><a class="viewcode-back" href="../../generated/yasa.Hypnogram.html#yasa.Hypnogram.upsample_to_data">[docs]</a>    <span class="k">def</span> <span class="nf">upsample_to_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Upsample an hypnogram to a given sampling frequency and fit the resulting hypnogram to</span>
<span class="sd">        corresponding EEG data, such that the hypnogram and EEG data have the exact same number of</span>
<span class="sd">        samples.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        self : :py:class:`yasa.Hypnogram`</span>
<span class="sd">            Hypnogram, assumed to be already cropped to time in bed (TIB, also referred to as</span>
<span class="sd">            Total Recording Time, i.e. &quot;lights out&quot; to &quot;lights on&quot;). For best results, the</span>
<span class="sd">            hypnogram should not contain any artefact or unscored epochs.</span>
<span class="sd">        data : array_like or :py:class:`mne.io.BaseRaw`</span>
<span class="sd">            1D or 2D EEG data. Can also be a :py:class:`mne.io.BaseRaw`, in which case ``data``</span>
<span class="sd">            and ``sf_data`` will be automatically extracted.</span>
<span class="sd">        sf_data : float</span>
<span class="sd">            The sampling frequency of ``data``, in Hz (e.g. 100 Hz, 256 Hz, ...).</span>
<span class="sd">            Can be omitted if ``data`` is a :py:class:`mne.io.BaseRaw`.</span>
<span class="sd">        verbose : bool or str</span>
<span class="sd">            Verbose level. Default (False) will only print warning and error messages. The logging</span>
<span class="sd">            levels are &#39;debug&#39;, &#39;info&#39;, &#39;warning&#39;, &#39;error&#39;, and &#39;critical&#39;. For most users the</span>
<span class="sd">            choice is between &#39;info&#39; (or ``verbose=True``) and warning (``verbose=False``).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hypno : array_like</span>
<span class="sd">            The hypnogram values, upsampled to ``sf_data`` and cropped/padded to</span>
<span class="sd">            ``max(data.shape)``. For compatibility with most YASA functions, the returned hypnogram</span>
<span class="sd">            is an array with integer values, and not a :py:class:`yasa.Hypnogram` object.</span>

<span class="sd">        Warns</span>
<span class="sd">        -----</span>
<span class="sd">        UserWarning</span>
<span class="sd">            If the upsampled ``hypno`` is shorter / longer than ``max(data.shape)``</span>
<span class="sd">            and therefore needs to be padded/cropped respectively. This output can be disabled by</span>
<span class="sd">            passing ``verbose=&#39;ERROR&#39;``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hypno_up</span> <span class="o">=</span> <span class="n">hypno_upsample_to_data</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">as_int</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_frequency</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">sf_data</span><span class="o">=</span><span class="n">sf</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">hypno_up</span></div></div>


<span class="c1">#############################################################################</span>
<span class="c1"># STR &lt;--&gt; INT CONVERSION</span>
<span class="c1">#############################################################################</span>


<div class="viewcode-block" id="hypno_str_to_int"><a class="viewcode-back" href="../../generated/yasa.hypno_str_to_int.html#yasa.hypno_str_to_int">[docs]</a><span class="k">def</span> <span class="nf">hypno_str_to_int</span><span class="p">(</span>
    <span class="n">hypno</span><span class="p">,</span>
    <span class="n">mapping_dict</span><span class="o">=</span><span class="p">{</span>
        <span class="s2">&quot;w&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s2">&quot;wake&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s2">&quot;n1&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="s2">&quot;s1&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="s2">&quot;n2&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
        <span class="s2">&quot;s2&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
        <span class="s2">&quot;n3&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
        <span class="s2">&quot;s3&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
        <span class="s2">&quot;s4&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
        <span class="s2">&quot;r&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
        <span class="s2">&quot;rem&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
        <span class="s2">&quot;art&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
        <span class="s2">&quot;mt&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
        <span class="s2">&quot;uns&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span>
        <span class="s2">&quot;nd&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span>
    <span class="p">},</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert a string hypnogram array to integer.</span>

<span class="sd">    [&#39;W&#39;, &#39;N2&#39;, &#39;N2&#39;, &#39;N3&#39;, &#39;R&#39;] ==&gt; [0, 2, 2, 3, 4]</span>

<span class="sd">    .. versionadded:: 0.1.5</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    hypno : array_like</span>
<span class="sd">        The sleep staging (hypnogram) 1D array.</span>
<span class="sd">    mapping_dict : dict</span>
<span class="sd">        The mapping dictionnary, in lowercase. Note that this function is essentially a wrapper</span>
<span class="sd">        around :py:meth:`pandas.Series.map`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    hypno : array_like</span>
<span class="sd">        The corresponding integer hypnogram.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># warnings.warn(</span>
    <span class="c1">#     &quot;The `yasa.hypno_str_to_int` function is deprecated and will be removed in v0.8. &quot;</span>
    <span class="c1">#     &quot;Please use the `yasa.Hypnogram.as_int` method instead.&quot;,</span>
    <span class="c1">#     FutureWarning,</span>
    <span class="c1"># )</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hypno</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)),</span> <span class="s2">&quot;Not an array.&quot;</span>
    <span class="n">hypno</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">hypno</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">str</span><span class="p">))</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">hypno</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">isnumeric</span><span class="p">()</span><span class="o">.</span><span class="n">any</span><span class="p">(),</span> <span class="s2">&quot;Hypno contains numeric values.&quot;</span>
    <span class="k">return</span> <span class="n">hypno</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">mapping_dict</span><span class="p">)</span><span class="o">.</span><span class="n">values</span></div>


<div class="viewcode-block" id="hypno_int_to_str"><a class="viewcode-back" href="../../generated/yasa.hypno_int_to_str.html#yasa.hypno_int_to_str">[docs]</a><span class="k">def</span> <span class="nf">hypno_int_to_str</span><span class="p">(</span>
    <span class="n">hypno</span><span class="p">,</span> <span class="n">mapping_dict</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s2">&quot;W&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s2">&quot;N1&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s2">&quot;N2&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="s2">&quot;N3&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span> <span class="s2">&quot;R&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="s2">&quot;Art&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span> <span class="s2">&quot;Uns&quot;</span><span class="p">}</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert an integer hypnogram array to a string array.</span>

<span class="sd">    [0, 2, 2, 3, 4] ==&gt; [&#39;W&#39;, &#39;N2&#39;, &#39;N2&#39;, &#39;N3&#39;, &#39;R&#39;]</span>

<span class="sd">    .. versionadded:: 0.1.5</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    hypno : array_like</span>
<span class="sd">        The sleep staging (hypnogram) 1D array.</span>
<span class="sd">    mapping_dict : dict</span>
<span class="sd">        The mapping dictionnary. Note that this function is essentially a wrapper around</span>
<span class="sd">        :py:meth:`pandas.Series.map`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    hypno : array_like</span>
<span class="sd">        The corresponding integer hypnogram.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># warnings.warn(</span>
    <span class="c1">#     &quot;The `yasa.hypno_int_to_str` function is deprecated and will be removed in v0.8. &quot;</span>
    <span class="c1">#     &quot;Please use the `yasa.Hypnogram` class to create an hypnogram instead.&quot;,</span>
    <span class="c1">#     FutureWarning,</span>
    <span class="c1"># )</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hypno</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)),</span> <span class="s2">&quot;Not an array.&quot;</span>
    <span class="n">hypno</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">hypno</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">hypno</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">mapping_dict</span><span class="p">)</span><span class="o">.</span><span class="n">values</span></div>


<span class="c1">#############################################################################</span>
<span class="c1"># UPSAMPLING</span>
<span class="c1">#############################################################################</span>


<div class="viewcode-block" id="hypno_upsample_to_sf"><a class="viewcode-back" href="../../generated/yasa.hypno_upsample_to_sf.html#yasa.hypno_upsample_to_sf">[docs]</a><span class="k">def</span> <span class="nf">hypno_upsample_to_sf</span><span class="p">(</span><span class="n">hypno</span><span class="p">,</span> <span class="n">sf_hypno</span><span class="p">,</span> <span class="n">sf_data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Upsample the hypnogram to a given sampling frequency.</span>

<span class="sd">    .. versionadded:: 0.1.5</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    hypno : array_like</span>
<span class="sd">        The sleep staging (hypnogram) 1D array.</span>
<span class="sd">    sf_hypno : float</span>
<span class="sd">        The current sampling frequency of the hypnogram, in Hz, e.g.</span>

<span class="sd">        * 1/30 = 1 value per each 30 seconds of EEG data,</span>
<span class="sd">        * 1 = 1 value per second of EEG data</span>
<span class="sd">    sf_data : float</span>
<span class="sd">        The desired sampling frequency of the hypnogram, in Hz (e.g. 100 Hz, 256 Hz, ...)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    hypno : array_like</span>
<span class="sd">        The hypnogram, upsampled to ``sf_data``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># warnings.warn(</span>
    <span class="c1">#     &quot;The `yasa.hypno_upsample_to_sf` function is deprecated and will be removed in v0.8. &quot;</span>
    <span class="c1">#     &quot;Please use the `yasa.Hypnogram.upsample` method instead.&quot;,</span>
    <span class="c1">#     FutureWarning,</span>
    <span class="c1"># )</span>
    <span class="n">repeats</span> <span class="o">=</span> <span class="n">sf_data</span> <span class="o">/</span> <span class="n">sf_hypno</span>
    <span class="k">assert</span> <span class="n">sf_hypno</span> <span class="o">&lt;=</span> <span class="n">sf_data</span><span class="p">,</span> <span class="s2">&quot;sf_hypno must be less than sf_data.&quot;</span>
    <span class="k">assert</span> <span class="n">repeats</span><span class="o">.</span><span class="n">is_integer</span><span class="p">(),</span> <span class="s2">&quot;sf_hypno / sf_data must be a whole number.&quot;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hypno</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">hypno</span><span class="p">),</span> <span class="n">repeats</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">hypno_fit_to_data</span><span class="p">(</span><span class="n">hypno</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Crop or pad the hypnogram to fit the length of data.</span>

<span class="sd">    Hypnogram and data MUST have the SAME sampling frequency.</span>

<span class="sd">    This is an internal function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    hypno : array_like</span>
<span class="sd">        The sleep staging (hypnogram) 1D array.</span>
<span class="sd">    data : np.array_like or mne.io.Raw</span>
<span class="sd">        1D or 2D EEG data. Can also be a MNE Raw object, in which case data and sf will be</span>
<span class="sd">        automatically extracted.</span>
<span class="sd">    sf : float, optional</span>
<span class="sd">        The sampling frequency of data AND the hypnogram.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    hypno : array_like</span>
<span class="sd">        Hypnogram, with the same number of samples as data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check if data is an MNE raw object</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">mne</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">BaseRaw</span><span class="p">):</span>
        <span class="n">sf</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;sfreq&quot;</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">times</span>  <span class="c1"># 1D array and does not require to preload data</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">hypno</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">hypno</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">hypno</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Hypno must be 1D.&quot;</span>
    <span class="n">npts_hyp</span> <span class="o">=</span> <span class="n">hypno</span><span class="o">.</span><span class="n">size</span>
    <span class="n">npts_data</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>  <span class="c1"># Support for 2D data</span>
    <span class="k">if</span> <span class="n">npts_hyp</span> <span class="o">&lt;</span> <span class="n">npts_data</span><span class="p">:</span>
        <span class="c1"># Hypnogram is shorter than data</span>
        <span class="n">npts_diff</span> <span class="o">=</span> <span class="n">npts_data</span> <span class="o">-</span> <span class="n">npts_hyp</span>
        <span class="k">if</span> <span class="n">sf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dur_diff</span> <span class="o">=</span> <span class="n">npts_diff</span> <span class="o">/</span> <span class="n">sf</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Hypnogram is SHORTER than data by </span><span class="si">%.2f</span><span class="s2"> seconds. &quot;</span>
                <span class="s2">&quot;Padding hypnogram with last value to match data.size.&quot;</span> <span class="o">%</span> <span class="n">dur_diff</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Hypnogram is SHORTER than data by </span><span class="si">%i</span><span class="s2"> samples. &quot;</span>
                <span class="s2">&quot;Padding hypnogram with last value to match data.size.&quot;</span> <span class="o">%</span> <span class="n">npts_diff</span>
            <span class="p">)</span>
        <span class="n">hypno</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">hypno</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">npts_diff</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;edge&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">npts_hyp</span> <span class="o">&gt;</span> <span class="n">npts_data</span><span class="p">:</span>
        <span class="c1"># Hypnogram is longer than data</span>
        <span class="n">npts_diff</span> <span class="o">=</span> <span class="n">npts_hyp</span> <span class="o">-</span> <span class="n">npts_data</span>
        <span class="k">if</span> <span class="n">sf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dur_diff</span> <span class="o">=</span> <span class="n">npts_diff</span> <span class="o">/</span> <span class="n">sf</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Hypnogram is LONGER than data by </span><span class="si">%.2f</span><span class="s2"> seconds. &quot;</span>
                <span class="s2">&quot;Cropping hypnogram to match data.size.&quot;</span> <span class="o">%</span> <span class="n">dur_diff</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Hypnogram is LONGER than data by </span><span class="si">%i</span><span class="s2"> samples. &quot;</span>
                <span class="s2">&quot;Cropping hypnogram to match data.size.&quot;</span> <span class="o">%</span> <span class="n">npts_diff</span>
            <span class="p">)</span>
        <span class="n">hypno</span> <span class="o">=</span> <span class="n">hypno</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">npts_data</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">hypno</span>


<div class="viewcode-block" id="hypno_upsample_to_data"><a class="viewcode-back" href="../../generated/yasa.hypno_upsample_to_data.html#yasa.hypno_upsample_to_data">[docs]</a><span class="k">def</span> <span class="nf">hypno_upsample_to_data</span><span class="p">(</span><span class="n">hypno</span><span class="p">,</span> <span class="n">sf_hypno</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">sf_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Upsample an hypnogram to a given sampling frequency and fit the</span>
<span class="sd">    resulting hypnogram to corresponding EEG data, such that the hypnogram</span>
<span class="sd">    and EEG data have the exact same number of samples.</span>

<span class="sd">    .. versionadded:: 0.1.5</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    hypno : array_like</span>
<span class="sd">        The sleep staging (hypnogram) 1D array.</span>
<span class="sd">    sf_hypno : float</span>
<span class="sd">        The current sampling frequency of the hypnogram, in Hz, e.g.</span>

<span class="sd">        * 1/30 = 1 value per each 30 seconds of EEG data,</span>
<span class="sd">        * 1 = 1 value per second of EEG data</span>
<span class="sd">    data : array_like or :py:class:`mne.io.BaseRaw`</span>
<span class="sd">        1D or 2D EEG data. Can also be a :py:class:`mne.io.BaseRaw`, in which</span>
<span class="sd">        case ``data`` and ``sf_data`` will be automatically extracted.</span>
<span class="sd">    sf_data : float</span>
<span class="sd">        The sampling frequency of ``data``, in Hz (e.g. 100 Hz, 256 Hz, ...).</span>
<span class="sd">        Can be omitted if ``data`` is a :py:class:`mne.io.BaseRaw`.</span>
<span class="sd">    verbose : bool or str</span>
<span class="sd">        Verbose level. Default (False) will only print warning and error</span>
<span class="sd">        messages. The logging levels are &#39;debug&#39;, &#39;info&#39;, &#39;warning&#39;, &#39;error&#39;,</span>
<span class="sd">        and &#39;critical&#39;. For most users the choice is between &#39;info&#39;</span>
<span class="sd">        (or ``verbose=True``) and warning (``verbose=False``).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    hypno : array_like</span>
<span class="sd">        The hypnogram, upsampled to ``sf_data`` and cropped/padded to ``max(data.shape)``.</span>

<span class="sd">    Warns</span>
<span class="sd">    -----</span>
<span class="sd">    UserWarning</span>
<span class="sd">        If the upsampled ``hypno`` is shorter / longer than ``max(data.shape)``</span>
<span class="sd">        and therefore needs to be padded/cropped respectively. This output can be disabled by</span>
<span class="sd">        passing ``verbose=&#39;ERROR&#39;``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># NOTE: FutureWarning not added here otherwise it would also be shown when calling</span>
    <span class="c1"># yasa.Hypnogram.upsample_to_data.</span>
    <span class="n">set_log_level</span><span class="p">(</span><span class="n">verbose</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">mne</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">BaseRaw</span><span class="p">):</span>
        <span class="n">sf_data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;sfreq&quot;</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">times</span>
    <span class="n">hypno_up</span> <span class="o">=</span> <span class="n">hypno_upsample_to_sf</span><span class="p">(</span><span class="n">hypno</span><span class="o">=</span><span class="n">hypno</span><span class="p">,</span> <span class="n">sf_hypno</span><span class="o">=</span><span class="n">sf_hypno</span><span class="p">,</span> <span class="n">sf_data</span><span class="o">=</span><span class="n">sf_data</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">hypno_fit_to_data</span><span class="p">(</span><span class="n">hypno</span><span class="o">=</span><span class="n">hypno_up</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="o">=</span><span class="n">sf_data</span><span class="p">)</span></div>


<span class="c1">#############################################################################</span>
<span class="c1"># HYPNO LOADING</span>
<span class="c1">#############################################################################</span>


<div class="viewcode-block" id="load_profusion_hypno"><a class="viewcode-back" href="../../generated/yasa.load_profusion_hypno.html#yasa.load_profusion_hypno">[docs]</a><span class="k">def</span> <span class="nf">load_profusion_hypno</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load a Compumedics Profusion hypnogram (.xml).</span>

<span class="sd">    The Compumedics Profusion hypnogram format is one of the two hypnogram</span>
<span class="sd">    formats found in the `National Sleep Research Resource (NSRR)</span>
<span class="sd">    &lt;https://sleepdata.org/&gt;`_ website. For more details on the format,</span>
<span class="sd">    please refer to</span>
<span class="sd">    https://github.com/nsrr/edf-editor-translator/wiki/Compumedics-Annotation-Format</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fname : str</span>
<span class="sd">        Filename with full path.</span>
<span class="sd">    replace : bool</span>
<span class="sd">        If True, the integer values will be mapped to YASA default, i.e.</span>
<span class="sd">        0 for Wake, 1 for N1, 2 for N2, 3 for N3 / S4 and 4 for REM.</span>
<span class="sd">        Note that the native profusion format is identical except for REM</span>
<span class="sd">        sleep which is marked as 5.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    hypno : 1D array (n_epochs, )</span>
<span class="sd">        Hypnogram, with one value per 30 second epochs.</span>
<span class="sd">    sf_hyp : float</span>
<span class="sd">        Sampling frequency of the hypnogram. Default is 1 / 30 Hz.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Note that an alternative is to use the `xmltodict` library:</span>
    <span class="c1"># &gt;&gt;&gt; with open(fname) as in_file:</span>
    <span class="c1"># &gt;&gt;&gt;   xml = in_file.read()</span>
    <span class="c1"># &gt;&gt;&gt; epoch_length = xml[&#39;EpochLength&#39;]</span>
    <span class="c1"># &gt;&gt;&gt; hypno = np.array(xml[&#39;SleepStages&#39;][&#39;SleepStage&#39;], dtype=&#39;int&#39;)</span>
    <span class="c1"># &gt;&gt;&gt; xml = xmltodict.parse(xml, process_namespaces=True)[&#39;CMPStudyConfig&#39;]</span>
    <span class="c1"># &gt;&gt;&gt; annotations = pd.DataFrame(xml[&#39;ScoredEvents&#39;][&#39;ScoredEvent&#39;])</span>
    <span class="c1"># &gt;&gt;&gt; annotations[&quot;Start&quot;] = annotations[&quot;Start&quot;].astype(float)</span>
    <span class="c1"># &gt;&gt;&gt; annotations[&quot;Duration&quot;] = annotations[&quot;Duration&quot;].astype(float)</span>
    <span class="kn">import</span> <span class="nn">xml.etree.ElementTree</span> <span class="k">as</span> <span class="nn">ET</span>

    <span class="n">tree</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
    <span class="n">root</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">getroot</span><span class="p">()</span>
    <span class="n">epoch_length</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">root</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
    <span class="n">sf_hyp</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">epoch_length</span>
    <span class="n">hypno</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">root</span><span class="p">[</span><span class="mi">4</span><span class="p">]:</span>
        <span class="n">hypno</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
    <span class="c1"># TODO: This should return a yasa.Hypnogram object</span>
    <span class="n">hypno</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">hypno</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">replace</span><span class="p">:</span>
        <span class="c1"># Stage 4 --&gt; 3 and REM --&gt; 4</span>
        <span class="n">hypno</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">hypno</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">({</span><span class="mi">4</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">:</span> <span class="mi">4</span><span class="p">})</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">hypno</span><span class="p">,</span> <span class="n">sf_hyp</span></div>


<span class="c1">#############################################################################</span>
<span class="c1"># PERIODS &amp; CYCLES</span>
<span class="c1">#############################################################################</span>


<div class="viewcode-block" id="hypno_find_periods"><a class="viewcode-back" href="../../generated/yasa.hypno_find_periods.html#yasa.hypno_find_periods">[docs]</a><span class="k">def</span> <span class="nf">hypno_find_periods</span><span class="p">(</span><span class="n">hypno</span><span class="p">,</span> <span class="n">sf_hypno</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="s2">&quot;5min&quot;</span><span class="p">,</span> <span class="n">equal_length</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find sequences of consecutive values exceeding a certain duration in hypnogram.</span>

<span class="sd">    .. versionadded:: 0.6.2</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    hypno : array_like</span>
<span class="sd">        A 1D array with the sleep stages (= hypnogram). The dtype can be anything (int, bool, str).</span>
<span class="sd">        More generally, this can be any vector for which you wish to find runs of</span>
<span class="sd">        consecutive items.</span>
<span class="sd">    sf_hypno : float</span>
<span class="sd">        The current sampling frequency of ``hypno``, in Hz, e.g. 1/30 = 1 value per each 30 seconds</span>
<span class="sd">        of EEG data, 1 = 1 value per second of EEG data.</span>
<span class="sd">    threshold : str</span>
<span class="sd">        This function will only keep periods that exceed a certain duration (default &#39;5min&#39;), e.g.</span>
<span class="sd">        &#39;5min&#39;, &#39;15min&#39;, &#39;30sec&#39;, &#39;1hour&#39;. To disable thresholding, use &#39;0sec&#39;.</span>
<span class="sd">    equal_length : bool</span>
<span class="sd">        If True, the periods will all have the exact duration defined</span>
<span class="sd">        in threshold. That is, periods that are longer than the duration threshold will be divided</span>
<span class="sd">        into sub-periods of exactly the length of ``threshold``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    periods : :py:class:`pandas.DataFrame`</span>
<span class="sd">        Output dataframe</span>

<span class="sd">        * ``values`` : The value in hypno of the current period</span>
<span class="sd">        * ``start`` : The index of the start of the period in hypno</span>
<span class="sd">        * ``length`` : The duration of the period, in number of samples</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Let&#39;s assume that we have an hypnogram where sleep = 1 and wake = 0. There is one value per</span>
<span class="sd">    minute, and therefore the sampling frequency of the hypnogram is 1 / 60 sec (~0.016 Hz).</span>

<span class="sd">    &gt;&gt;&gt; import yasa</span>
<span class="sd">    &gt;&gt;&gt; hypno = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0]</span>
<span class="sd">    &gt;&gt;&gt; yasa.hypno_find_periods(hypno, sf_hypno=1/60, threshold=&quot;0min&quot;)</span>
<span class="sd">       values  start  length</span>
<span class="sd">    0       0      0      11</span>
<span class="sd">    1       1     11       3</span>
<span class="sd">    2       0     14       2</span>
<span class="sd">    3       1     16       9</span>
<span class="sd">    4       0     25       2</span>

<span class="sd">    This gives us the start and duration of each sequence of consecutive values in the hypnogram.</span>
<span class="sd">    For example, the first row tells us that there is a sequence of 11 consecutive 0 starting at</span>
<span class="sd">    the first index of hypno.</span>

<span class="sd">    Now, we may want to keep only periods that are longer than a specific threshold,</span>
<span class="sd">    for example 5 minutes:</span>

<span class="sd">    &gt;&gt;&gt; yasa.hypno_find_periods(hypno, sf_hypno=1/60, threshold=&quot;5min&quot;)</span>
<span class="sd">       values  start  length</span>
<span class="sd">    0       0      0      11</span>
<span class="sd">    1       1     16       9</span>

<span class="sd">    Only the two sequences that are longer than 5 minutes (11 minutes and 9 minutes respectively)</span>
<span class="sd">    are kept. Feel free to play around with different values of threshold!</span>

<span class="sd">    This function is not limited to binary arrays, e.g.</span>

<span class="sd">    &gt;&gt;&gt; hypno = [0, 0, 0, 0, 1, 2, 2, 2, 2, 2, 2, 0, 0, 0, 1, 0, 1]</span>
<span class="sd">    &gt;&gt;&gt; yasa.hypno_find_periods(hypno, sf_hypno=1/60, threshold=&quot;2min&quot;)</span>
<span class="sd">       values  start  length</span>
<span class="sd">    0       0      0       4</span>
<span class="sd">    1       2      5       6</span>
<span class="sd">    2       0     11       3</span>

<span class="sd">    Lastly, using ``equal_length=True`` will further divide the periods into segments of the</span>
<span class="sd">    same duration, i.e. the duration defined in ``threshold``:</span>

<span class="sd">    &gt;&gt;&gt; hypno = [0, 0, 0, 0, 1, 2, 2, 2, 2, 2, 2, 0, 0, 0, 1, 0, 1]</span>
<span class="sd">    &gt;&gt;&gt; yasa.hypno_find_periods(hypno, sf_hypno=1/60, threshold=&quot;2min&quot;, equal_length=True)</span>
<span class="sd">       values  start  length</span>
<span class="sd">    0       0      0       2</span>
<span class="sd">    1       0      2       2</span>
<span class="sd">    2       2      5       2</span>
<span class="sd">    3       2      7       2</span>
<span class="sd">    4       2      9       2</span>
<span class="sd">    5       0     11       2</span>

<span class="sd">    Here, the first period of 4 minutes of consecutive 0 is further divided into 2 periods of</span>
<span class="sd">    exactly 2 minutes. Next, the sequence of 6 consecutive 2 is further divided into 3 periods of</span>
<span class="sd">    2 minutes. Lastly, the last value in the sequence of 3 consecutive 0 at the end of the array is</span>
<span class="sd">    removed to keep only a segment of 2 exactly minutes. In other words, the remainder of the</span>
<span class="sd">    division of a given segment by the desired duration is discarded.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># NOTE: FutureWarning not added here otherwise it would also be shown when calling</span>
    <span class="c1"># yasa.Hypnogram.find_periods</span>
    <span class="c1"># Convert the threshold to number of samples</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">threshold</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="s2">&quot;Threshold must be a string, e.g. &#39;5min&#39;, &#39;30sec&#39;, &#39;15min&#39;&quot;</span>
    <span class="n">thr_sec</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span><span class="n">threshold</span><span class="p">)</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span>
    <span class="n">thr_samp</span> <span class="o">=</span> <span class="n">sf_hypno</span> <span class="o">*</span> <span class="n">thr_sec</span>
    <span class="k">if</span> <span class="nb">float</span><span class="p">(</span><span class="n">thr_samp</span><span class="p">)</span><span class="o">.</span><span class="n">is_integer</span><span class="p">():</span>
        <span class="n">thr_samp</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">thr_samp</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;The selected threshold does not result in an whole number of samples (&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">thr_sec</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2"> seconds * </span><span class="si">{</span><span class="n">sf_hypno</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2"> Hz = </span><span class="si">{</span><span class="n">thr_samp</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2"> samples)&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Find run starts</span>
    <span class="c1"># https://gist.github.com/alimanfoo/c5977e87111abe8127453b21204c1065</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hypno</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)),</span> <span class="s2">&quot;hypno must be an array.&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">hypno</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">loc_run_start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">loc_run_start</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">loc_run_start</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">run_starts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">loc_run_start</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># Find run values</span>
    <span class="n">run_values</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">loc_run_start</span><span class="p">]</span>
    <span class="c1"># Find run lengths</span>
    <span class="n">run_lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">run_starts</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
    <span class="n">seq</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">&quot;values&quot;</span><span class="p">:</span> <span class="n">run_values</span><span class="p">,</span> <span class="s2">&quot;start&quot;</span><span class="p">:</span> <span class="n">run_starts</span><span class="p">,</span> <span class="s2">&quot;length&quot;</span><span class="p">:</span> <span class="n">run_lengths</span><span class="p">})</span>

    <span class="c1"># Remove runs that are shorter than threshold</span>
    <span class="n">seq</span> <span class="o">=</span> <span class="n">seq</span><span class="p">[</span><span class="n">seq</span><span class="p">[</span><span class="s2">&quot;length&quot;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">thr_samp</span><span class="p">]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">equal_length</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">seq</span>

    <span class="c1"># Divide into epochs of equal length</span>
    <span class="k">assert</span> <span class="n">thr_samp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Threshold must be non-zero if using equal_length=True.&quot;</span>
    <span class="n">new_seq</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;values&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s2">&quot;start&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s2">&quot;length&quot;</span><span class="p">:</span> <span class="p">[]}</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">seq</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">quotient</span><span class="p">,</span> <span class="n">remainder</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divmod</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;length&quot;</span><span class="p">],</span> <span class="n">thr_samp</span><span class="p">)</span>
        <span class="n">new_start</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;start&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">quotient</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">quotient</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">new_seq</span><span class="p">[</span><span class="s2">&quot;values&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;values&quot;</span><span class="p">])</span>
                <span class="n">new_seq</span><span class="p">[</span><span class="s2">&quot;start&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_start</span><span class="p">)</span>
                <span class="n">new_seq</span><span class="p">[</span><span class="s2">&quot;length&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">thr_samp</span><span class="p">)</span>
                <span class="n">new_start</span> <span class="o">+=</span> <span class="n">thr_samp</span>
                <span class="n">quotient</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_seq</span><span class="p">[</span><span class="s2">&quot;values&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;values&quot;</span><span class="p">])</span>
            <span class="n">new_seq</span><span class="p">[</span><span class="s2">&quot;start&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;start&quot;</span><span class="p">])</span>
            <span class="n">new_seq</span><span class="p">[</span><span class="s2">&quot;length&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;length&quot;</span><span class="p">])</span>

    <span class="n">new_seq</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">new_seq</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">new_seq</span></div>


<span class="c1">#############################################################################</span>
<span class="c1"># SIMULATION</span>
<span class="c1">#############################################################################</span>


<div class="viewcode-block" id="simulate_hypnogram"><a class="viewcode-back" href="../../generated/yasa.simulate_hypnogram.html#yasa.simulate_hypnogram">[docs]</a><span class="k">def</span> <span class="nf">simulate_hypnogram</span><span class="p">(</span>
    <span class="n">tib</span><span class="o">=</span><span class="mi">480</span><span class="p">,</span>
    <span class="n">trans_probas</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">init_probas</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Simulate a hypnogram based on transition probabilities.</span>

<span class="sd">    Current implentation is a naive Markov model. The initial stage of a hypnogram</span>
<span class="sd">    is generated using probabilites from ``init_probas`` and then subsequent stages</span>
<span class="sd">    are generated from a Markov sequence based on ``trans_probas``.</span>

<span class="sd">    .. important:: The Markov simulation model is not meant to accurately portray sleep</span>
<span class="sd">        macroarchitecture and should only be used for testing or other unique purposes.</span>

<span class="sd">    .. seealso:: :py:meth:`yasa.Hypnogram.simulate_similar`</span>

<span class="sd">    .. versionadded:: 0.6.3</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tib : int, float</span>
<span class="sd">        Total duration of the hypnogram (i.e., time in bed), expressed in minutes.</span>
<span class="sd">        Returned hypnogram will be slightly shorter if ``tib`` is not evenly divisible by ``freq``.</span>
<span class="sd">        Default is 480 minutes (= 8 hours).</span>

<span class="sd">        .. seealso:: :py:func:`yasa.sleep_statistics`</span>
<span class="sd">    trans_probas : :py:class:`pandas.DataFrame` or None</span>
<span class="sd">        Transition probability matrix where each cell is a transition probability</span>
<span class="sd">        between sleep stages of consecutive *epochs*.</span>

<span class="sd">        ``trans_probas`` is a `right stochastic matrix</span>
<span class="sd">        &lt;https://en.wikipedia.org/wiki/Stochastic_matrix&gt;`_, i.e. each row sums to 1.</span>

<span class="sd">        If None (default), transition probabilities come from Metzner et al., 2021 [Metzner2021]_.</span>
<span class="sd">        If :py:class:`pandas.DataFrame`, must have &quot;from&quot;-stages as indices and</span>
<span class="sd">        &quot;to&quot;-stages as columns. Indices and columns must follow YASA string</span>
<span class="sd">        hypnogram convention (e.g., WAKE, N1). Unscored/Artefact stages are not allowed.</span>

<span class="sd">        .. note:: Transition probability matrices should indicate the transition</span>
<span class="sd">            probability between *epochs* (i.e., probability of the next epoch) and</span>
<span class="sd">            not simply stage (i.e., probability of non-similar stage).</span>

<span class="sd">        .. seealso:: Return value from :py:func:`yasa.transition_matrix`</span>
<span class="sd">    init_probas : :py:class:`pandas.Series` or None</span>
<span class="sd">        Probabilites of each stage to initialize random walk.</span>
<span class="sd">        If None (default), initialize with &quot;from&quot;-WAKE row of ``trans_probas``.</span>
<span class="sd">        If :py:class:`pandas.Series`, indices must be stages following YASA string</span>
<span class="sd">        hypnogram convention and identical to those of ``trans_probas``.</span>
<span class="sd">    seed : int or None</span>
<span class="sd">        Random seed for generating Markov sequence.</span>
<span class="sd">        If an integer number is provided, the random hypnogram will be predictable.</span>
<span class="sd">        This argument is required if reproducible results are desired.</span>
<span class="sd">    **kwargs : dict</span>
<span class="sd">        Other arguments that are passed to :py:class:`yasa.Hypnogram`.</span>

<span class="sd">        .. note:: `n_stages` and `freq` must be consistent with a user-specificied `trans_probas`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    hyp : :py:class:`yasa.Hypnogram`</span>
<span class="sd">        Hypnogram containing simulated sleep stages.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Default transition probabilities are based on 30-second epochs and can be found in the</span>
<span class="sd">    ``traMat_Epoch.npy`` file of Supplementary Information for Metzner et al., 2021 [Metzner2021]_</span>
<span class="sd">    (rounded values are viewable in Figure 5b). Please cite this work if these probabilites are used</span>
<span class="sd">    for publication.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [Metzner2021] Metzner, C., Schilling, A., Traxdorf, M., Schulze, H., &amp; Krausse, P.</span>
<span class="sd">                     (2021). Sleep as a random walk: a super-statistical analysis of EEG</span>
<span class="sd">                     data across sleep stages. Communications Biology, 4.</span>
<span class="sd">                     https://doi.org/10.1038/s42003-021-02912-6</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from yasa import simulate_hypnogram</span>
<span class="sd">    &gt;&gt;&gt; hyp = simulate_hypnogram(tib=5, seed=1)</span>
<span class="sd">    &gt;&gt;&gt; hyp</span>
<span class="sd">    &lt;Hypnogram | 10 epochs x 30s (5.00 minutes), 5 stages&gt;</span>
<span class="sd">     - Use `.hypno` to get the string values as a pandas.Series</span>
<span class="sd">     - Use `.as_int()` to get the integer values as a pandas.Series</span>
<span class="sd">     - Use `.plot_hypnogram()` to plot the hypnogram</span>
<span class="sd">    See the online documentation for more details.</span>

<span class="sd">    &gt;&gt;&gt; hyp.hypno</span>
<span class="sd">    Epoch</span>
<span class="sd">    0    WAKE</span>
<span class="sd">    1      N1</span>
<span class="sd">    2      N1</span>
<span class="sd">    3      N2</span>
<span class="sd">    4      N2</span>
<span class="sd">    5      N2</span>
<span class="sd">    6      N2</span>
<span class="sd">    7      N2</span>
<span class="sd">    8      N2</span>
<span class="sd">    9      N2</span>
<span class="sd">    Name: Stage, dtype: object</span>

<span class="sd">    &gt;&gt;&gt; hyp = simulate_hypnogram(tib=5, n_stages=2, seed=1)</span>
<span class="sd">    &gt;&gt;&gt; hyp.hypno</span>
<span class="sd">    Epoch</span>
<span class="sd">    0     WAKE</span>
<span class="sd">    1    SLEEP</span>
<span class="sd">    2    SLEEP</span>
<span class="sd">    3    SLEEP</span>
<span class="sd">    4    SLEEP</span>
<span class="sd">    5    SLEEP</span>
<span class="sd">    6    SLEEP</span>
<span class="sd">    7    SLEEP</span>
<span class="sd">    8    SLEEP</span>
<span class="sd">    9    SLEEP</span>
<span class="sd">    Name: Stage, dtype: object</span>

<span class="sd">    Add some Unscored epochs.</span>

<span class="sd">    &gt;&gt;&gt; hyp = simulate_hypnogram(tib=5, n_stages=2, seed=1)</span>
<span class="sd">    &gt;&gt;&gt; hyp.hypno.iloc[-2:] = &quot;UNS&quot;</span>
<span class="sd">    &gt;&gt;&gt; hyp.hypno</span>
<span class="sd">    Epoch</span>
<span class="sd">    0     WAKE</span>
<span class="sd">    1    SLEEP</span>
<span class="sd">    2    SLEEP</span>
<span class="sd">    3    SLEEP</span>
<span class="sd">    4    SLEEP</span>
<span class="sd">    5    SLEEP</span>
<span class="sd">    6    SLEEP</span>
<span class="sd">    7    SLEEP</span>
<span class="sd">    8      UNS</span>
<span class="sd">    9      UNS</span>
<span class="sd">    Name: Stage, dtype: object</span>

<span class="sd">    Base the data off a real subject&#39;s transition matrix.</span>

<span class="sd">    .. plot::</span>

<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">        &gt;&gt;&gt; from yasa import Hypnogram, hypno_int_to_str</span>
<span class="sd">        &gt;&gt;&gt; url = (</span>
<span class="sd">        &gt;&gt;&gt;     &quot;https://github.com/raphaelvallat/yasa/raw/master/&quot;</span>
<span class="sd">        &gt;&gt;&gt;     &quot;notebooks/data_full_6hrs_100Hz_hypno_30s.txt&quot;</span>
<span class="sd">        &gt;&gt;&gt; )</span>
<span class="sd">        &gt;&gt;&gt; values_str = hypno_int_to_str(np.loadtxt(url))</span>
<span class="sd">        &gt;&gt;&gt; real_hyp = Hypnogram(values_str)</span>
<span class="sd">        &gt;&gt;&gt; fake_hyp = real_hyp.simulate_similar(seed=2)</span>
<span class="sd">        &gt;&gt;&gt; fig, (ax1, ax2) = plt.subplots(nrows=2, figsize=(7, 5))</span>
<span class="sd">        &gt;&gt;&gt; real_hyp.plot_hypnogram(ax=ax1).set_title(&quot;Real hypnogram&quot;)</span>
<span class="sd">        &gt;&gt;&gt; fake_hyp.plot_hypnogram(ax=ax2).set_title(&quot;Fake hypnogram&quot;)</span>
<span class="sd">        &gt;&gt;&gt; plt.tight_layout()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Extract yasa.Hypnogram defaults, which will be assumed later but need throughout</span>
    <span class="k">if</span> <span class="s2">&quot;n_stages&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;n_stages&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="k">if</span> <span class="s2">&quot;freq&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;freq&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;30s&quot;</span>
    <span class="c1"># Validate input</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tib</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span> <span class="ow">and</span> <span class="n">tib</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;`tib` must be a number &gt; 0&quot;</span>
    <span class="k">if</span> <span class="n">trans_probas</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">trans_probas</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">),</span> <span class="s2">&quot;`trans_probas` must be a pandas DataFrame&quot;</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">less_equal</span><span class="p">(</span><span class="n">trans_probas</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;n_stages&quot;</span><span class="p">])</span>
        <span class="p">),</span> <span class="s2">&quot;user-specified `trans_probas` must not include more stages than `n_stages`&quot;</span>
    <span class="k">if</span> <span class="n">init_probas</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">init_probas</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">),</span> <span class="s2">&quot;`init_probas` must be a pandas Series&quot;</span>
    <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">seed</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;`seed` must be an integer &gt;= 0&quot;</span>
    <span class="k">if</span> <span class="n">trans_probas</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Check this here, rather than letting hyp.upsample catch it, to be clear about reason</span>
        <span class="k">assert</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;freq&quot;</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span>
            <span class="s2">&quot;30s&quot;</span>
        <span class="p">),</span> <span class="s2">&quot;`freq` must be &lt;= 30s when using default `trans_probas`&quot;</span>

    <span class="c1"># Initialize random number generator</span>
    <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_markov_sequence</span><span class="p">(</span><span class="n">p_init</span><span class="p">,</span> <span class="n">p_transition</span><span class="p">,</span> <span class="n">sequence_length</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate a Markov sequence based on p_init and p_transition.</span>
<span class="sd">        https://ericmjl.github.io/essays-on-data-science/machine-learning/markov-models</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">initial_state</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">rng</span><span class="o">.</span><span class="n">multinomial</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">p_init</span><span class="p">))</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">states</span> <span class="o">=</span> <span class="p">[</span><span class="n">initial_state</span><span class="p">]</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">states</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">sequence_length</span><span class="p">:</span>
            <span class="n">p_tr</span> <span class="o">=</span> <span class="n">p_transition</span><span class="p">[</span><span class="n">states</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">new_state</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">rng</span><span class="o">.</span><span class="n">multinomial</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">p_tr</span><span class="p">))</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">states</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_state</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">states</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">trans_probas</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Generate transition probability DataFrame</span>
        <span class="n">trans_freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="p">[</span><span class="mi">11737</span><span class="p">,</span> <span class="mi">571</span><span class="p">,</span> <span class="mi">84</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
                <span class="p">[</span><span class="mi">281</span><span class="p">,</span> <span class="mi">6697</span><span class="p">,</span> <span class="mi">1661</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">59</span><span class="p">],</span>
                <span class="p">[</span><span class="mi">253</span><span class="p">,</span> <span class="mi">1070</span><span class="p">,</span> <span class="mi">26259</span><span class="p">,</span> <span class="mi">505</span><span class="p">,</span> <span class="mi">272</span><span class="p">],</span>
                <span class="p">[</span><span class="mi">49</span><span class="p">,</span> <span class="mi">176</span><span class="p">,</span> <span class="mi">279</span><span class="p">,</span> <span class="mi">9630</span><span class="p">,</span> <span class="mi">12</span><span class="p">],</span>
                <span class="p">[</span><span class="mi">57</span><span class="p">,</span> <span class="mi">189</span><span class="p">,</span> <span class="mi">84</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10071</span><span class="p">],</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="n">trans_probas</span> <span class="o">=</span> <span class="n">trans_freqs</span> <span class="o">/</span> <span class="n">trans_freqs</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">trans_probas</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">trans_probas</span><span class="p">,</span>
            <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;WAKE&quot;</span><span class="p">,</span> <span class="s2">&quot;N1&quot;</span><span class="p">,</span> <span class="s2">&quot;N2&quot;</span><span class="p">,</span> <span class="s2">&quot;N3&quot;</span><span class="p">,</span> <span class="s2">&quot;REM&quot;</span><span class="p">],</span>
            <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;WAKE&quot;</span><span class="p">,</span> <span class="s2">&quot;N1&quot;</span><span class="p">,</span> <span class="s2">&quot;N2&quot;</span><span class="p">,</span> <span class="s2">&quot;N3&quot;</span><span class="p">,</span> <span class="s2">&quot;REM&quot;</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="n">trans_probas</span><span class="o">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;is_default&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">trans_probas</span><span class="o">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;is_default&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">}</span>

    <span class="k">if</span> <span class="n">init_probas</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Extract Wake row of initial probabilities as a Series</span>
        <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="s2">&quot;W&quot;</span><span class="p">,</span> <span class="s2">&quot;wake&quot;</span><span class="p">,</span> <span class="s2">&quot;WAKE&quot;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">trans_probas</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
                <span class="n">init_probas</span> <span class="o">=</span> <span class="n">trans_probas</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">w</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">init_probas</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;`trans_probas` must include &#39;WAKE&#39; in the index&quot;</span>

    <span class="n">stage_order</span> <span class="o">=</span> <span class="n">init_probas</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="k">assert</span> <span class="p">(</span>
        <span class="n">stage_order</span> <span class="o">==</span> <span class="n">trans_probas</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">==</span> <span class="n">trans_probas</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="p">),</span> <span class="s2">&quot;`init_probas` and `trans_probas` must have all matching indices&quot;</span>

    <span class="c1"># Extract probabilities as arrays</span>
    <span class="n">trans_arr</span> <span class="o">=</span> <span class="n">trans_probas</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
    <span class="n">init_arr</span> <span class="o">=</span> <span class="n">init_probas</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

    <span class="c1"># Make sure all rows sum to 1</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">trans_arr</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="p">),</span> <span class="s2">&quot;All rows of `trans_probas` must sum to 1&quot;</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">init_arr</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="mi">1</span><span class="p">),</span> <span class="s2">&quot;`init_probas` must sum to 1&quot;</span>

    <span class="c1"># Find number of *complete* epochs within TIB duration to simulate</span>
    <span class="k">if</span> <span class="n">trans_probas</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;is_default&quot;</span><span class="p">):</span>
        <span class="n">freq_sec</span> <span class="o">=</span> <span class="mi">30</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">freq_sec</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;freq&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span>
    <span class="n">n_epochs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">tib</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">/</span> <span class="n">freq_sec</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="c1"># Generate hypnogram integer values</span>
    <span class="n">values_int</span> <span class="o">=</span> <span class="n">_markov_sequence</span><span class="p">(</span><span class="n">init_arr</span><span class="p">,</span> <span class="n">trans_arr</span><span class="p">,</span> <span class="n">n_epochs</span><span class="p">)</span>
    <span class="c1"># Convert to hypnogram string values (based on indices)</span>
    <span class="n">values_str</span> <span class="o">=</span> <span class="p">[</span><span class="n">stage_order</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">values_int</span><span class="p">]</span>

    <span class="c1"># Create YASA hypnogram instance</span>
    <span class="k">if</span> <span class="n">trans_probas</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;is_default&quot;</span><span class="p">):</span>
        <span class="c1"># If using default trans_probas, hyp *must* be initialized with 5 stages and 30s epochs</span>
        <span class="n">n_stages</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;n_stages&quot;</span><span class="p">)</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>
        <span class="n">hyp</span> <span class="o">=</span> <span class="n">Hypnogram</span><span class="p">(</span><span class="n">values_str</span><span class="p">,</span> <span class="n">n_stages</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="s2">&quot;30s&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span><span class="s2">&quot;30s&quot;</span><span class="p">):</span>
            <span class="n">hyp</span> <span class="o">=</span> <span class="n">hyp</span><span class="o">.</span><span class="n">upsample</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n_stages</span> <span class="o">!=</span> <span class="mi">5</span><span class="p">:</span>
            <span class="n">hyp</span> <span class="o">=</span> <span class="n">hyp</span><span class="o">.</span><span class="n">consolidate_stages</span><span class="p">(</span><span class="n">n_stages</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">hyp</span> <span class="o">=</span> <span class="n">Hypnogram</span><span class="p">(</span><span class="n">values_str</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">hyp</span></div>
</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
      
    </p>
    <p>
        &copy; Copyright 2018-2024, Dr. Raphael Vallat, Center for Human Sleep Science, UC Berkeley.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.4.0.<br/>
    </p>
  </div>
</footer>
  </body>
</html>