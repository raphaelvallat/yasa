<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>yasa.detection &#8212; yasa 0.6.0 documentation</title>
    <link rel="stylesheet" href="../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../../_static/js/jquery-1.12.4.min.js "></script>
<script type="text/javascript" src="../../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../../_static/bootstrap-3.4.1/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../../_static/bootstrap-sphinx.js "></script>

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../index.html"><span><img src="../../_static/yasa_128x128.png"></span>
          yasa</a>
        <span class="navbar-text navbar-version pull-left"><b>0.6.0</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../../api.html">API</a></li>
                <li><a href="../../quickstart.html">Quickstart</a></li>
                <li><a href="../../faq.html">FAQ</a></li>
                <li><a href="../../changelog.html">What's new</a></li>
                <li><a href="../../contributing.html">Contribute</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"></ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <h1>Source code for yasa.detection</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">YASA (Yet Another Spindle Algorithm): fast and robust detection of spindles,</span>
<span class="sd">slow-waves, and rapid eye movements from sleep EEG recordings.</span>

<span class="sd">- Author: Raphael Vallat (www.raphaelvallat.com)</span>
<span class="sd">- GitHub: https://github.com/raphaelvallat/yasa</span>
<span class="sd">- License: BSD 3-Clause License</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">mne</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">signal</span>
<span class="kn">from</span> <span class="nn">mne.filter</span> <span class="kn">import</span> <span class="n">filter_data</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">interp1d</span>
<span class="kn">from</span> <span class="nn">scipy.fftpack</span> <span class="kn">import</span> <span class="n">next_fast_len</span>
<span class="kn">from</span> <span class="nn">sklearn.ensemble</span> <span class="kn">import</span> <span class="n">IsolationForest</span>

<span class="kn">from</span> <span class="nn">.spectral</span> <span class="kn">import</span> <span class="n">stft_power</span>
<span class="kn">from</span> <span class="nn">.numba</span> <span class="kn">import</span> <span class="n">_detrend</span><span class="p">,</span> <span class="n">_rms</span>
<span class="kn">from</span> <span class="nn">.io</span> <span class="kn">import</span> <span class="n">set_log_level</span><span class="p">,</span> <span class="n">is_tensorpac_installed</span><span class="p">,</span> <span class="n">is_pyriemann_installed</span>
<span class="kn">from</span> <span class="nn">.others</span> <span class="kn">import</span> <span class="p">(</span><span class="n">moving_transform</span><span class="p">,</span> <span class="n">trimbothstd</span><span class="p">,</span> <span class="n">get_centered_indices</span><span class="p">,</span>
                     <span class="n">sliding_window</span><span class="p">,</span> <span class="n">_merge_close</span><span class="p">,</span> <span class="n">_zerocrossings</span><span class="p">)</span>


<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;yasa&#39;</span><span class="p">)</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;art_detect&#39;</span><span class="p">,</span> <span class="s1">&#39;spindles_detect&#39;</span><span class="p">,</span> <span class="s1">&#39;SpindlesResults&#39;</span><span class="p">,</span> <span class="s1">&#39;sw_detect&#39;</span><span class="p">,</span> <span class="s1">&#39;SWResults&#39;</span><span class="p">,</span>
           <span class="s1">&#39;rem_detect&#39;</span><span class="p">,</span> <span class="s1">&#39;REMResults&#39;</span><span class="p">]</span>


<span class="c1">#############################################################################</span>
<span class="c1"># DATA PREPROCESSING</span>
<span class="c1">#############################################################################</span>

<span class="k">def</span> <span class="nf">_check_data_hypno</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ch_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">hypno</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">include</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">check_amp</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper functions for preprocessing of data and hypnogram.&quot;&quot;&quot;</span>
    <span class="c1"># 1) Extract data as a 2D NumPy array</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">mne</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">BaseRaw</span><span class="p">):</span>
        <span class="n">sf</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">]</span>  <span class="c1"># Extract sampling frequency</span>
        <span class="n">ch_names</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">ch_names</span>  <span class="c1"># Extract channel names</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span> <span class="o">*</span> <span class="mf">1e6</span>  <span class="c1"># Convert from V to uV</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">sf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;sf must be specified if not using MNE Raw.&#39;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;data must be 1D (times) or 2D (chan, times).&#39;</span>
    <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Force to 2D array: (n_chan, n_samples)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
    <span class="n">n_chan</span><span class="p">,</span> <span class="n">n_samples</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>

    <span class="c1"># 2) Check channel names</span>
    <span class="k">if</span> <span class="n">ch_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ch_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;CHAN&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_chan</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">ch_names</span><span class="p">)</span> <span class="o">==</span> <span class="n">n_chan</span>

    <span class="c1"># 3) Check hypnogram</span>
    <span class="k">if</span> <span class="n">hypno</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">hypno</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">hypno</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">hypno</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;Hypno must be one dimensional.&#39;</span>
        <span class="k">assert</span> <span class="n">hypno</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">n_samples</span><span class="p">,</span> <span class="s1">&#39;Hypno must have same size as data.&#39;</span>
        <span class="n">unique_hypno</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">hypno</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Number of unique values in hypno = </span><span class="si">%i</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">unique_hypno</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">include</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;include cannot be None if hypno is given&#39;</span>
        <span class="n">include</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">include</span><span class="p">))</span>
        <span class="k">assert</span> <span class="n">include</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;`include` must have at least one element.&#39;</span>
        <span class="k">assert</span> <span class="n">hypno</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">include</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;hypno and include must have same dtype&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">hypno</span><span class="p">,</span> <span class="n">include</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(),</span> <span class="p">(</span><span class="s1">&#39;None of the stages specified &#39;</span>
                                               <span class="s1">&#39;in `include` are present in &#39;</span>
                                               <span class="s1">&#39;hypno.&#39;</span><span class="p">)</span>

    <span class="c1"># 4) Check data amplitude</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Number of samples in data = </span><span class="si">%i</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Sampling frequency = </span><span class="si">%.2f</span><span class="s1"> Hz&#39;</span><span class="p">,</span> <span class="n">sf</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Data duration = </span><span class="si">%.2f</span><span class="s1"> seconds&#39;</span><span class="p">,</span> <span class="n">n_samples</span> <span class="o">/</span> <span class="n">sf</span><span class="p">)</span>
    <span class="n">all_ptp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">all_trimstd</span> <span class="o">=</span> <span class="n">trimbothstd</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">cut</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
    <span class="n">bad_chan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_chan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_chan</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Trimmed standard deviation of </span><span class="si">%s</span><span class="s1"> = </span><span class="si">%.4f</span><span class="s1"> uV&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ch_names</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">all_trimstd</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Peak-to-peak amplitude of </span><span class="si">%s</span><span class="s1"> = </span><span class="si">%.4f</span><span class="s1"> uV&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ch_names</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">all_ptp</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">check_amp</span> <span class="ow">and</span> <span class="ow">not</span><span class="p">(</span><span class="mf">0.1</span> <span class="o">&lt;</span> <span class="n">all_trimstd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">1e3</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Wrong data amplitude for </span><span class="si">%s</span><span class="s1"> &#39;</span>
                         <span class="s1">&#39;(trimmed STD = </span><span class="si">%.3f</span><span class="s1">). Unit of data MUST be uV! &#39;</span>
                         <span class="s1">&#39;Channel will be skipped.&#39;</span>
                         <span class="o">%</span> <span class="p">(</span><span class="n">ch_names</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">all_trimstd</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="n">bad_chan</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># 5) Create sleep stage vector mask</span>
    <span class="k">if</span> <span class="n">hypno</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">hypno</span><span class="p">,</span> <span class="n">include</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">ch_names</span><span class="p">,</span> <span class="n">hypno</span><span class="p">,</span> <span class="n">include</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">n_chan</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">,</span> <span class="n">bad_chan</span><span class="p">)</span>


<span class="c1">#############################################################################</span>
<span class="c1"># BASE DETECTION RESULTS CLASS</span>
<span class="c1">#############################################################################</span>


<span class="k">class</span> <span class="nc">_DetectionResults</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Main class for detection results.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">ch_names</span><span class="p">,</span> <span class="n">hypno</span><span class="p">,</span> <span class="n">data_filt</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_events</span> <span class="o">=</span> <span class="n">events</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sf</span> <span class="o">=</span> <span class="n">sf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hypno</span> <span class="o">=</span> <span class="n">hypno</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ch_names</span> <span class="o">=</span> <span class="n">ch_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_filt</span> <span class="o">=</span> <span class="n">data_filt</span>

    <span class="k">def</span> <span class="nf">_check_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">)))</span>
        <span class="n">n_events</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_events</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_events</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span>  <span class="c1"># All set to True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">mask</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;Mask must be a boolean array.&quot;</span>
            <span class="k">assert</span> <span class="n">mask</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Mask must be one-dimensional&quot;</span>
            <span class="k">assert</span> <span class="n">mask</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">n_events</span><span class="p">,</span> <span class="s2">&quot;Mask.size must be the number of detected events.&quot;</span>
        <span class="k">return</span> <span class="n">mask</span>

    <span class="k">def</span> <span class="nf">summary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event_type</span><span class="p">,</span> <span class="n">grp_chan</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">grp_stage</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">aggfunc</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Summary&quot;&quot;&quot;</span>
        <span class="c1"># Check masking</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_mask</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>

        <span class="c1"># Define grouping</span>
        <span class="n">grouper</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">grp_stage</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="s1">&#39;Stage&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_events</span><span class="p">:</span>
            <span class="n">grouper</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;Stage&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">grp_chan</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="s1">&#39;Channel&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_events</span><span class="p">:</span>
            <span class="n">grouper</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;Channel&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">grouper</span><span class="p">):</span>
            <span class="c1"># Return a copy of self._events after masking, without grouping</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_events</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">event_type</span> <span class="o">==</span> <span class="s1">&#39;spindles&#39;</span><span class="p">:</span>
            <span class="n">aggdict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Start&#39;</span><span class="p">:</span> <span class="s1">&#39;count&#39;</span><span class="p">,</span>
                       <span class="s1">&#39;Duration&#39;</span><span class="p">:</span> <span class="n">aggfunc</span><span class="p">,</span>
                       <span class="s1">&#39;Amplitude&#39;</span><span class="p">:</span> <span class="n">aggfunc</span><span class="p">,</span>
                       <span class="s1">&#39;RMS&#39;</span><span class="p">:</span> <span class="n">aggfunc</span><span class="p">,</span>
                       <span class="s1">&#39;AbsPower&#39;</span><span class="p">:</span> <span class="n">aggfunc</span><span class="p">,</span>
                       <span class="s1">&#39;RelPower&#39;</span><span class="p">:</span> <span class="n">aggfunc</span><span class="p">,</span>
                       <span class="s1">&#39;Frequency&#39;</span><span class="p">:</span> <span class="n">aggfunc</span><span class="p">,</span>
                       <span class="s1">&#39;Oscillations&#39;</span><span class="p">:</span> <span class="n">aggfunc</span><span class="p">,</span>
                       <span class="s1">&#39;Symmetry&#39;</span><span class="p">:</span> <span class="n">aggfunc</span><span class="p">}</span>

            <span class="c1"># if &#39;SOPhase&#39; in self._events:</span>
            <span class="c1">#     from scipy.stats import circmean</span>
            <span class="c1">#     aggdict[&#39;SOPhase&#39;] = lambda x: circmean(x, low=-np.pi, high=np.pi)</span>

        <span class="k">elif</span> <span class="n">event_type</span> <span class="o">==</span> <span class="s1">&#39;sw&#39;</span><span class="p">:</span>
            <span class="n">aggdict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Start&#39;</span><span class="p">:</span> <span class="s1">&#39;count&#39;</span><span class="p">,</span>
                       <span class="s1">&#39;Duration&#39;</span><span class="p">:</span> <span class="n">aggfunc</span><span class="p">,</span>
                       <span class="s1">&#39;ValNegPeak&#39;</span><span class="p">:</span> <span class="n">aggfunc</span><span class="p">,</span>
                       <span class="s1">&#39;ValPosPeak&#39;</span><span class="p">:</span> <span class="n">aggfunc</span><span class="p">,</span>
                       <span class="s1">&#39;PTP&#39;</span><span class="p">:</span> <span class="n">aggfunc</span><span class="p">,</span>
                       <span class="s1">&#39;Slope&#39;</span><span class="p">:</span> <span class="n">aggfunc</span><span class="p">,</span>
                       <span class="s1">&#39;Frequency&#39;</span><span class="p">:</span> <span class="n">aggfunc</span><span class="p">}</span>

            <span class="k">if</span> <span class="s1">&#39;PhaseAtSigmaPeak&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_events</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">circmean</span>
                <span class="n">aggdict</span><span class="p">[</span><span class="s1">&#39;PhaseAtSigmaPeak&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">circmean</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">low</span><span class="o">=-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
                <span class="n">aggdict</span><span class="p">[</span><span class="s1">&#39;ndPAC&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">aggfunc</span>

            <span class="k">if</span> <span class="s2">&quot;CooccurringSpindle&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_events</span><span class="p">:</span>
                <span class="c1"># We do not average &quot;CooccurringSpindlePeak&quot;</span>
                <span class="n">aggdict</span><span class="p">[</span><span class="s2">&quot;CooccurringSpindle&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">aggfunc</span>
                <span class="n">aggdict</span><span class="p">[</span><span class="s2">&quot;DistanceSpindleToSW&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">aggfunc</span>

        <span class="k">else</span><span class="p">:</span>  <span class="c1"># REM</span>
            <span class="n">aggdict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Start&#39;</span><span class="p">:</span> <span class="s1">&#39;count&#39;</span><span class="p">,</span>
                       <span class="s1">&#39;Duration&#39;</span><span class="p">:</span> <span class="n">aggfunc</span><span class="p">,</span>
                       <span class="s1">&#39;LOCAbsValPeak&#39;</span><span class="p">:</span> <span class="n">aggfunc</span><span class="p">,</span>
                       <span class="s1">&#39;ROCAbsValPeak&#39;</span><span class="p">:</span> <span class="n">aggfunc</span><span class="p">,</span>
                       <span class="s1">&#39;LOCAbsRiseSlope&#39;</span><span class="p">:</span> <span class="n">aggfunc</span><span class="p">,</span>
                       <span class="s1">&#39;ROCAbsRiseSlope&#39;</span><span class="p">:</span> <span class="n">aggfunc</span><span class="p">,</span>
                       <span class="s1">&#39;LOCAbsFallSlope&#39;</span><span class="p">:</span> <span class="n">aggfunc</span><span class="p">,</span>
                       <span class="s1">&#39;ROCAbsFallSlope&#39;</span><span class="p">:</span> <span class="n">aggfunc</span><span class="p">}</span>

        <span class="c1"># Apply grouping, after masking</span>
        <span class="n">df_grp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_events</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">grouper</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="n">sort</span><span class="p">,</span> <span class="n">as_index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="n">aggdict</span><span class="p">)</span>
        <span class="n">df_grp</span> <span class="o">=</span> <span class="n">df_grp</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;Start&#39;</span><span class="p">:</span> <span class="s1">&#39;Count&#39;</span><span class="p">})</span>

        <span class="c1"># Calculate density (= number per min of each stage)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hypno</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">grp_stage</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">stages</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_events</span><span class="p">[</span><span class="s1">&#39;Stage&#39;</span><span class="p">])</span>
            <span class="n">dur</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="n">stages</span><span class="p">:</span>
                <span class="c1"># Get duration in minutes of each stage present in dataframe</span>
                <span class="n">dur</span><span class="p">[</span><span class="n">st</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hypno</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_hypno</span> <span class="o">==</span> <span class="n">st</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">/</span> <span class="p">(</span><span class="mi">60</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sf</span><span class="p">)</span>

            <span class="c1"># Insert new density column in grouped dataframe after count</span>
            <span class="n">df_grp</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
                <span class="n">loc</span><span class="o">=</span><span class="n">df_grp</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="s1">&#39;Count&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="s1">&#39;Density&#39;</span><span class="p">,</span>
                <span class="n">value</span><span class="o">=</span><span class="n">df_grp</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">rw</span><span class="p">:</span> <span class="n">rw</span><span class="p">[</span><span class="s1">&#39;Count&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">dur</span><span class="p">[</span><span class="n">rw</span><span class="p">[</span><span class="s1">&#39;Stage&#39;</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">df_grp</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">grouper</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;get_mask&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">yasa.others</span> <span class="kn">import</span> <span class="n">_index_to_events</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_events</span><span class="p">[</span><span class="s1">&#39;IdxChannel&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>
            <span class="n">ev_chan</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_events</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_events</span><span class="p">[</span><span class="s1">&#39;IdxChannel&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span>
            <span class="n">idx_ev</span> <span class="o">=</span> <span class="n">_index_to_events</span><span class="p">(</span>
                <span class="n">ev_chan</span><span class="p">[[</span><span class="s1">&#39;Start&#39;</span><span class="p">,</span> <span class="s1">&#39;End&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sf</span><span class="p">)</span>
            <span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">idx_ev</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_sync_events</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">time_before</span><span class="p">,</span> <span class="n">time_after</span><span class="p">,</span> <span class="n">filt</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">as_dataframe</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get_sync_events (not for REM, spindles &amp; SW only)&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">yasa.others</span> <span class="kn">import</span> <span class="n">get_centered_indices</span>
        <span class="k">assert</span> <span class="n">time_before</span> <span class="o">&gt;=</span> <span class="mi">0</span>
        <span class="k">assert</span> <span class="n">time_after</span> <span class="o">&gt;=</span> <span class="mi">0</span>
        <span class="n">bef</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sf</span> <span class="o">*</span> <span class="n">time_before</span><span class="p">)</span>
        <span class="n">aft</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sf</span> <span class="o">*</span> <span class="n">time_after</span><span class="p">)</span>
        <span class="c1"># TODO: Step size is determined by sf: 0.01 sec at 100 Hz, 0.002 sec at</span>
        <span class="c1"># 500 Hz, 0.00390625 sec at 256 Hz. Should we add resample=100 (Hz) or step_size=0.01?</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">bef</span><span class="p">,</span> <span class="n">aft</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int&#39;</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sf</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">filt</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">filter_data</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sf</span><span class="p">,</span> <span class="n">l_freq</span><span class="o">=</span><span class="n">filt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">h_freq</span><span class="o">=</span><span class="n">filt</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;fir&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>

        <span class="c1"># Apply mask</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_mask</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
        <span class="n">masked_events</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_events</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="p">:]</span>

        <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">masked_events</span><span class="p">[</span><span class="s1">&#39;IdxChannel&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>
            <span class="c1"># Copy is required to merge with the stage later on</span>
            <span class="n">ev_chan</span> <span class="o">=</span> <span class="n">masked_events</span><span class="p">[</span><span class="n">masked_events</span><span class="p">[</span><span class="s1">&#39;IdxChannel&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">ev_chan</span><span class="p">[</span><span class="s1">&#39;Event&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ev_chan</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">peaks</span> <span class="o">=</span> <span class="p">(</span><span class="n">ev_chan</span><span class="p">[</span><span class="n">center</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sf</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
            <span class="c1"># Get centered indices</span>
            <span class="n">idx</span><span class="p">,</span> <span class="n">idx_valid</span> <span class="o">=</span> <span class="n">get_centered_indices</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">peaks</span><span class="p">,</span> <span class="n">bef</span><span class="p">,</span> <span class="n">aft</span><span class="p">)</span>
            <span class="c1"># If no good epochs are returned raise a warning</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx_valid</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="s1">&#39;Time before and/or time after exceed data bounds, please &#39;</span>
                    <span class="s1">&#39;lower the temporal window around center. Skipping channel.&#39;</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="c1"># Get data at indices and time vector</span>
            <span class="n">amps</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">as_dataframe</span><span class="p">:</span>
                <span class="c1"># Output is a list (n_channels) of numpy arrays (n_events, n_times)</span>
                <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">amps</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="c1"># Convert to long-format dataframe</span>
            <span class="n">df_chan</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">amps</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="n">df_chan</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span>
            <span class="c1"># Convert to long-format</span>
            <span class="n">df_chan</span> <span class="o">=</span> <span class="n">df_chan</span><span class="o">.</span><span class="n">melt</span><span class="p">(</span><span class="n">id_vars</span><span class="o">=</span><span class="s1">&#39;Time&#39;</span><span class="p">,</span> <span class="n">var_name</span><span class="o">=</span><span class="s1">&#39;Event&#39;</span><span class="p">,</span> <span class="n">value_name</span><span class="o">=</span><span class="s1">&#39;Amplitude&#39;</span><span class="p">)</span>
            <span class="c1"># Append stage</span>
            <span class="k">if</span> <span class="s1">&#39;Stage&#39;</span> <span class="ow">in</span> <span class="n">masked_events</span><span class="p">:</span>
                <span class="n">df_chan</span> <span class="o">=</span> <span class="n">df_chan</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">ev_chan</span><span class="p">[[</span><span class="s1">&#39;Event&#39;</span><span class="p">,</span> <span class="s1">&#39;Stage&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">idx_valid</span><span class="p">])</span>
            <span class="c1"># Append channel name</span>
            <span class="n">df_chan</span><span class="p">[</span><span class="s1">&#39;Channel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ev_chan</span><span class="p">[</span><span class="s1">&#39;Channel&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">df_chan</span><span class="p">[</span><span class="s1">&#39;IdxChannel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
            <span class="c1"># Append to master dataframe</span>
            <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df_chan</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">as_dataframe</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">output</span>

    <span class="k">def</span> <span class="nf">get_coincidence_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scaled</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;get_coincidence_matrix&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ch_names</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;At least 2 channels are required to calculate coincidence.&quot;</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_mask</span><span class="p">()</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_ch_names</span><span class="p">)</span>
        <span class="n">mask</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Channel&quot;</span>

        <span class="k">def</span> <span class="nf">_coincidence</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Calculate the (scaled) coincidence.&quot;&quot;&quot;</span>
            <span class="n">coincidence</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">scaled</span><span class="p">:</span>
                <span class="c1"># Handle division by zero error</span>
                <span class="n">denom</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">*</span> <span class="n">y</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
                <span class="k">if</span> <span class="n">denom</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">coincidence</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">coincidence</span> <span class="o">/=</span> <span class="n">denom</span>
            <span class="k">return</span> <span class="n">coincidence</span>

        <span class="n">coinc_mat</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">corr</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">_coincidence</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">scaled</span><span class="p">:</span>
            <span class="c1"># Otherwise diagonal values are set to 1</span>
            <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">coinc_mat</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">mask</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
            <span class="n">coinc_mat</span> <span class="o">=</span> <span class="n">coinc_mat</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">coinc_mat</span>

    <span class="k">def</span> <span class="nf">plot_average</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event_type</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="s1">&#39;Peak&#39;</span><span class="p">,</span> <span class="n">hue</span><span class="o">=</span><span class="s1">&#39;Channel&#39;</span><span class="p">,</span> <span class="n">time_before</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                     <span class="n">time_after</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">filt</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot the average event (not for REM, spindles &amp; SW only)&quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

        <span class="n">df_sync</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sync_events</span><span class="p">(</span><span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span> <span class="n">time_before</span><span class="o">=</span><span class="n">time_before</span><span class="p">,</span>
                                       <span class="n">time_after</span><span class="o">=</span><span class="n">time_after</span><span class="p">,</span> <span class="n">filt</span><span class="o">=</span><span class="n">filt</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">df_sync</span><span class="o">.</span><span class="n">empty</span><span class="p">,</span> <span class="s2">&quot;Could not calculate event-locked data.&quot;</span>
        <span class="k">assert</span> <span class="n">hue</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;Stage&#39;</span><span class="p">,</span> <span class="s1">&#39;Channel&#39;</span><span class="p">],</span> <span class="s2">&quot;hue must be &#39;Channel&#39; or &#39;Stage&#39;&quot;</span>
        <span class="k">assert</span> <span class="n">hue</span> <span class="ow">in</span> <span class="n">df_sync</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not present in data.&quot;</span> <span class="o">%</span> <span class="n">hue</span>

        <span class="k">if</span> <span class="n">event_type</span> <span class="o">==</span> <span class="s1">&#39;spindles&#39;</span><span class="p">:</span>
            <span class="n">title</span> <span class="o">=</span> <span class="s2">&quot;Average spindle&quot;</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># &quot;sw&quot;:</span>
            <span class="n">title</span> <span class="o">=</span> <span class="s2">&quot;Average SW&quot;</span>

        <span class="c1"># Start figure</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
        <span class="n">sns</span><span class="o">.</span><span class="n">lineplot</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">df_sync</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="s1">&#39;Time&#39;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s1">&#39;Amplitude&#39;</span><span class="p">,</span> <span class="n">hue</span><span class="o">=</span><span class="n">hue</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># ax.legend(frameon=False, loc=&#39;lower right&#39;)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">df_sync</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">df_sync</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time (sec)&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Amplitude (uV)&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ax</span>

    <span class="k">def</span> <span class="nf">plot_detection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot an overlay of the detected events on the signal.&quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="kn">import</span> <span class="nn">ipywidgets</span> <span class="k">as</span> <span class="nn">ipy</span>

        <span class="c1"># Define mask</span>
        <span class="n">sf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sf</span>
        <span class="n">win_size</span> <span class="o">=</span> <span class="mi">10</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_mask</span><span class="p">()</span>
        <span class="n">highlight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">*</span> <span class="n">mask</span>
        <span class="n">highlight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">highlight</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">highlight</span><span class="p">)</span>
        <span class="n">highlight_filt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_filt</span> <span class="o">*</span> <span class="n">mask</span>
        <span class="n">highlight_filt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">highlight_filt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">highlight_filt</span><span class="p">)</span>

        <span class="n">n_epochs</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">sf</span><span class="p">)</span> <span class="o">/</span> <span class="n">win_size</span><span class="p">)</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">sf</span>

        <span class="c1"># Define xlim and xrange</span>
        <span class="n">xlim</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">win_size</span><span class="p">]</span>
        <span class="n">xrng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">xlim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">sf</span><span class="p">,</span> <span class="p">(</span><span class="n">xlim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">sf</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1"># Plot</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="n">xrng</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">xrng</span><span class="p">],</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="n">xrng</span><span class="p">],</span> <span class="n">highlight</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">xrng</span><span class="p">],</span> <span class="s1">&#39;indianred&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time (seconds)&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Amplitude (uV)&#39;</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">header_visible</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>

        <span class="c1"># WIDGETS</span>
        <span class="n">layout</span> <span class="o">=</span> <span class="n">ipy</span><span class="o">.</span><span class="n">Layout</span><span class="p">(</span>
            <span class="n">width</span><span class="o">=</span><span class="s2">&quot;50%&quot;</span><span class="p">,</span>
            <span class="n">justify_content</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span>
            <span class="n">align_items</span><span class="o">=</span><span class="s1">&#39;center&#39;</span>
        <span class="p">)</span>

        <span class="n">sl_ep</span> <span class="o">=</span> <span class="n">ipy</span><span class="o">.</span><span class="n">IntSlider</span><span class="p">(</span>
            <span class="nb">min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="nb">max</span><span class="o">=</span><span class="n">n_epochs</span><span class="p">,</span>
            <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">layout</span><span class="o">=</span><span class="n">layout</span><span class="p">,</span>
            <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Epoch:&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">sl_amp</span> <span class="o">=</span> <span class="n">ipy</span><span class="o">.</span><span class="n">IntSlider</span><span class="p">(</span>
            <span class="nb">min</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span>
            <span class="nb">max</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span>
            <span class="n">step</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span>
            <span class="n">value</span><span class="o">=</span><span class="mi">150</span><span class="p">,</span>
            <span class="n">layout</span><span class="o">=</span><span class="n">layout</span><span class="p">,</span>
            <span class="n">orientation</span><span class="o">=</span><span class="s1">&#39;horizontal&#39;</span><span class="p">,</span>
            <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Amplitude:&quot;</span>
        <span class="p">)</span>

        <span class="n">dd_ch</span> <span class="o">=</span> <span class="n">ipy</span><span class="o">.</span><span class="n">Dropdown</span><span class="p">(</span>
            <span class="n">options</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_ch_names</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_ch_names</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">description</span><span class="o">=</span><span class="s1">&#39;Channel:&#39;</span>
        <span class="p">)</span>

        <span class="n">dd_win</span> <span class="o">=</span> <span class="n">ipy</span><span class="o">.</span><span class="n">Dropdown</span><span class="p">(</span>
            <span class="n">options</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">60</span><span class="p">],</span>
            <span class="n">value</span><span class="o">=</span><span class="n">win_size</span><span class="p">,</span>
            <span class="n">description</span><span class="o">=</span><span class="s1">&#39;Window size:&#39;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">dd_check</span> <span class="o">=</span> <span class="n">ipy</span><span class="o">.</span><span class="n">Checkbox</span><span class="p">(</span>
            <span class="n">value</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">description</span><span class="o">=</span><span class="s1">&#39;Filtered&#39;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">epoch</span><span class="p">,</span> <span class="n">amplitude</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">win_size</span><span class="p">,</span> <span class="n">filt</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Update plot.&quot;&quot;&quot;</span>
            <span class="n">n_epochs</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">sf</span><span class="p">)</span> <span class="o">/</span> <span class="n">win_size</span><span class="p">)</span>
            <span class="n">sl_ep</span><span class="o">.</span><span class="n">max</span> <span class="o">=</span> <span class="n">n_epochs</span>
            <span class="n">xlim</span> <span class="o">=</span> <span class="p">[</span><span class="n">epoch</span> <span class="o">*</span> <span class="n">win_size</span><span class="p">,</span> <span class="p">(</span><span class="n">epoch</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">win_size</span><span class="p">]</span>
            <span class="n">xrng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">xlim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">sf</span><span class="p">,</span> <span class="p">(</span><span class="n">xlim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">sf</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="c1"># Check if filtered</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">filt</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_filt</span>
            <span class="n">overlay</span> <span class="o">=</span> <span class="n">highlight</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">filt</span> <span class="k">else</span> <span class="n">highlight_filt</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="n">xrng</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="n">dd_ch</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">xrng</span><span class="p">])</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">lines</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="n">xrng</span><span class="p">],</span> <span class="n">overlay</span><span class="p">[</span><span class="n">dd_ch</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">xrng</span><span class="p">])</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">xlim</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="o">-</span><span class="n">amplitude</span><span class="p">,</span> <span class="n">amplitude</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">ipy</span><span class="o">.</span><span class="n">interact</span><span class="p">(</span><span class="n">update</span><span class="p">,</span> <span class="n">epoch</span><span class="o">=</span><span class="n">sl_ep</span><span class="p">,</span> <span class="n">amplitude</span><span class="o">=</span><span class="n">sl_amp</span><span class="p">,</span>
                            <span class="n">channel</span><span class="o">=</span><span class="n">dd_ch</span><span class="p">,</span> <span class="n">win_size</span><span class="o">=</span><span class="n">dd_win</span><span class="p">,</span> <span class="n">filt</span><span class="o">=</span><span class="n">dd_check</span><span class="p">)</span>


<span class="c1">#############################################################################</span>
<span class="c1"># SPINDLES DETECTION</span>
<span class="c1">#############################################################################</span>


<div class="viewcode-block" id="spindles_detect"><a class="viewcode-back" href="../../generated/yasa.spindles_detect.html#yasa.spindles_detect">[docs]</a><span class="k">def</span> <span class="nf">spindles_detect</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ch_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">hypno</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">include</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">freq_sp</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">15</span><span class="p">),</span> <span class="n">freq_broad</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">30</span><span class="p">),</span>
                    <span class="n">duration</span><span class="o">=</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">min_distance</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span>
                    <span class="n">thresh</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;rel_pow&#39;</span><span class="p">:</span> <span class="mf">0.2</span><span class="p">,</span> <span class="s1">&#39;corr&#39;</span><span class="p">:</span> <span class="mf">0.65</span><span class="p">,</span> <span class="s1">&#39;rms&#39;</span><span class="p">:</span> <span class="mf">1.5</span><span class="p">},</span>
                    <span class="n">multi_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">remove_outliers</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Spindles detection.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : array_like</span>
<span class="sd">        Single or multi-channel data. Unit must be uV and shape (n_samples) or</span>
<span class="sd">        (n_chan, n_samples). Can also be a :py:class:`mne.io.BaseRaw`,</span>
<span class="sd">        in which case ``data``, ``sf``, and ``ch_names`` will be automatically</span>
<span class="sd">        extracted, and ``data`` will also be automatically converted from</span>
<span class="sd">        Volts (MNE) to micro-Volts (YASA).</span>
<span class="sd">    sf : float</span>
<span class="sd">        Sampling frequency of the data in Hz.</span>
<span class="sd">        Can be omitted if ``data`` is a :py:class:`mne.io.BaseRaw`.</span>

<span class="sd">        .. tip:: If the detection is taking too long, make sure to downsample</span>
<span class="sd">            your data to 100 Hz (or 128 Hz). For more details, please refer to</span>
<span class="sd">            :py:func:`mne.filter.resample`.</span>
<span class="sd">    ch_names : list of str</span>
<span class="sd">        Channel names. Can be omitted if ``data`` is a</span>
<span class="sd">        :py:class:`mne.io.BaseRaw`.</span>
<span class="sd">    hypno : array_like</span>
<span class="sd">        Sleep stage (hypnogram). If the hypnogram is loaded, the</span>
<span class="sd">        detection will only be applied to the value defined in</span>
<span class="sd">        ``include`` (default = N1 + N2 + N3 sleep).</span>

<span class="sd">        The hypnogram must have the same number of samples as ``data``.</span>
<span class="sd">        To upsample your hypnogram, please refer to</span>
<span class="sd">        :py:func:`yasa.hypno_upsample_to_data`.</span>

<span class="sd">        .. note::</span>
<span class="sd">            The default hypnogram format in YASA is a 1D integer</span>
<span class="sd">            vector where:</span>

<span class="sd">            - -2 = Unscored</span>
<span class="sd">            - -1 = Artefact / Movement</span>
<span class="sd">            - 0 = Wake</span>
<span class="sd">            - 1 = N1 sleep</span>
<span class="sd">            - 2 = N2 sleep</span>
<span class="sd">            - 3 = N3 sleep</span>
<span class="sd">            - 4 = REM sleep</span>
<span class="sd">    include : tuple, list or int</span>
<span class="sd">        Values in ``hypno`` that will be included in the mask. The default is</span>
<span class="sd">        (1, 2, 3), meaning that the detection is applied on N1, N2 and N3</span>
<span class="sd">        sleep. This has no effect when ``hypno`` is None.</span>
<span class="sd">    freq_sp : tuple or list</span>
<span class="sd">        Spindles frequency range. Default is 12 to 15 Hz. Please note that YASA</span>
<span class="sd">        uses a FIR filter (implemented in MNE) with a 1.5Hz transition band,</span>
<span class="sd">        which means that for `freq_sp = (12, 15 Hz)`, the -6 dB points are</span>
<span class="sd">        located at 11.25 and 15.75 Hz.</span>
<span class="sd">    freq_broad : tuple or list</span>
<span class="sd">        Broad band frequency range. Default is 1 to 30 Hz.</span>
<span class="sd">    duration : tuple or list</span>
<span class="sd">        The minimum and maximum duration of the spindles.</span>
<span class="sd">        Default is 0.5 to 2 seconds.</span>
<span class="sd">    min_distance : int</span>
<span class="sd">        If two spindles are closer than ``min_distance`` (in ms), they are</span>
<span class="sd">        merged into a single spindles. Default is 500 ms.</span>
<span class="sd">    thresh : dict</span>
<span class="sd">        Detection thresholds:</span>

<span class="sd">        * ``&#39;rel_pow&#39;``: Relative power (= power ratio freq_sp / freq_broad).</span>
<span class="sd">        * ``&#39;corr&#39;``: Moving correlation between original signal and</span>
<span class="sd">          sigma-filtered signal.</span>
<span class="sd">        * ``&#39;rms&#39;``: Number of standard deviations above the mean of a moving</span>
<span class="sd">          root mean square of sigma-filtered signal.</span>

<span class="sd">        You can disable one or more threshold by putting ``None`` instead:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            thresh = {&#39;rel_pow&#39;: None, &#39;corr&#39;: 0.65, &#39;rms&#39;: 1.5}</span>
<span class="sd">            thresh = {&#39;rel_pow&#39;: None, &#39;corr&#39;: None, &#39;rms&#39;: 3}</span>
<span class="sd">    multi_only : boolean</span>
<span class="sd">        Define the behavior of the multi-channel detection. If True, only</span>
<span class="sd">        spindles that are present on at least two channels are kept. If False,</span>
<span class="sd">        no selection is applied and the output is just a concatenation of the</span>
<span class="sd">        single-channel detection dataframe. Default is False.</span>
<span class="sd">    remove_outliers : boolean</span>
<span class="sd">        If True, YASA will automatically detect and remove outliers spindles</span>
<span class="sd">        using :py:class:`sklearn.ensemble.IsolationForest`.</span>
<span class="sd">        The outliers detection is performed on all the spindles</span>
<span class="sd">        parameters with the exception of the ``Start``, ``Peak``, ``End``,</span>
<span class="sd">        ``Stage``, and ``SOPhase`` columns.</span>
<span class="sd">        YASA uses a random seed (42) to ensure reproducible results.</span>
<span class="sd">        Note that this step will only be applied if there are more than 50</span>
<span class="sd">        detected spindles in the first place. Default to False.</span>
<span class="sd">    verbose : bool or str</span>
<span class="sd">        Verbose level. Default (False) will only print warning and error</span>
<span class="sd">        messages. The logging levels are &#39;debug&#39;, &#39;info&#39;, &#39;warning&#39;, &#39;error&#39;,</span>
<span class="sd">        and &#39;critical&#39;. For most users the choice is between &#39;info&#39;</span>
<span class="sd">        (or ``verbose=True``) and warning (``verbose=False``).</span>

<span class="sd">        .. versionadded:: 0.2.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sp : :py:class:`yasa.SpindlesResults`</span>
<span class="sd">        To get the full detection dataframe, use:</span>

<span class="sd">        &gt;&gt;&gt; sp = spindles_detect(...)</span>
<span class="sd">        &gt;&gt;&gt; sp.summary()</span>

<span class="sd">        This will give a :py:class:`pandas.DataFrame` where each row is a</span>
<span class="sd">        detected spindle and each column is a parameter (= feature or property)</span>
<span class="sd">        of this spindle. To get the average spindles parameters per channel and</span>
<span class="sd">        sleep stage:</span>

<span class="sd">        &gt;&gt;&gt; sp.summary(grp_chan=True, grp_stage=True)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The parameters that are calculated for each spindle are:</span>

<span class="sd">    * ``&#39;Start&#39;``: Start time of the spindle, in seconds from the beginning of</span>
<span class="sd">      data.</span>
<span class="sd">    * ``&#39;Peak&#39;``: Time at the most prominent spindle peak (in seconds).</span>
<span class="sd">    * ``&#39;End&#39;`` : End time (in seconds).</span>
<span class="sd">    * ``&#39;Duration&#39;``: Duration (in seconds)</span>
<span class="sd">    * ``&#39;Amplitude&#39;``: Peak-to-peak amplitude of the (detrended) spindle in</span>
<span class="sd">      the raw data (in V).</span>
<span class="sd">    * ``&#39;RMS&#39;``: Root-mean-square (in V)</span>
<span class="sd">    * ``&#39;AbsPower&#39;``: Median absolute power (in log10 V^2),</span>
<span class="sd">      calculated from the Hilbert-transform of the ``freq_sp`` filtered signal.</span>
<span class="sd">    * ``&#39;RelPower&#39;``: Median relative power of the ``freq_sp`` band in spindle</span>
<span class="sd">      calculated from a short-term fourier transform and expressed as a</span>
<span class="sd">      proportion of the total power in ``freq_broad``.</span>
<span class="sd">    * ``&#39;Frequency&#39;``: Median instantaneous frequency of spindle (in Hz),</span>
<span class="sd">      derived from an Hilbert transform of the ``freq_sp`` filtered signal.</span>
<span class="sd">    * ``&#39;Oscillations&#39;``: Number of oscillations (= number of positive peaks</span>
<span class="sd">      in spindle.)</span>
<span class="sd">    * ``&#39;Symmetry&#39;``: Location of the most prominent peak of spindle,</span>
<span class="sd">      normalized from 0 (start) to 1 (end). Ideally this value should be close</span>
<span class="sd">      to 0.5, indicating that the most prominent peak is halfway through the</span>
<span class="sd">      spindle.</span>
<span class="sd">    * ``&#39;Stage&#39;`` : Sleep stage during which spindle occured, if ``hypno``</span>
<span class="sd">      was provided.</span>

<span class="sd">      All parameters are calculated from the broadband-filtered EEG</span>
<span class="sd">      (frequency range defined in ``freq_broad``).</span>

<span class="sd">    For better results, apply this detection only on artefact-free NREM sleep.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    The sleep spindles detection algorithm is based on:</span>

<span class="sd">    * Lacourse, K., Delfrate, J., Beaudry, J., Peppard, P., &amp; Warby, S. C.</span>
<span class="sd">      (2018). `A sleep spindle detection algorithm that emulates human expert</span>
<span class="sd">      spindle scoring. &lt;https://doi.org/10.1016/j.jneumeth.2018.08.014&gt;`_</span>
<span class="sd">      Journal of Neuroscience Methods.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    For a walkthrough of the spindles detection, please refer to the following</span>
<span class="sd">    Jupyter notebooks:</span>

<span class="sd">    https://github.com/raphaelvallat/yasa/blob/master/notebooks/01_spindles_detection.ipynb</span>

<span class="sd">    https://github.com/raphaelvallat/yasa/blob/master/notebooks/02_spindles_detection_multi.ipynb</span>

<span class="sd">    https://github.com/raphaelvallat/yasa/blob/master/notebooks/03_spindles_detection_NREM_only.ipynb</span>

<span class="sd">    https://github.com/raphaelvallat/yasa/blob/master/notebooks/04_spindles_slow_fast.ipynb</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">set_log_level</span><span class="p">(</span><span class="n">verbose</span><span class="p">)</span>

    <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">ch_names</span><span class="p">,</span> <span class="n">hypno</span><span class="p">,</span> <span class="n">include</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">n_chan</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">,</span> <span class="n">bad_chan</span>
     <span class="p">)</span> <span class="o">=</span> <span class="n">_check_data_hypno</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">ch_names</span><span class="p">,</span> <span class="n">hypno</span><span class="p">,</span> <span class="n">include</span><span class="p">)</span>

    <span class="c1"># If all channels are bad</span>
    <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">bad_chan</span><span class="p">)</span> <span class="o">==</span> <span class="n">n_chan</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;All channels have bad amplitude. Returning None.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Check detection thresholds</span>
    <span class="k">if</span> <span class="s1">&#39;rel_pow&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">thresh</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">thresh</span><span class="p">[</span><span class="s1">&#39;rel_pow&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.20</span>
    <span class="k">if</span> <span class="s1">&#39;corr&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">thresh</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">thresh</span><span class="p">[</span><span class="s1">&#39;corr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.65</span>
    <span class="k">if</span> <span class="s1">&#39;rms&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">thresh</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">thresh</span><span class="p">[</span><span class="s1">&#39;rms&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.5</span>
    <span class="n">do_rel_pow</span> <span class="o">=</span> <span class="n">thresh</span><span class="p">[</span><span class="s1">&#39;rel_pow&#39;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="s2">&quot;None&quot;</span><span class="p">]</span>
    <span class="n">do_corr</span> <span class="o">=</span> <span class="n">thresh</span><span class="p">[</span><span class="s1">&#39;corr&#39;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="s2">&quot;None&quot;</span><span class="p">]</span>
    <span class="n">do_rms</span> <span class="o">=</span> <span class="n">thresh</span><span class="p">[</span><span class="s1">&#39;rms&#39;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="s2">&quot;None&quot;</span><span class="p">]</span>
    <span class="n">n_thresh</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">do_rel_pow</span><span class="p">,</span> <span class="n">do_corr</span><span class="p">,</span> <span class="n">do_rms</span><span class="p">])</span>
    <span class="k">assert</span> <span class="n">n_thresh</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;At least one threshold must be defined.&#39;</span>

    <span class="c1"># Filtering</span>
    <span class="n">nfast</span> <span class="o">=</span> <span class="n">next_fast_len</span><span class="p">(</span><span class="n">n_samples</span><span class="p">)</span>
    <span class="c1"># 1) Broadband bandpass filter (optional -- careful of lower freq for PAC)</span>
    <span class="n">data_broad</span> <span class="o">=</span> <span class="n">filter_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">freq_broad</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">freq_broad</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;fir&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># 2) Sigma bandpass filter</span>
    <span class="c1"># The width of the transition band is set to 1.5 Hz on each side,</span>
    <span class="c1"># meaning that for freq_sp = (12, 15 Hz), the -6 dB points are located at</span>
    <span class="c1"># 11.25 and 15.75 Hz.</span>
    <span class="n">data_sigma</span> <span class="o">=</span> <span class="n">filter_data</span><span class="p">(</span>
        <span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">freq_sp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">freq_sp</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">l_trans_bandwidth</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">h_trans_bandwidth</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="s1">&#39;fir&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Hilbert power (to define the instantaneous frequency / power)</span>
    <span class="n">analytic</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">hilbert</span><span class="p">(</span><span class="n">data_sigma</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="n">nfast</span><span class="p">)[:,</span> <span class="p">:</span><span class="n">n_samples</span><span class="p">]</span>
    <span class="n">inst_phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">analytic</span><span class="p">)</span>
    <span class="n">inst_pow</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">analytic</span><span class="p">))</span>
    <span class="n">inst_freq</span> <span class="o">=</span> <span class="p">(</span><span class="n">sf</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">inst_phase</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>

    <span class="c1"># Extract the SO signal for coupling</span>
    <span class="c1"># if coupling:</span>
    <span class="c1">#     # We need to use the original (non-filtered data)</span>
    <span class="c1">#     data_so = filter_data(data, sf, freq_so[0], freq_so[1], method=&#39;fir&#39;,</span>
    <span class="c1">#                           l_trans_bandwidth=0.1, h_trans_bandwidth=0.1,</span>
    <span class="c1">#                           verbose=0)</span>
    <span class="c1">#     # Now extract the instantaneous phase using Hilbert transform</span>
    <span class="c1">#     so_phase = np.angle(signal.hilbert(data_so, N=nfast)[:, :n_samples])</span>

    <span class="c1"># Initialize empty output dataframe</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_chan</span><span class="p">):</span>

        <span class="c1"># ####################################################################</span>
        <span class="c1"># START SINGLE CHANNEL DETECTION</span>
        <span class="c1"># ####################################################################</span>

        <span class="c1"># First, skip channels with bad data amplitude</span>
        <span class="k">if</span> <span class="n">bad_chan</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="k">continue</span>

        <span class="c1"># Compute the pointwise relative power using interpolated STFT</span>
        <span class="c1"># Here we use a step of 200 ms to speed up the computation.</span>
        <span class="c1"># Note that even if the threshold is None we still need to calculate it</span>
        <span class="c1"># for the individual spindles parameter (RelPow).</span>
        <span class="n">f</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">Sxx</span> <span class="o">=</span> <span class="n">stft_power</span><span class="p">(</span>
            <span class="n">data_broad</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">sf</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">step</span><span class="o">=.</span><span class="mi">2</span><span class="p">,</span> <span class="n">band</span><span class="o">=</span><span class="n">freq_broad</span><span class="p">,</span> <span class="n">interp</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">idx_sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">f</span> <span class="o">&gt;=</span> <span class="n">freq_sp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span> <span class="o">&lt;=</span> <span class="n">freq_sp</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">rel_pow</span> <span class="o">=</span> <span class="n">Sxx</span><span class="p">[</span><span class="n">idx_sigma</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Let&#39;s interpolate `rel_pow` to get one value per sample</span>
        <span class="c1"># Note that we could also have use the `interp=True` in the</span>
        <span class="c1"># `stft_power` function, however 2D interpolation is much slower than</span>
        <span class="c1"># 1D interpolation.</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">rel_pow</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;cubic&#39;</span><span class="p">,</span> <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_samples</span><span class="p">)</span> <span class="o">/</span> <span class="n">sf</span>
        <span class="n">rel_pow</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">do_corr</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">mcorr</span> <span class="o">=</span> <span class="n">moving_transform</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">data_sigma</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">y</span><span class="o">=</span><span class="n">data_broad</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">sf</span><span class="o">=</span><span class="n">sf</span><span class="p">,</span> <span class="n">window</span><span class="o">=.</span><span class="mi">3</span><span class="p">,</span>
                                        <span class="n">step</span><span class="o">=.</span><span class="mi">1</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;corr&#39;</span><span class="p">,</span> <span class="n">interp</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">do_rms</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">mrms</span> <span class="o">=</span> <span class="n">moving_transform</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">data_sigma</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">sf</span><span class="o">=</span><span class="n">sf</span><span class="p">,</span> <span class="n">window</span><span class="o">=.</span><span class="mi">3</span><span class="p">,</span> <span class="n">step</span><span class="o">=.</span><span class="mi">1</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;rms&#39;</span><span class="p">,</span>
                                       <span class="n">interp</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># Let&#39;s define the thresholds</span>
            <span class="k">if</span> <span class="n">hypno</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">thresh_rms</span> <span class="o">=</span> <span class="n">mrms</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="o">+</span> <span class="n">thresh</span><span class="p">[</span><span class="s1">&#39;rms&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">trimbothstd</span><span class="p">(</span><span class="n">mrms</span><span class="p">,</span> <span class="n">cut</span><span class="o">=</span><span class="mf">0.10</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">thresh_rms</span> <span class="o">=</span> <span class="n">mrms</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="o">+</span> <span class="n">thresh</span><span class="p">[</span><span class="s1">&#39;rms&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">trimbothstd</span><span class="p">(</span><span class="n">mrms</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="n">cut</span><span class="o">=</span><span class="mf">0.10</span><span class="p">)</span>
            <span class="c1"># Avoid too high threshold caused by Artefacts / Motion during Wake</span>
            <span class="n">thresh_rms</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">thresh_rms</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Moving RMS threshold = </span><span class="si">%.3f</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">thresh_rms</span><span class="p">)</span>

        <span class="c1"># Boolean vector of supra-threshold indices</span>
        <span class="n">idx_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_samples</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">do_rel_pow</span><span class="p">:</span>
            <span class="n">idx_rel_pow</span> <span class="o">=</span> <span class="p">(</span><span class="n">rel_pow</span> <span class="o">&gt;=</span> <span class="n">thresh</span><span class="p">[</span><span class="s1">&#39;rel_pow&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">idx_sum</span> <span class="o">+=</span> <span class="n">idx_rel_pow</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;N supra-theshold relative power = </span><span class="si">%i</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">idx_rel_pow</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">do_corr</span><span class="p">:</span>
            <span class="n">idx_mcorr</span> <span class="o">=</span> <span class="p">(</span><span class="n">mcorr</span> <span class="o">&gt;=</span> <span class="n">thresh</span><span class="p">[</span><span class="s1">&#39;corr&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">idx_sum</span> <span class="o">+=</span> <span class="n">idx_mcorr</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;N supra-theshold moving corr = </span><span class="si">%i</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">idx_mcorr</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">do_rms</span><span class="p">:</span>
            <span class="n">idx_mrms</span> <span class="o">=</span> <span class="p">(</span><span class="n">mrms</span> <span class="o">&gt;=</span> <span class="n">thresh_rms</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">idx_sum</span> <span class="o">+=</span> <span class="n">idx_mrms</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;N supra-theshold moving RMS = </span><span class="si">%i</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">idx_mrms</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>

        <span class="c1"># Make sure that we do not detect spindles outside mask</span>
        <span class="k">if</span> <span class="n">hypno</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">idx_sum</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># The detection using the three thresholds tends to underestimate the</span>
        <span class="c1"># real duration of the spindle. To overcome this, we compute a soft</span>
        <span class="c1"># threshold by smoothing the idx_sum vector with a 100 ms window.</span>
        <span class="n">w</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.1</span> <span class="o">*</span> <span class="n">sf</span><span class="p">)</span>
        <span class="n">idx_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">idx_sum</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">/</span> <span class="n">w</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">)</span>
        <span class="c1"># And we then find indices that are strictly greater than 2, i.e. we</span>
        <span class="c1"># find the &#39;true&#39; beginning and &#39;true&#39; end of the events by finding</span>
        <span class="c1"># where at least two out of the three treshold were crossed.</span>
        <span class="n">where_sp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">idx_sum</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">n_thresh</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># If no events are found, skip to next channel</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">where_sp</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;No spindle were found in channel </span><span class="si">%s</span><span class="s1">.&#39;</span><span class="p">,</span> <span class="n">ch_names</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">continue</span>

        <span class="c1"># Merge events that are too close</span>
        <span class="k">if</span> <span class="n">min_distance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">min_distance</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">where_sp</span> <span class="o">=</span> <span class="n">_merge_close</span><span class="p">(</span><span class="n">where_sp</span><span class="p">,</span> <span class="n">min_distance</span><span class="p">,</span> <span class="n">sf</span><span class="p">)</span>

        <span class="c1"># Extract start, end, and duration of each spindle</span>
        <span class="n">sp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">where_sp</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">where_sp</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">idx_start_end</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">k</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sp</span><span class="p">])</span> <span class="o">/</span> <span class="n">sf</span>
        <span class="n">sp_start</span><span class="p">,</span> <span class="n">sp_end</span> <span class="o">=</span> <span class="n">idx_start_end</span><span class="o">.</span><span class="n">T</span>
        <span class="n">sp_dur</span> <span class="o">=</span> <span class="n">sp_end</span> <span class="o">-</span> <span class="n">sp_start</span>

        <span class="c1"># Find events with bad duration</span>
        <span class="n">good_dur</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">sp_dur</span> <span class="o">&gt;</span> <span class="n">duration</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sp_dur</span> <span class="o">&lt;</span> <span class="n">duration</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># If no events of good duration are found, skip to next channel</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="o">~</span><span class="n">good_dur</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;No spindle were found in channel </span><span class="si">%s</span><span class="s1">.&#39;</span><span class="p">,</span> <span class="n">ch_names</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">continue</span>

        <span class="c1"># Initialize empty variables</span>
        <span class="n">sp_amp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sp</span><span class="p">))</span>
        <span class="n">sp_freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sp</span><span class="p">))</span>
        <span class="n">sp_rms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sp</span><span class="p">))</span>
        <span class="n">sp_osc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sp</span><span class="p">))</span>
        <span class="n">sp_sym</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sp</span><span class="p">))</span>
        <span class="n">sp_abs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sp</span><span class="p">))</span>
        <span class="n">sp_rel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sp</span><span class="p">))</span>
        <span class="n">sp_sta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sp</span><span class="p">))</span>
        <span class="n">sp_pro</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sp</span><span class="p">))</span>
        <span class="c1"># sp_cou = np.zeros(len(sp))</span>

        <span class="c1"># Number of oscillations (number of peaks separated by at least 60 ms)</span>
        <span class="c1"># --&gt; 60 ms because 1000 ms / 16 Hz = 62.5 m, in other words, at 16 Hz,</span>
        <span class="c1"># peaks are separated by 62.5 ms. At 11 Hz peaks are separated by 90 ms</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="mi">60</span> <span class="o">*</span> <span class="n">sf</span> <span class="o">/</span> <span class="mi">1000</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sp</span><span class="p">))[</span><span class="n">good_dur</span><span class="p">]:</span>
            <span class="c1"># Important: detrend the signal to avoid wrong PTP amplitude</span>
            <span class="n">sp_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">data_broad</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">sp</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">sp_det</span> <span class="o">=</span> <span class="n">_detrend</span><span class="p">(</span><span class="n">sp_x</span><span class="p">,</span> <span class="n">data_broad</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">sp</span><span class="p">[</span><span class="n">j</span><span class="p">]])</span>
            <span class="c1"># sp_det = signal.detrend(data_broad[i, sp[i]], type=&#39;linear&#39;)</span>
            <span class="n">sp_amp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="n">sp_det</span><span class="p">)</span>  <span class="c1"># Peak-to-peak amplitude</span>
            <span class="n">sp_rms</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">_rms</span><span class="p">(</span><span class="n">sp_det</span><span class="p">)</span>  <span class="c1"># Root mean square</span>
            <span class="n">sp_rel</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">rel_pow</span><span class="p">[</span><span class="n">sp</span><span class="p">[</span><span class="n">j</span><span class="p">]])</span>  <span class="c1"># Median relative power</span>

            <span class="c1"># Hilbert-based instantaneous properties</span>
            <span class="n">sp_inst_freq</span> <span class="o">=</span> <span class="n">inst_freq</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">sp</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>
            <span class="n">sp_inst_pow</span> <span class="o">=</span> <span class="n">inst_pow</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">sp</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>
            <span class="n">sp_abs</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">sp_inst_pow</span><span class="p">[</span><span class="n">sp_inst_pow</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]))</span>
            <span class="n">sp_freq</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">sp_inst_freq</span><span class="p">[</span><span class="n">sp_inst_freq</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span>

            <span class="c1"># Number of oscillations</span>
            <span class="n">peaks</span><span class="p">,</span> <span class="n">peaks_params</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">find_peaks</span><span class="p">(</span>
                <span class="n">sp_det</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="n">distance</span><span class="p">,</span> <span class="n">prominence</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
            <span class="n">sp_osc</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">peaks</span><span class="p">)</span>

            <span class="c1"># For frequency and amplitude, we can also optionally use these</span>
            <span class="c1"># faster alternatives. If we use them, we do not need to compute</span>
            <span class="c1"># the Hilbert transform of the filtered signal.</span>
            <span class="c1"># sp_freq[j] = sf / np.mean(np.diff(peaks))</span>
            <span class="c1"># sp_amp[j] = peaks_params[&#39;prominences&#39;].max()</span>

            <span class="c1"># Peak location &amp; symmetry index</span>
            <span class="c1"># pk is expressed in sample since the beginning of the spindle</span>
            <span class="n">pk</span> <span class="o">=</span> <span class="n">peaks</span><span class="p">[</span><span class="n">peaks_params</span><span class="p">[</span><span class="s1">&#39;prominences&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">argmax</span><span class="p">()]</span>
            <span class="n">sp_pro</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">sp_start</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">pk</span> <span class="o">/</span> <span class="n">sf</span>
            <span class="n">sp_sym</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">pk</span> <span class="o">/</span> <span class="n">sp_det</span><span class="o">.</span><span class="n">size</span>

            <span class="c1"># SO-spindles coupling</span>
            <span class="c1"># if coupling:</span>
            <span class="c1">#     sp_cou[j] = so_phase[i, sp[j]][pk]</span>

            <span class="c1"># Sleep stage</span>
            <span class="k">if</span> <span class="n">hypno</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">sp_sta</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">hypno</span><span class="p">[</span><span class="n">sp</span><span class="p">[</span><span class="n">j</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Create a dataframe</span>
        <span class="n">sp_params</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Start&#39;</span><span class="p">:</span> <span class="n">sp_start</span><span class="p">,</span>
                     <span class="s1">&#39;Peak&#39;</span><span class="p">:</span> <span class="n">sp_pro</span><span class="p">,</span>
                     <span class="s1">&#39;End&#39;</span><span class="p">:</span> <span class="n">sp_end</span><span class="p">,</span>
                     <span class="s1">&#39;Duration&#39;</span><span class="p">:</span> <span class="n">sp_dur</span><span class="p">,</span>
                     <span class="s1">&#39;Amplitude&#39;</span><span class="p">:</span> <span class="n">sp_amp</span><span class="p">,</span>
                     <span class="s1">&#39;RMS&#39;</span><span class="p">:</span> <span class="n">sp_rms</span><span class="p">,</span>
                     <span class="s1">&#39;AbsPower&#39;</span><span class="p">:</span> <span class="n">sp_abs</span><span class="p">,</span>
                     <span class="s1">&#39;RelPower&#39;</span><span class="p">:</span> <span class="n">sp_rel</span><span class="p">,</span>
                     <span class="s1">&#39;Frequency&#39;</span><span class="p">:</span> <span class="n">sp_freq</span><span class="p">,</span>
                     <span class="s1">&#39;Oscillations&#39;</span><span class="p">:</span> <span class="n">sp_osc</span><span class="p">,</span>
                     <span class="s1">&#39;Symmetry&#39;</span><span class="p">:</span> <span class="n">sp_sym</span><span class="p">,</span>
                     <span class="c1"># &#39;SOPhase&#39;: sp_cou,</span>
                     <span class="s1">&#39;Stage&#39;</span><span class="p">:</span> <span class="n">sp_sta</span><span class="p">}</span>

        <span class="n">df_chan</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">sp_params</span><span class="p">)[</span><span class="n">good_dur</span><span class="p">]</span>

        <span class="c1"># We need at least 50 detected spindles to apply the Isolation Forest.</span>
        <span class="k">if</span> <span class="n">remove_outliers</span> <span class="ow">and</span> <span class="n">df_chan</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">50</span><span class="p">:</span>
            <span class="n">col_keep</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Duration&#39;</span><span class="p">,</span> <span class="s1">&#39;Amplitude&#39;</span><span class="p">,</span> <span class="s1">&#39;RMS&#39;</span><span class="p">,</span> <span class="s1">&#39;AbsPower&#39;</span><span class="p">,</span> <span class="s1">&#39;RelPower&#39;</span><span class="p">,</span>
                        <span class="s1">&#39;Frequency&#39;</span><span class="p">,</span> <span class="s1">&#39;Oscillations&#39;</span><span class="p">,</span> <span class="s1">&#39;Symmetry&#39;</span><span class="p">]</span>
            <span class="n">ilf</span> <span class="o">=</span> <span class="n">IsolationForest</span><span class="p">(</span>
                <span class="n">contamination</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">max_samples</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
            <span class="n">good</span> <span class="o">=</span> <span class="n">ilf</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">df_chan</span><span class="p">[</span><span class="n">col_keep</span><span class="p">])</span>
            <span class="n">good</span><span class="p">[</span><span class="n">good</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%i</span><span class="s1"> outliers were removed in channel </span><span class="si">%s</span><span class="s1">.&#39;</span>
                        <span class="o">%</span> <span class="p">((</span><span class="n">good</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="n">ch_names</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="c1"># Remove outliers from DataFrame</span>
            <span class="n">df_chan</span> <span class="o">=</span> <span class="n">df_chan</span><span class="p">[</span><span class="n">good</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)]</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%i</span><span class="s1"> spindles were found in channel </span><span class="si">%s</span><span class="s1">.&#39;</span>
                        <span class="o">%</span> <span class="p">(</span><span class="n">df_chan</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ch_names</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

        <span class="c1"># ####################################################################</span>
        <span class="c1"># END SINGLE CHANNEL DETECTION</span>
        <span class="c1"># ####################################################################</span>
        <span class="n">df_chan</span><span class="p">[</span><span class="s1">&#39;Channel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ch_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">df_chan</span><span class="p">[</span><span class="s1">&#39;IdxChannel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df_chan</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># If no spindles were detected, return None</span>
    <span class="k">if</span> <span class="n">df</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;No spindles were found in data. Returning None.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Remove useless columns</span>
    <span class="n">to_drop</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">hypno</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">to_drop</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;Stage&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;Stage&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;Stage&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="c1"># if not coupling:</span>
    <span class="c1">#     to_drop.append(&#39;SOPhase&#39;)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_drop</span><span class="p">):</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">to_drop</span><span class="p">)</span>

    <span class="c1"># Find spindles that are present on at least two channels</span>
    <span class="k">if</span> <span class="n">multi_only</span> <span class="ow">and</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;Channel&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">nunique</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># We round to the nearest second</span>
        <span class="n">idx_good</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span>
            <span class="n">df</span><span class="p">[</span><span class="s1">&#39;Start&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">duplicated</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
            <span class="n">df</span><span class="p">[</span><span class="s1">&#39;End&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">duplicated</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">idx_good</span><span class="p">]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">SpindlesResults</span><span class="p">(</span><span class="n">events</span><span class="o">=</span><span class="n">df</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="o">=</span><span class="n">sf</span><span class="p">,</span> <span class="n">ch_names</span><span class="o">=</span><span class="n">ch_names</span><span class="p">,</span>
                           <span class="n">hypno</span><span class="o">=</span><span class="n">hypno</span><span class="p">,</span> <span class="n">data_filt</span><span class="o">=</span><span class="n">data_sigma</span><span class="p">)</span></div>


<div class="viewcode-block" id="SpindlesResults"><a class="viewcode-back" href="../../generated/yasa.SpindlesResults.html#yasa.SpindlesResults">[docs]</a><span class="k">class</span> <span class="nc">SpindlesResults</span><span class="p">(</span><span class="n">_DetectionResults</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Output class for spindles detection.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    _events : :py:class:`pandas.DataFrame`</span>
<span class="sd">        Output detection dataframe</span>
<span class="sd">    _data : array_like</span>
<span class="sd">        Original EEG data of shape *(n_chan, n_samples)*.</span>
<span class="sd">    _data_filt : array_like</span>
<span class="sd">        Sigma-filtered EEG data of shape *(n_chan, n_samples)*.</span>
<span class="sd">    _sf : float</span>
<span class="sd">        Sampling frequency of data.</span>
<span class="sd">    _ch_names : list</span>
<span class="sd">        Channel names.</span>
<span class="sd">    _hypno : array_like or None</span>
<span class="sd">        Sleep staging vector.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="SpindlesResults.__init__"><a class="viewcode-back" href="../../generated/yasa.SpindlesResults.html#yasa.SpindlesResults.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">ch_names</span><span class="p">,</span> <span class="n">hypno</span><span class="p">,</span> <span class="n">data_filt</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">events</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">ch_names</span><span class="p">,</span> <span class="n">hypno</span><span class="p">,</span> <span class="n">data_filt</span><span class="p">)</span></div>

<div class="viewcode-block" id="SpindlesResults.summary"><a class="viewcode-back" href="../../generated/yasa.SpindlesResults.html#yasa.SpindlesResults.summary">[docs]</a>    <span class="k">def</span> <span class="nf">summary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grp_chan</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">grp_stage</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">aggfunc</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a summary of the spindles detection, optionally grouped</span>
<span class="sd">        across channels and/or stage.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        grp_chan : bool</span>
<span class="sd">            If True, group by channel (for multi-channels detection only).</span>
<span class="sd">        grp_stage : bool</span>
<span class="sd">            If True, group by sleep stage (provided that an hypnogram was</span>
<span class="sd">            used).</span>
<span class="sd">        mask : array_like or None</span>
<span class="sd">            Custom boolean mask. Only the detected events for which mask is True will be</span>
<span class="sd">            included in the summary dataframe. Default is None, i.e. no masking</span>
<span class="sd">            (all events are included).</span>
<span class="sd">        aggfunc : str or function</span>
<span class="sd">            Averaging function (e.g. ``&#39;mean&#39;`` or ``&#39;median&#39;``).</span>
<span class="sd">        sort : bool</span>
<span class="sd">            If True, sort group keys when grouping.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">summary</span><span class="p">(</span><span class="n">event_type</span><span class="o">=</span><span class="s1">&#39;spindles&#39;</span><span class="p">,</span> <span class="n">grp_chan</span><span class="o">=</span><span class="n">grp_chan</span><span class="p">,</span> <span class="n">grp_stage</span><span class="o">=</span><span class="n">grp_stage</span><span class="p">,</span>
                               <span class="n">aggfunc</span><span class="o">=</span><span class="n">aggfunc</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="n">sort</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span></div>

<div class="viewcode-block" id="SpindlesResults.get_coincidence_matrix"><a class="viewcode-back" href="../../generated/yasa.SpindlesResults.html#yasa.SpindlesResults.get_coincidence_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">get_coincidence_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scaled</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the (scaled) coincidence matrix.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scaled : bool</span>
<span class="sd">            If True (default), the coincidence matrix is scaled (see Notes).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        coincidence : pd.DataFrame</span>
<span class="sd">            A symmetric matrix with the (scaled) coincidence values.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Do spindles occur at the same time? One way to measure this is to</span>
<span class="sd">        calculate the coincidence matrix, which gives, for each pair of</span>
<span class="sd">        channel, the number of samples that were marked as a spindle in both</span>
<span class="sd">        channels. The output is a symmetric matrix, in which the diagonal is</span>
<span class="sd">        simply the number of data points that were marked as a spindle in the</span>
<span class="sd">        channel.</span>

<span class="sd">        The coincidence matrix can be scaled (default) by dividing the output</span>
<span class="sd">        by the product of the sum of each individual binary mask, as shown in</span>
<span class="sd">        the example below. It can then be used to define functional</span>
<span class="sd">        networks or quickly find outlier channels.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Calculate the coincidence of two binary mask:</span>

<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; x = np.array([0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1])</span>
<span class="sd">        &gt;&gt;&gt; y = np.array([0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1])</span>
<span class="sd">        &gt;&gt;&gt; x * y</span>
<span class="sd">        array([0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1])</span>

<span class="sd">        &gt;&gt;&gt; (x * y).sum()  # Unscaled coincidence</span>
<span class="sd">        3</span>

<span class="sd">        &gt;&gt;&gt; (x * y).sum() / (x.sum() * y.sum())  # Scaled coincidence</span>
<span class="sd">        0.12</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        - https://github.com/Mark-Kramer/Sleep-Networks-2021</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_coincidence_matrix</span><span class="p">(</span><span class="n">scaled</span><span class="o">=</span><span class="n">scaled</span><span class="p">)</span></div>

<div class="viewcode-block" id="SpindlesResults.get_mask"><a class="viewcode-back" href="../../generated/yasa.SpindlesResults.html#yasa.SpindlesResults.get_mask">[docs]</a>    <span class="k">def</span> <span class="nf">get_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a boolean array indicating for each sample in data if this</span>
<span class="sd">        sample is part of a detected event (True) or not (False).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_mask</span><span class="p">()</span></div>

<div class="viewcode-block" id="SpindlesResults.get_sync_events"><a class="viewcode-back" href="../../generated/yasa.SpindlesResults.html#yasa.SpindlesResults.get_sync_events">[docs]</a>    <span class="k">def</span> <span class="nf">get_sync_events</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="s1">&#39;Peak&#39;</span><span class="p">,</span> <span class="n">time_before</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">time_after</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">filt</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                        <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">as_dataframe</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the raw or filtered data of each detected event after</span>
<span class="sd">        centering to a specific timepoint.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        center : str</span>
<span class="sd">            Landmark of the event to synchronize the timing on.</span>
<span class="sd">            Default is to use the center peak of the spindles.</span>
<span class="sd">        time_before : float</span>
<span class="sd">            Time (in seconds) before ``center``.</span>
<span class="sd">        time_after : float</span>
<span class="sd">            Time (in seconds) after ``center``.</span>
<span class="sd">        filt : tuple</span>
<span class="sd">            Optional filtering to apply to data. For instance, ``filt=(1, 30)``</span>
<span class="sd">            will apply a 1 to 30 Hz bandpass filter, and ``filt=(None, 40)``</span>
<span class="sd">            will apply a 40 Hz lowpass filter. Filtering is done using default</span>
<span class="sd">            parameters in the :py:func:`mne.filter.filter_data` function.</span>
<span class="sd">        mask : array_like or None</span>
<span class="sd">            Custom boolean mask. Only the detected events for which mask is True will be</span>
<span class="sd">            included. Default is None, i.e. no masking (all events are included).</span>
<span class="sd">        as_dataframe : boolean</span>
<span class="sd">            If True (default), returns a long-format pandas dataframe. If False, returns a list of</span>
<span class="sd">            numpy arrays. Each element of the list a unique channel, and the shape of the numpy</span>
<span class="sd">            arrays within the list is (n_events, n_times).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        df_sync : :py:class:`pandas.DataFrame`</span>
<span class="sd">            Ouput long-format dataframe (if ``as_dataframe=True``)::</span>

<span class="sd">            &#39;Event&#39; : Event number</span>
<span class="sd">            &#39;Time&#39; : Timing of the events (in seconds)</span>
<span class="sd">            &#39;Amplitude&#39; : Raw or filtered data for event</span>
<span class="sd">            &#39;Channel&#39; : Channel</span>
<span class="sd">            &#39;IdxChannel&#39; : Index of channel in data</span>
<span class="sd">            &#39;Stage&#39;: Sleep stage in which the events occured (if available)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_sync_events</span><span class="p">(</span><span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span> <span class="n">time_before</span><span class="o">=</span><span class="n">time_before</span><span class="p">,</span>
                                       <span class="n">time_after</span><span class="o">=</span><span class="n">time_after</span><span class="p">,</span> <span class="n">filt</span><span class="o">=</span><span class="n">filt</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span>
                                       <span class="n">as_dataframe</span><span class="o">=</span><span class="n">as_dataframe</span><span class="p">)</span></div>

<div class="viewcode-block" id="SpindlesResults.plot_average"><a class="viewcode-back" href="../../generated/yasa.SpindlesResults.html#yasa.SpindlesResults.plot_average">[docs]</a>    <span class="k">def</span> <span class="nf">plot_average</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="s1">&#39;Peak&#39;</span><span class="p">,</span> <span class="n">hue</span><span class="o">=</span><span class="s1">&#39;Channel&#39;</span><span class="p">,</span> <span class="n">time_before</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                     <span class="n">time_after</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">filt</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the average spindle.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        center : str</span>
<span class="sd">            Landmark of the event to synchronize the timing on.</span>
<span class="sd">            Default is to use the most prominent peak of the spindle.</span>
<span class="sd">        hue : str</span>
<span class="sd">            Grouping variable that will produce lines with different colors.</span>
<span class="sd">            Can be either &#39;Channel&#39; or &#39;Stage&#39;.</span>
<span class="sd">        time_before : float</span>
<span class="sd">            Time (in seconds) before ``center``.</span>
<span class="sd">        time_after : float</span>
<span class="sd">            Time (in seconds) after ``center``.</span>
<span class="sd">        filt : tuple</span>
<span class="sd">            Optional filtering to apply to data. For instance, ``filt=(12, 16)``</span>
<span class="sd">            will apply a 12 to 16 Hz bandpass filter, and ``filt=(None, 40)``</span>
<span class="sd">            will apply a 40 Hz lowpass filter. Filtering is done using the default</span>
<span class="sd">            parameters in the :py:func:`mne.filter.filter_data` function.</span>
<span class="sd">        mask : array_like or None</span>
<span class="sd">            Custom boolean mask. Only the detected events for which mask is True will be</span>
<span class="sd">            plotted. Default is None, i.e. no masking (all events are included).</span>
<span class="sd">        figsize : tuple</span>
<span class="sd">            Figure size in inches.</span>
<span class="sd">        **kwargs : dict</span>
<span class="sd">            Optional argument that are passed to :py:func:`seaborn.lineplot`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">plot_average</span><span class="p">(</span><span class="n">event_type</span><span class="o">=</span><span class="s1">&#39;spindles&#39;</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
                                    <span class="n">hue</span><span class="o">=</span><span class="n">hue</span><span class="p">,</span> <span class="n">time_before</span><span class="o">=</span><span class="n">time_before</span><span class="p">,</span>
                                    <span class="n">time_after</span><span class="o">=</span><span class="n">time_after</span><span class="p">,</span> <span class="n">filt</span><span class="o">=</span><span class="n">filt</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span>
                                    <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="SpindlesResults.plot_detection"><a class="viewcode-back" href="../../generated/yasa.SpindlesResults.html#yasa.SpindlesResults.plot_detection">[docs]</a>    <span class="k">def</span> <span class="nf">plot_detection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot an overlay of the detected spindles on the EEG signal.</span>

<span class="sd">        This only works in Jupyter and it requires the ipywidgets</span>
<span class="sd">        (https://ipywidgets.readthedocs.io/en/latest/) package.</span>

<span class="sd">        To activate the interactive mode, make sure to run:</span>

<span class="sd">        &gt;&gt;&gt; %matplotlib widget</span>

<span class="sd">        .. versionadded:: 0.4.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">plot_detection</span><span class="p">()</span></div></div>


<span class="c1">#############################################################################</span>
<span class="c1"># SLOW-WAVES DETECTION</span>
<span class="c1">#############################################################################</span>


<div class="viewcode-block" id="sw_detect"><a class="viewcode-back" href="../../generated/yasa.sw_detect.html#yasa.sw_detect">[docs]</a><span class="k">def</span> <span class="nf">sw_detect</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ch_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">hypno</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">include</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">freq_sw</span><span class="o">=</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">),</span>
              <span class="n">dur_neg</span><span class="o">=</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">),</span> <span class="n">dur_pos</span><span class="o">=</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">amp_neg</span><span class="o">=</span><span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="mi">200</span><span class="p">),</span> <span class="n">amp_pos</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">150</span><span class="p">),</span>
              <span class="n">amp_ptp</span><span class="o">=</span><span class="p">(</span><span class="mi">75</span><span class="p">,</span> <span class="mi">350</span><span class="p">),</span> <span class="n">coupling</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
              <span class="n">coupling_params</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;freq_sp&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span> <span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;p&quot;</span><span class="p">:</span> <span class="mf">0.05</span><span class="p">},</span>
              <span class="n">remove_outliers</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Slow-waves detection.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : array_like</span>
<span class="sd">        Single or multi-channel data. Unit must be uV and shape (n_samples) or</span>
<span class="sd">        (n_chan, n_samples). Can also be a :py:class:`mne.io.BaseRaw`,</span>
<span class="sd">        in which case ``data``, ``sf``, and ``ch_names`` will be automatically</span>
<span class="sd">        extracted, and ``data`` will also be automatically converted from</span>
<span class="sd">        Volts (MNE) to micro-Volts (YASA).</span>
<span class="sd">    sf : float</span>
<span class="sd">        Sampling frequency of the data in Hz.</span>
<span class="sd">        Can be omitted if ``data`` is a :py:class:`mne.io.BaseRaw`.</span>

<span class="sd">        .. tip:: If the detection is taking too long, make sure to downsample</span>
<span class="sd">            your data to 100 Hz (or 128 Hz). For more details, please refer to</span>
<span class="sd">            :py:func:`mne.filter.resample`.</span>
<span class="sd">    ch_names : list of str</span>
<span class="sd">        Channel names. Can be omitted if ``data`` is a</span>
<span class="sd">        :py:class:`mne.io.BaseRaw`.</span>
<span class="sd">    hypno : array_like</span>
<span class="sd">        Sleep stage (hypnogram). If the hypnogram is loaded, the</span>
<span class="sd">        detection will only be applied to the value defined in</span>
<span class="sd">        ``include`` (default = N2 + N3 sleep).</span>

<span class="sd">        The hypnogram must have the same number of samples as ``data``.</span>
<span class="sd">        To upsample your hypnogram, please refer to</span>
<span class="sd">        :py:func:`yasa.hypno_upsample_to_data`.</span>

<span class="sd">        .. note::</span>
<span class="sd">            The default hypnogram format in YASA is a 1D integer</span>
<span class="sd">            vector where:</span>

<span class="sd">            - -2 = Unscored</span>
<span class="sd">            - -1 = Artefact / Movement</span>
<span class="sd">            - 0 = Wake</span>
<span class="sd">            - 1 = N1 sleep</span>
<span class="sd">            - 2 = N2 sleep</span>
<span class="sd">            - 3 = N3 sleep</span>
<span class="sd">            - 4 = REM sleep</span>
<span class="sd">    include : tuple, list or int</span>
<span class="sd">        Values in ``hypno`` that will be included in the mask. The default is</span>
<span class="sd">        (2, 3), meaning that the detection is applied on N2 and N3</span>
<span class="sd">        sleep. This has no effect when ``hypno`` is None.</span>
<span class="sd">    freq_sw : tuple or list</span>
<span class="sd">        Slow wave frequency range. Default is 0.3 to 1.5 Hz. Please note that</span>
<span class="sd">        YASA uses a FIR filter (implemented in MNE) with a 0.2 Hz transition</span>
<span class="sd">        band, which means that the -6 dB points are located at 0.2 and 1.6 Hz.</span>
<span class="sd">    dur_neg : tuple or list</span>
<span class="sd">        The minimum and maximum duration of the negative deflection of the</span>
<span class="sd">        slow wave. Default is 0.3 to 1.5 second.</span>
<span class="sd">    dur_pos : tuple or list</span>
<span class="sd">        The minimum and maximum duration of the positive deflection of the</span>
<span class="sd">        slow wave. Default is 0.1 to 1 second.</span>
<span class="sd">    amp_neg : tuple or list</span>
<span class="sd">        Absolute minimum and maximum negative trough amplitude of the</span>
<span class="sd">        slow-wave. Default is 40 uV to 200 uV. Can also be in unit of standard</span>
<span class="sd">        deviations if the data has been previously z-scored. If you do not want</span>
<span class="sd">        to specify any negative amplitude thresholds,</span>
<span class="sd">        use ``amp_neg=(None, None)``.</span>
<span class="sd">    amp_pos : tuple or list</span>
<span class="sd">        Absolute minimum and maximum positive peak amplitude of the</span>
<span class="sd">        slow-wave. Default is 10 uV to 150 uV. Can also be in unit of standard</span>
<span class="sd">        deviations if the data has been previously z-scored.</span>
<span class="sd">        If you do not want to specify any positive amplitude thresholds,</span>
<span class="sd">        use ``amp_pos=(None, None)``.</span>
<span class="sd">    amp_ptp : tuple or list</span>
<span class="sd">        Minimum and maximum peak-to-peak amplitude of the slow-wave.</span>
<span class="sd">        Default is 75 uV to 350 uV. Can also be in unit of standard</span>
<span class="sd">        deviations if the data has been previously z-scored.</span>
<span class="sd">        Use ``np.inf`` to set no upper amplitude threshold</span>
<span class="sd">        (e.g. ``amp_ptp=(75, np.inf)``).</span>
<span class="sd">    coupling : boolean</span>
<span class="sd">        If True, YASA will also calculate the phase-amplitude coupling between</span>
<span class="sd">        the slow-waves phase and the spindles-related sigma band</span>
<span class="sd">        amplitude. Specifically, the following columns will be added to the</span>
<span class="sd">        output dataframe:</span>

<span class="sd">        1. ``&#39;SigmaPeak&#39;``: The location (in seconds) of the maximum sigma peak amplitude within a</span>
<span class="sd">           2-seconds epoch centered around the negative peak (through) of the current slow-wave.</span>

<span class="sd">        2. ``PhaseAtSigmaPeak``: the phase of the bandpas-filtered slow-wave signal (in radians)</span>
<span class="sd">           at ``&#39;SigmaPeak&#39;``.</span>

<span class="sd">           Importantly, since ``PhaseAtSigmaPeak`` is expressed in radians, one should use circular</span>
<span class="sd">           statistics to calculate the mean direction and vector length:</span>

<span class="sd">           .. code-block:: python</span>

<span class="sd">               import pingouin as pg</span>
<span class="sd">               mean_direction = pg.circ_mean(sw[&#39;PhaseAtSigmaPeak&#39;])</span>
<span class="sd">               vector_length = pg.circ_r(sw[&#39;PhaseAtSigmaPeak&#39;])</span>

<span class="sd">        3. ``ndPAC``: the normalized Mean Vector Length (also called the normalized direct PAC,</span>
<span class="sd">           or ndPAC) within a 2-sec epoch centered around the negative peak of the slow-wave.</span>

<span class="sd">        The lower and upper frequencies for the slow-waves and spindles-related sigma signals are</span>
<span class="sd">        defined in ``freq_sw`` and ``coupling_params[&#39;freq_sp&#39;]``, respectively.</span>
<span class="sd">        For more details, please refer to the `Jupyter notebook</span>
<span class="sd">        &lt;https://github.com/raphaelvallat/yasa/blob/master/notebooks/12_SO-sigma_coupling.ipynb&gt;`_</span>

<span class="sd">        Note that setting ``coupling=True`` may increase computation time.</span>

<span class="sd">        .. versionadded:: 0.2.0</span>

<span class="sd">    coupling_params : dict</span>
<span class="sd">        Parameters for the phase-amplitude coupling.</span>

<span class="sd">        * ``freq_sp`` is a tuple or list that defines the spindles-related frequency of interest.</span>
<span class="sd">          The default is 12 to 16 Hz, with a wide transition bandwidth of 1.5 Hz.</span>

<span class="sd">        * ``time`` is an int or a float that defines the time around the negative peak of each</span>
<span class="sd">          detected slow-waves, in seconds. For example, a value of 1 means that the coupling will</span>
<span class="sd">          be calculated for each slow-waves using a 2-seconds epoch centered around the negative</span>
<span class="sd">          peak of the slow-waves (i.e. 1 second on each side).</span>

<span class="sd">        * ``p`` is a parameter passed to the :py:func:`tensorpac.methods.norm_direct_pac``</span>
<span class="sd">          function. It represents the p-value to use for thresholding of unreliable coupling</span>
<span class="sd">          values. Sub-threshold PAC values will be set to 0. To disable this behavior (no masking),</span>
<span class="sd">          use ``p=1`` or ``p=None``.</span>

<span class="sd">        .. versionadded:: 0.6.0</span>

<span class="sd">    remove_outliers : boolean</span>
<span class="sd">        If True, YASA will automatically detect and remove outliers slow-waves</span>
<span class="sd">        using :py:class:`sklearn.ensemble.IsolationForest`.</span>
<span class="sd">        The outliers detection is performed on the frequency, amplitude and</span>
<span class="sd">        duration parameters of the detected slow-waves. YASA uses a random seed</span>
<span class="sd">        (42) to ensure reproducible results. Note that this step will only be</span>
<span class="sd">        applied if there are more than 50 detected slow-waves in the first</span>
<span class="sd">        place. Default to False.</span>
<span class="sd">    verbose : bool or str</span>
<span class="sd">        Verbose level. Default (False) will only print warning and error</span>
<span class="sd">        messages. The logging levels are &#39;debug&#39;, &#39;info&#39;, &#39;warning&#39;, &#39;error&#39;,</span>
<span class="sd">        and &#39;critical&#39;. For most users the choice is between &#39;info&#39;</span>
<span class="sd">        (or ``verbose=True``) and warning (``verbose=False``).</span>

<span class="sd">        .. versionadded:: 0.2.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sw : :py:class:`yasa.SWResults`</span>
<span class="sd">        To get the full detection dataframe, use:</span>

<span class="sd">        &gt;&gt;&gt; sw = sw_detect(...)</span>
<span class="sd">        &gt;&gt;&gt; sw.summary()</span>

<span class="sd">        This will give a :py:class:`pandas.DataFrame` where each row is a</span>
<span class="sd">        detected slow-wave and each column is a parameter (= property).</span>
<span class="sd">        To get the average SW parameters per channel and sleep stage:</span>

<span class="sd">        &gt;&gt;&gt; sw.summary(grp_chan=True, grp_stage=True)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The parameters that are calculated for each slow-wave are:</span>

<span class="sd">    * ``&#39;Start&#39;``: Start time of each detected slow-wave, in seconds from the beginning of data.</span>
<span class="sd">    * ``&#39;NegPeak&#39;``: Location of the negative peak (in seconds)</span>
<span class="sd">    * ``&#39;MidCrossing&#39;``: Location of the negative-to-positive zero-crossing (in seconds)</span>
<span class="sd">    * ``&#39;Pospeak&#39;``: Location of the positive peak (in seconds)</span>
<span class="sd">    * ``&#39;End&#39;``: End time(in seconds)</span>
<span class="sd">    * ``&#39;Duration&#39;``: Duration (in seconds)</span>
<span class="sd">    * ``&#39;ValNegPeak&#39;``: Amplitude of the negative peak (in uV, calculated on the ``freq_sw``</span>
<span class="sd">      bandpass-filtered signal)</span>
<span class="sd">    * ``&#39;ValPosPeak&#39;``: Amplitude of the positive peak (in uV, calculated on the ``freq_sw``</span>
<span class="sd">      bandpass-filtered signal)</span>
<span class="sd">    * ``&#39;PTP&#39;``: Peak-to-peak amplitude (= ``ValPosPeak`` - ``ValNegPeak``, calculated on the</span>
<span class="sd">      ``freq_sw`` bandpass-filtered signal)</span>
<span class="sd">    * ``&#39;Slope&#39;``: Slope between ``NegPeak`` and ``MidCrossing`` (in uV/sec, calculated on the</span>
<span class="sd">      ``freq_sw`` bandpass-filtered signal)</span>
<span class="sd">    * ``&#39;Frequency&#39;``: Frequency of the slow-wave (= 1 / ``Duration``)</span>
<span class="sd">    * ``&#39;SigmaPeak&#39;``: Location of the sigma peak amplitude within a 2-sec epoch centered around</span>
<span class="sd">      the negative peak of the slow-wave. This is only calculated when ``coupling=True``.</span>
<span class="sd">    * ``&#39;PhaseAtSigmaPeak&#39;``: SW phase at max sigma amplitude within a 2-sec epoch centered around</span>
<span class="sd">      the negative peak of the slow-wave. This is only calculated when ``coupling=True``</span>
<span class="sd">    * ``&#39;ndPAC&#39;``: Normalized direct PAC within a 2-sec epoch centered around the negative peak</span>
<span class="sd">      of the slow-wave. This is only calculated when ``coupling=True``</span>
<span class="sd">    * ``&#39;Stage&#39;``: Sleep stage (only if hypno was provided)</span>

<span class="sd">    .. image:: https://raw.githubusercontent.com/raphaelvallat/yasa/master/docs/pictures/slow_waves.png  # noqa</span>
<span class="sd">      :width: 500px</span>
<span class="sd">      :align: center</span>
<span class="sd">      :alt: slow-wave</span>

<span class="sd">    For better results, apply this detection only on artefact-free NREM sleep.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    The slow-waves detection algorithm is based on:</span>

<span class="sd">    * Massimini, M., Huber, R., Ferrarelli, F., Hill, S., &amp; Tononi, G. (2004). `The sleep slow</span>
<span class="sd">      oscillation as a traveling wave. &lt;https://doi.org/10.1523/JNEUROSCI.1318-04.2004&gt;`_. The</span>
<span class="sd">      Journal of Neuroscience, 24(31), 68626870.</span>

<span class="sd">    * Carrier, J., Viens, I., Poirier, G., Robillard, R., Lafortune, M., Vandewalle, G., Martin,</span>
<span class="sd">      N., Barakat, M., Paquet, J., &amp; Filipini, D. (2011). `Sleep slow wave changes during the</span>
<span class="sd">      middle years of life. &lt;https://doi.org/10.1111/j.1460-9568.2010.07543.x&gt;`_. The European</span>
<span class="sd">      Journal of Neuroscience, 33(4), 758766.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    For an example of how to run the detection, please refer to the tutorial:</span>
<span class="sd">    https://github.com/raphaelvallat/yasa/blob/master/notebooks/05_sw_detection.ipynb</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">set_log_level</span><span class="p">(</span><span class="n">verbose</span><span class="p">)</span>

    <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">ch_names</span><span class="p">,</span> <span class="n">hypno</span><span class="p">,</span> <span class="n">include</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">n_chan</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">,</span> <span class="n">bad_chan</span>
     <span class="p">)</span> <span class="o">=</span> <span class="n">_check_data_hypno</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">ch_names</span><span class="p">,</span> <span class="n">hypno</span><span class="p">,</span> <span class="n">include</span><span class="p">)</span>

    <span class="c1"># If all channels are bad</span>
    <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">bad_chan</span><span class="p">)</span> <span class="o">==</span> <span class="n">n_chan</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;All channels have bad amplitude. Returning None.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Define time vector</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="o">/</span> <span class="n">sf</span>
    <span class="n">idx_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Bandpass filter</span>
    <span class="n">nfast</span> <span class="o">=</span> <span class="n">next_fast_len</span><span class="p">(</span><span class="n">n_samples</span><span class="p">)</span>
    <span class="n">data_filt</span> <span class="o">=</span> <span class="n">filter_data</span><span class="p">(</span>
        <span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">freq_sw</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">freq_sw</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;fir&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">l_trans_bandwidth</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
        <span class="n">h_trans_bandwidth</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>

    <span class="c1"># Extract the spindles-related sigma signal for coupling</span>
    <span class="k">if</span> <span class="n">coupling</span><span class="p">:</span>
        <span class="n">is_tensorpac_installed</span><span class="p">()</span>
        <span class="kn">import</span> <span class="nn">tensorpac.methods</span> <span class="k">as</span> <span class="nn">tpm</span>
        <span class="c1"># The width of the transition band is set to 1.5 Hz on each side,</span>
        <span class="c1"># meaning that for freq_sp = (12, 15 Hz), the -6 dB points are located</span>
        <span class="c1"># at 11.25 and 15.75 Hz. The frequency band for the amplitude signal</span>
        <span class="c1"># must be large enough to fit the sidebands caused by the assumed</span>
        <span class="c1"># modulating lower frequency band (Aru et al. 2015).</span>
        <span class="c1"># https://doi.org/10.1016/j.conb.2014.08.002</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coupling_params</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span>
        <span class="k">assert</span> <span class="s2">&quot;freq_sp&quot;</span> <span class="ow">in</span> <span class="n">coupling_params</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="k">assert</span> <span class="s2">&quot;time&quot;</span> <span class="ow">in</span> <span class="n">coupling_params</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="k">assert</span> <span class="s2">&quot;p&quot;</span> <span class="ow">in</span> <span class="n">coupling_params</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="n">freq_sp</span> <span class="o">=</span> <span class="n">coupling_params</span><span class="p">[</span><span class="s1">&#39;freq_sp&#39;</span><span class="p">]</span>
        <span class="n">data_sp</span> <span class="o">=</span> <span class="n">filter_data</span><span class="p">(</span>
            <span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">freq_sp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">freq_sp</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;fir&#39;</span><span class="p">,</span> <span class="n">l_trans_bandwidth</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span>
            <span class="n">h_trans_bandwidth</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Now extract the instantaneous phase/amplitude using Hilbert transform</span>
        <span class="n">sw_pha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">hilbert</span><span class="p">(</span><span class="n">data_filt</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="n">nfast</span><span class="p">)[:,</span> <span class="p">:</span><span class="n">n_samples</span><span class="p">])</span>
        <span class="n">sp_amp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">hilbert</span><span class="p">(</span><span class="n">data_sp</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="n">nfast</span><span class="p">)[:,</span> <span class="p">:</span><span class="n">n_samples</span><span class="p">])</span>

    <span class="c1"># Initialize empty output dataframe</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_chan</span><span class="p">):</span>
        <span class="c1"># ####################################################################</span>
        <span class="c1"># START SINGLE CHANNEL DETECTION</span>
        <span class="c1"># ####################################################################</span>
        <span class="c1"># First, skip channels with bad data amplitude</span>
        <span class="k">if</span> <span class="n">bad_chan</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="k">continue</span>

        <span class="c1"># Find peaks in data</span>
        <span class="c1"># Negative peaks with value comprised between -40 to -300 uV</span>
        <span class="n">idx_neg_peaks</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">find_peaks</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">data_filt</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">height</span><span class="o">=</span><span class="n">amp_neg</span><span class="p">)</span>
        <span class="c1"># Positive peaks with values comprised between 10 to 200 uV</span>
        <span class="n">idx_pos_peaks</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">find_peaks</span><span class="p">(</span><span class="n">data_filt</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">height</span><span class="o">=</span><span class="n">amp_pos</span><span class="p">)</span>
        <span class="c1"># Intersect with sleep stage vector</span>
        <span class="n">idx_neg_peaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">idx_neg_peaks</span><span class="p">,</span> <span class="n">idx_mask</span><span class="p">,</span> <span class="n">assume_unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">idx_pos_peaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">idx_pos_peaks</span><span class="p">,</span> <span class="n">idx_mask</span><span class="p">,</span> <span class="n">assume_unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># If no peaks are detected, return None</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx_neg_peaks</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx_pos_peaks</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;No SW were found in channel </span><span class="si">%s</span><span class="s1">.&#39;</span><span class="p">,</span> <span class="n">ch_names</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">continue</span>

        <span class="c1"># Make sure that the last detected peak is a positive one</span>
        <span class="k">if</span> <span class="n">idx_pos_peaks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">idx_neg_peaks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="c1"># If not, append a fake positive peak one sample after the last neg</span>
            <span class="n">idx_pos_peaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx_pos_peaks</span><span class="p">,</span> <span class="n">idx_neg_peaks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># For each negative peak, we find the closest following positive peak</span>
        <span class="n">pk_sorted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">idx_pos_peaks</span><span class="p">,</span> <span class="n">idx_neg_peaks</span><span class="p">)</span>
        <span class="n">closest_pos_peaks</span> <span class="o">=</span> <span class="n">idx_pos_peaks</span><span class="p">[</span><span class="n">pk_sorted</span><span class="p">]</span> <span class="o">-</span> <span class="n">idx_neg_peaks</span>
        <span class="n">closest_pos_peaks</span> <span class="o">=</span> <span class="n">closest_pos_peaks</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">closest_pos_peaks</span><span class="p">)]</span>
        <span class="n">idx_pos_peaks</span> <span class="o">=</span> <span class="n">idx_neg_peaks</span> <span class="o">+</span> <span class="n">closest_pos_peaks</span>

        <span class="c1"># Now we compute the PTP amplitude and keep only the good peaks</span>
        <span class="n">sw_ptp</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">data_filt</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">idx_neg_peaks</span><span class="p">])</span> <span class="o">+</span> <span class="n">data_filt</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">idx_pos_peaks</span><span class="p">])</span>
        <span class="n">good_ptp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">sw_ptp</span> <span class="o">&gt;</span> <span class="n">amp_ptp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sw_ptp</span> <span class="o">&lt;</span> <span class="n">amp_ptp</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># If good_ptp is all False</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="o">~</span><span class="n">good_ptp</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;No SW were found in channel </span><span class="si">%s</span><span class="s1">.&#39;</span><span class="p">,</span> <span class="n">ch_names</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">continue</span>

        <span class="n">sw_ptp</span> <span class="o">=</span> <span class="n">sw_ptp</span><span class="p">[</span><span class="n">good_ptp</span><span class="p">]</span>
        <span class="n">idx_neg_peaks</span> <span class="o">=</span> <span class="n">idx_neg_peaks</span><span class="p">[</span><span class="n">good_ptp</span><span class="p">]</span>
        <span class="n">idx_pos_peaks</span> <span class="o">=</span> <span class="n">idx_pos_peaks</span><span class="p">[</span><span class="n">good_ptp</span><span class="p">]</span>

        <span class="c1"># Now we need to check the negative and positive phase duration</span>
        <span class="c1"># For that we need to compute the zero crossings of the filtered signal</span>
        <span class="n">zero_crossings</span> <span class="o">=</span> <span class="n">_zerocrossings</span><span class="p">(</span><span class="n">data_filt</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])</span>
        <span class="c1"># Make sure that there is a zero-crossing after the last detected peak</span>
        <span class="k">if</span> <span class="n">zero_crossings</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nb">max</span><span class="p">(</span><span class="n">idx_pos_peaks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">idx_neg_peaks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="c1"># If not, append the index of the last peak</span>
            <span class="n">zero_crossings</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">zero_crossings</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">idx_pos_peaks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">idx_neg_peaks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

        <span class="c1"># Find distance to previous and following zc</span>
        <span class="n">neg_sorted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">zero_crossings</span><span class="p">,</span> <span class="n">idx_neg_peaks</span><span class="p">)</span>
        <span class="n">previous_neg_zc</span> <span class="o">=</span> <span class="n">zero_crossings</span><span class="p">[</span><span class="n">neg_sorted</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">idx_neg_peaks</span>
        <span class="n">following_neg_zc</span> <span class="o">=</span> <span class="n">zero_crossings</span><span class="p">[</span><span class="n">neg_sorted</span><span class="p">]</span> <span class="o">-</span> <span class="n">idx_neg_peaks</span>

        <span class="c1"># Distance between the positive peaks and the previous and</span>
        <span class="c1"># following zero-crossings</span>
        <span class="n">pos_sorted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">zero_crossings</span><span class="p">,</span> <span class="n">idx_pos_peaks</span><span class="p">)</span>
        <span class="n">previous_pos_zc</span> <span class="o">=</span> <span class="n">zero_crossings</span><span class="p">[</span><span class="n">pos_sorted</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">idx_pos_peaks</span>
        <span class="n">following_pos_zc</span> <span class="o">=</span> <span class="n">zero_crossings</span><span class="p">[</span><span class="n">pos_sorted</span><span class="p">]</span> <span class="o">-</span> <span class="n">idx_pos_peaks</span>

        <span class="c1"># Duration of the negative and positive phases, in seconds</span>
        <span class="n">neg_phase_dur</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">previous_neg_zc</span><span class="p">)</span> <span class="o">+</span> <span class="n">following_neg_zc</span><span class="p">)</span> <span class="o">/</span> <span class="n">sf</span>
        <span class="n">pos_phase_dur</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">previous_pos_zc</span><span class="p">)</span> <span class="o">+</span> <span class="n">following_pos_zc</span><span class="p">)</span> <span class="o">/</span> <span class="n">sf</span>

        <span class="c1"># We now compute a set of metrics</span>
        <span class="n">sw_start</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="n">idx_neg_peaks</span> <span class="o">+</span> <span class="n">previous_neg_zc</span><span class="p">]</span>
        <span class="n">sw_end</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="n">idx_pos_peaks</span> <span class="o">+</span> <span class="n">following_pos_zc</span><span class="p">]</span>
        <span class="c1"># This should be the same as `sw_dur = pos_phase_dur + neg_phase_dur`</span>
        <span class="c1"># We round to avoid floating point errr (e.g. 1.9000000002)</span>
        <span class="n">sw_dur</span> <span class="o">=</span> <span class="p">(</span><span class="n">sw_end</span> <span class="o">-</span> <span class="n">sw_start</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="n">sw_dur_both_phase</span> <span class="o">=</span> <span class="p">(</span><span class="n">pos_phase_dur</span> <span class="o">+</span> <span class="n">neg_phase_dur</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="n">sw_midcrossing</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="n">idx_neg_peaks</span> <span class="o">+</span> <span class="n">following_neg_zc</span><span class="p">]</span>
        <span class="n">sw_idx_neg</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="n">idx_neg_peaks</span><span class="p">]</span>  <span class="c1"># Location of negative peak</span>
        <span class="n">sw_idx_pos</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="n">idx_pos_peaks</span><span class="p">]</span>  <span class="c1"># Location of positive peak</span>
        <span class="c1"># Slope between peak trough and midcrossing</span>
        <span class="n">sw_slope</span> <span class="o">=</span> <span class="n">sw_ptp</span> <span class="o">/</span> <span class="p">(</span><span class="n">sw_midcrossing</span> <span class="o">-</span> <span class="n">sw_idx_neg</span><span class="p">)</span>
        <span class="c1"># Hypnogram</span>
        <span class="k">if</span> <span class="n">hypno</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sw_sta</span> <span class="o">=</span> <span class="n">hypno</span><span class="p">[</span><span class="n">idx_neg_peaks</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sw_sta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">sw_dur</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="c1"># And we apply a set of thresholds to remove bad slow waves</span>
        <span class="n">good_sw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="o">.</span><span class="n">reduce</span><span class="p">((</span>
            <span class="c1"># Data edges</span>
            <span class="n">previous_neg_zc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">following_neg_zc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">previous_pos_zc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">following_pos_zc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span>
            <span class="c1"># Duration criteria</span>
            <span class="n">sw_dur</span> <span class="o">==</span> <span class="n">sw_dur_both_phase</span><span class="p">,</span>  <span class="c1"># dur = negative + positive</span>
            <span class="n">sw_dur</span> <span class="o">&lt;=</span> <span class="n">dur_neg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dur_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>  <span class="c1"># dur &lt; max(neg) + max(pos)</span>
            <span class="n">sw_dur</span> <span class="o">&gt;=</span> <span class="n">dur_neg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">dur_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>  <span class="c1"># dur &gt; min(neg) + min(pos)</span>
            <span class="n">neg_phase_dur</span> <span class="o">&gt;</span> <span class="n">dur_neg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">neg_phase_dur</span> <span class="o">&lt;</span> <span class="n">dur_neg</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">pos_phase_dur</span> <span class="o">&gt;</span> <span class="n">dur_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">pos_phase_dur</span> <span class="o">&lt;</span> <span class="n">dur_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="c1"># Sanity checks</span>
            <span class="n">sw_midcrossing</span> <span class="o">&gt;</span> <span class="n">sw_start</span><span class="p">,</span>
            <span class="n">sw_midcrossing</span> <span class="o">&lt;</span> <span class="n">sw_end</span><span class="p">,</span>
            <span class="n">sw_slope</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span>
        <span class="p">))</span>

        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="o">~</span><span class="n">good_sw</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;No SW were found in channel </span><span class="si">%s</span><span class="s1">.&#39;</span><span class="p">,</span> <span class="n">ch_names</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">continue</span>

        <span class="c1"># Filter good events</span>
        <span class="n">idx_neg_peaks</span> <span class="o">=</span> <span class="n">idx_neg_peaks</span><span class="p">[</span><span class="n">good_sw</span><span class="p">]</span>
        <span class="n">idx_pos_peaks</span> <span class="o">=</span> <span class="n">idx_pos_peaks</span><span class="p">[</span><span class="n">good_sw</span><span class="p">]</span>
        <span class="n">sw_start</span> <span class="o">=</span> <span class="n">sw_start</span><span class="p">[</span><span class="n">good_sw</span><span class="p">]</span>
        <span class="n">sw_idx_neg</span> <span class="o">=</span> <span class="n">sw_idx_neg</span><span class="p">[</span><span class="n">good_sw</span><span class="p">]</span>
        <span class="n">sw_midcrossing</span> <span class="o">=</span> <span class="n">sw_midcrossing</span><span class="p">[</span><span class="n">good_sw</span><span class="p">]</span>
        <span class="n">sw_idx_pos</span> <span class="o">=</span> <span class="n">sw_idx_pos</span><span class="p">[</span><span class="n">good_sw</span><span class="p">]</span>
        <span class="n">sw_end</span> <span class="o">=</span> <span class="n">sw_end</span><span class="p">[</span><span class="n">good_sw</span><span class="p">]</span>
        <span class="n">sw_dur</span> <span class="o">=</span> <span class="n">sw_dur</span><span class="p">[</span><span class="n">good_sw</span><span class="p">]</span>
        <span class="n">sw_ptp</span> <span class="o">=</span> <span class="n">sw_ptp</span><span class="p">[</span><span class="n">good_sw</span><span class="p">]</span>
        <span class="n">sw_slope</span> <span class="o">=</span> <span class="n">sw_slope</span><span class="p">[</span><span class="n">good_sw</span><span class="p">]</span>
        <span class="n">sw_sta</span> <span class="o">=</span> <span class="n">sw_sta</span><span class="p">[</span><span class="n">good_sw</span><span class="p">]</span>

        <span class="c1"># Create a dictionnary</span>
        <span class="n">sw_params</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">({</span>
            <span class="s1">&#39;Start&#39;</span><span class="p">:</span> <span class="n">sw_start</span><span class="p">,</span>
            <span class="s1">&#39;NegPeak&#39;</span><span class="p">:</span> <span class="n">sw_idx_neg</span><span class="p">,</span>
            <span class="s1">&#39;MidCrossing&#39;</span><span class="p">:</span> <span class="n">sw_midcrossing</span><span class="p">,</span>
            <span class="s1">&#39;PosPeak&#39;</span><span class="p">:</span> <span class="n">sw_idx_pos</span><span class="p">,</span>
            <span class="s1">&#39;End&#39;</span><span class="p">:</span> <span class="n">sw_end</span><span class="p">,</span>
            <span class="s1">&#39;Duration&#39;</span><span class="p">:</span> <span class="n">sw_dur</span><span class="p">,</span>
            <span class="s1">&#39;ValNegPeak&#39;</span><span class="p">:</span> <span class="n">data_filt</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">idx_neg_peaks</span><span class="p">],</span>
            <span class="s1">&#39;ValPosPeak&#39;</span><span class="p">:</span> <span class="n">data_filt</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">idx_pos_peaks</span><span class="p">],</span>
            <span class="s1">&#39;PTP&#39;</span><span class="p">:</span> <span class="n">sw_ptp</span><span class="p">,</span>
            <span class="s1">&#39;Slope&#39;</span><span class="p">:</span> <span class="n">sw_slope</span><span class="p">,</span>
            <span class="s1">&#39;Frequency&#39;</span><span class="p">:</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">sw_dur</span><span class="p">,</span>
            <span class="s1">&#39;Stage&#39;</span><span class="p">:</span> <span class="n">sw_sta</span><span class="p">,</span>
        <span class="p">})</span>

        <span class="c1"># Add phase (in radians) of slow-oscillation signal at maximum</span>
        <span class="c1"># spindles-related sigma amplitude within a XX-seconds centered epochs.</span>
        <span class="k">if</span> <span class="n">coupling</span><span class="p">:</span>
            <span class="c1"># Get phase and amplitude for each centered epoch</span>
            <span class="n">time_before</span> <span class="o">=</span> <span class="n">time_after</span> <span class="o">=</span> <span class="n">coupling_params</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span>
            <span class="k">assert</span> <span class="nb">float</span><span class="p">(</span><span class="n">sf</span> <span class="o">*</span> <span class="n">time_before</span><span class="p">)</span><span class="o">.</span><span class="n">is_integer</span><span class="p">(),</span> <span class="p">(</span>
                <span class="s2">&quot;Invalid time parameter for coupling. Must be a whole number of samples.&quot;</span><span class="p">)</span>
            <span class="n">bef</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sf</span> <span class="o">*</span> <span class="n">time_before</span><span class="p">)</span>
            <span class="n">aft</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sf</span> <span class="o">*</span> <span class="n">time_after</span><span class="p">)</span>
            <span class="c1"># Center of each epoch is defined as the negative peak of the SW</span>
            <span class="n">n_peaks</span> <span class="o">=</span> <span class="n">idx_neg_peaks</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># idx.shape = (len(idx_valid), bef + aft + 1)</span>
            <span class="n">idx</span><span class="p">,</span> <span class="n">idx_valid</span> <span class="o">=</span> <span class="n">get_centered_indices</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">idx_neg_peaks</span><span class="p">,</span> <span class="n">bef</span><span class="p">,</span> <span class="n">aft</span><span class="p">)</span>
            <span class="n">sw_pha_ev</span> <span class="o">=</span> <span class="n">sw_pha</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span>
            <span class="n">sp_amp_ev</span> <span class="o">=</span> <span class="n">sp_amp</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span>
            <span class="c1"># 1) Find location of max sigma amplitude in epoch</span>
            <span class="n">idx_max_amp</span> <span class="o">=</span> <span class="n">sp_amp_ev</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># Now we need to append it back to the original unmasked shape</span>
            <span class="c1"># to avoid error when idx.shape[0] != idx_valid.shape, i.e.</span>
            <span class="c1"># some epochs were out of data bounds.</span>
            <span class="n">sw_params</span><span class="p">[</span><span class="s1">&#39;SigmaPeak&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_peaks</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="c1"># Timestamp at sigma peak, expressed in seconds from negative peak</span>
            <span class="c1"># e.g. -0.39, 0.5, 1, 2 -- limits are [time_before, time_after]</span>
            <span class="n">time_sigpk</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx_max_amp</span> <span class="o">-</span> <span class="n">bef</span><span class="p">)</span> <span class="o">/</span> <span class="n">sf</span>
            <span class="c1"># convert to absolute time from beginning of the recording</span>
            <span class="c1"># time_sigpk only includes valid epoch</span>
            <span class="n">time_sigpk_abs</span> <span class="o">=</span> <span class="n">sw_idx_neg</span><span class="p">[</span><span class="n">idx_valid</span><span class="p">]</span> <span class="o">+</span> <span class="n">time_sigpk</span>
            <span class="n">sw_params</span><span class="p">[</span><span class="s1">&#39;SigmaPeak&#39;</span><span class="p">][</span><span class="n">idx_valid</span><span class="p">]</span> <span class="o">=</span> <span class="n">time_sigpk_abs</span>
            <span class="c1"># 2) PhaseAtSigmaPeak</span>
            <span class="c1"># Find SW phase at max sigma amplitude in epoch</span>
            <span class="n">pha_at_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">take_along_axis</span><span class="p">(</span><span class="n">sw_pha_ev</span><span class="p">,</span> <span class="n">idx_max_amp</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">sw_params</span><span class="p">[</span><span class="s1">&#39;PhaseAtSigmaPeak&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_peaks</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">sw_params</span><span class="p">[</span><span class="s1">&#39;PhaseAtSigmaPeak&#39;</span><span class="p">][</span><span class="n">idx_valid</span><span class="p">]</span> <span class="o">=</span> <span class="n">pha_at_max</span>
            <span class="c1"># 3) Normalized Direct PAC, with thresholding</span>
            <span class="c1"># Unreliable values are set to 0</span>
            <span class="n">ndp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">tpm</span><span class="o">.</span><span class="n">norm_direct_pac</span><span class="p">(</span>
                <span class="n">sw_pha_ev</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">sp_amp_ev</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">p</span><span class="o">=</span><span class="n">coupling_params</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]))</span>
            <span class="n">sw_params</span><span class="p">[</span><span class="s1">&#39;ndPAC&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_peaks</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">sw_params</span><span class="p">[</span><span class="s1">&#39;ndPAC&#39;</span><span class="p">][</span><span class="n">idx_valid</span><span class="p">]</span> <span class="o">=</span> <span class="n">ndp</span>
            <span class="c1"># Make sure that Stage is the last column of the dataframe</span>
            <span class="n">sw_params</span><span class="o">.</span><span class="n">move_to_end</span><span class="p">(</span><span class="s1">&#39;Stage&#39;</span><span class="p">)</span>

        <span class="c1"># Convert to dataframe, keeping only good events</span>
        <span class="n">df_chan</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">sw_params</span><span class="p">)</span>

        <span class="c1"># Remove all duplicates</span>
        <span class="n">df_chan</span> <span class="o">=</span> <span class="n">df_chan</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Start&#39;</span><span class="p">],</span> <span class="n">keep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">df_chan</span> <span class="o">=</span> <span class="n">df_chan</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;End&#39;</span><span class="p">],</span> <span class="n">keep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># We need at least 50 detected slow waves to apply the Isolation Forest</span>
        <span class="k">if</span> <span class="n">remove_outliers</span> <span class="ow">and</span> <span class="n">df_chan</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">50</span><span class="p">:</span>
            <span class="n">col_keep</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Duration&#39;</span><span class="p">,</span> <span class="s1">&#39;ValNegPeak&#39;</span><span class="p">,</span> <span class="s1">&#39;ValPosPeak&#39;</span><span class="p">,</span> <span class="s1">&#39;PTP&#39;</span><span class="p">,</span> <span class="s1">&#39;Slope&#39;</span><span class="p">,</span> <span class="s1">&#39;Frequency&#39;</span><span class="p">]</span>
            <span class="n">ilf</span> <span class="o">=</span> <span class="n">IsolationForest</span><span class="p">(</span><span class="n">contamination</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">max_samples</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span>
                                  <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
            <span class="n">good</span> <span class="o">=</span> <span class="n">ilf</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">df_chan</span><span class="p">[</span><span class="n">col_keep</span><span class="p">])</span>
            <span class="n">good</span><span class="p">[</span><span class="n">good</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%i</span><span class="s1"> outliers were removed in channel </span><span class="si">%s</span><span class="s1">.&#39;</span>
                        <span class="o">%</span> <span class="p">((</span><span class="n">good</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="n">ch_names</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="c1"># Remove outliers from DataFrame</span>
            <span class="n">df_chan</span> <span class="o">=</span> <span class="n">df_chan</span><span class="p">[</span><span class="n">good</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)]</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%i</span><span class="s1"> slow-waves were found in channel </span><span class="si">%s</span><span class="s1">.&#39;</span>
                        <span class="o">%</span> <span class="p">(</span><span class="n">df_chan</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ch_names</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

        <span class="c1"># ####################################################################</span>
        <span class="c1"># END SINGLE CHANNEL DETECTION</span>
        <span class="c1"># ####################################################################</span>

        <span class="n">df_chan</span><span class="p">[</span><span class="s1">&#39;Channel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ch_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">df_chan</span><span class="p">[</span><span class="s1">&#39;IdxChannel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df_chan</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># If no SW were detected, return None</span>
    <span class="k">if</span> <span class="n">df</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;No SW were found in data. Returning None.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">hypno</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Stage&#39;</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;Stage&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;Stage&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">SWResults</span><span class="p">(</span><span class="n">events</span><span class="o">=</span><span class="n">df</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="o">=</span><span class="n">sf</span><span class="p">,</span> <span class="n">ch_names</span><span class="o">=</span><span class="n">ch_names</span><span class="p">,</span>
                     <span class="n">hypno</span><span class="o">=</span><span class="n">hypno</span><span class="p">,</span> <span class="n">data_filt</span><span class="o">=</span><span class="n">data_filt</span><span class="p">)</span></div>


<div class="viewcode-block" id="SWResults"><a class="viewcode-back" href="../../generated/yasa.SWResults.html#yasa.SWResults">[docs]</a><span class="k">class</span> <span class="nc">SWResults</span><span class="p">(</span><span class="n">_DetectionResults</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Output class for slow-waves detection.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    _events : :py:class:`pandas.DataFrame`</span>
<span class="sd">        Output detection dataframe</span>
<span class="sd">    _data : array_like</span>
<span class="sd">        EEG data of shape *(n_chan, n_samples)*.</span>
<span class="sd">    _data_filt : array_like</span>
<span class="sd">        Slow-wave filtered EEG data of shape *(n_chan, n_samples)*.</span>
<span class="sd">    _sf : float</span>
<span class="sd">        Sampling frequency of data.</span>
<span class="sd">    _ch_names : list</span>
<span class="sd">        Channel names.</span>
<span class="sd">    _hypno : array_like or None</span>
<span class="sd">        Sleep staging vector.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="SWResults.__init__"><a class="viewcode-back" href="../../generated/yasa.SWResults.html#yasa.SWResults.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">ch_names</span><span class="p">,</span> <span class="n">hypno</span><span class="p">,</span> <span class="n">data_filt</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">events</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">ch_names</span><span class="p">,</span> <span class="n">hypno</span><span class="p">,</span> <span class="n">data_filt</span><span class="p">)</span></div>

<div class="viewcode-block" id="SWResults.summary"><a class="viewcode-back" href="../../generated/yasa.SWResults.html#yasa.SWResults.summary">[docs]</a>    <span class="k">def</span> <span class="nf">summary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grp_chan</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">grp_stage</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">aggfunc</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a summary of the SW detection, optionally grouped across</span>
<span class="sd">        channels and/or stage.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        grp_chan : bool</span>
<span class="sd">            If True, group by channel (for multi-channels detection only).</span>
<span class="sd">        grp_stage : bool</span>
<span class="sd">            If True, group by sleep stage (provided that an hypnogram was used).</span>
<span class="sd">        mask : array_like or None</span>
<span class="sd">            Custom boolean mask. Only the detected events for which mask is True will be</span>
<span class="sd">            included in the summary. Default is None, i.e. no masking (all events are included).</span>
<span class="sd">        aggfunc : str or function</span>
<span class="sd">            Averaging function (e.g. ``&#39;mean&#39;`` or ``&#39;median&#39;``).</span>
<span class="sd">        sort : bool</span>
<span class="sd">            If True, sort group keys when grouping.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">summary</span><span class="p">(</span><span class="n">event_type</span><span class="o">=</span><span class="s1">&#39;sw&#39;</span><span class="p">,</span> <span class="n">grp_chan</span><span class="o">=</span><span class="n">grp_chan</span><span class="p">,</span> <span class="n">grp_stage</span><span class="o">=</span><span class="n">grp_stage</span><span class="p">,</span>
                               <span class="n">aggfunc</span><span class="o">=</span><span class="n">aggfunc</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="n">sort</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span></div>

<div class="viewcode-block" id="SWResults.find_cooccurring_spindles"><a class="viewcode-back" href="../../generated/yasa.SWResults.html#yasa.SWResults.find_cooccurring_spindles">[docs]</a>    <span class="k">def</span> <span class="nf">find_cooccurring_spindles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spindles</span><span class="p">,</span> <span class="n">lookaround</span><span class="o">=</span><span class="mf">1.2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Given a spindles detection summary dataframe, find slow-waves that co-occur with</span>
<span class="sd">        sleep spindles.</span>

<span class="sd">        .. versionadded:: 0.6.0</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        spindles : :py:class:`pandas.DataFrame`</span>
<span class="sd">            Output dataframe of :py:meth:`yasa.SpindlesResults.summary`.</span>
<span class="sd">        lookaround : float</span>
<span class="sd">            Lookaround window, in seconds. The default is +/- 1.2 seconds around the</span>
<span class="sd">            negative peak of the slow-wave, as in [1]_. This means that YASA will look for a</span>
<span class="sd">            spindle in a 2.4 seconds window centered around the downstate of the slow-wave.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        _events : :py:class:`pandas.DataFrame`</span>
<span class="sd">            The slow-wave detection is modified IN-PLACE (see Notes). To see the updated dataframe,</span>
<span class="sd">            call the :py:meth:`yasa.SWResults.summary` method.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        From [1]_:</span>

<span class="sd">            &quot;SOspindle co-occurrence was first determined by the number of spindle centers</span>
<span class="sd">            occurring within a 1.2-sec window around the downstate peak of a SO, expressed as</span>
<span class="sd">            the ratio of all detected SO events in an individual channel.&quot;</span>

<span class="sd">        This function adds three columns to the output detection dataframe:</span>

<span class="sd">        * `CooccurringSpindle`: a boolean column (True / False) that indicates whether the given</span>
<span class="sd">          slow-wave co-occur with a sleep spindle.</span>

<span class="sd">        * `CooccurringSpindlePeak`: the timestamp of the peak of the co-occurring,</span>
<span class="sd">          in seconds from beginning of recording. Values are set to np.nan when no co-occurring</span>
<span class="sd">          spindles were found.</span>

<span class="sd">        * `DistanceSpindleToSW`: The distance in seconds from the center peak of the spindles and</span>
<span class="sd">          the negative peak of the slow-waves. Negative values indicate that the spindles occured</span>
<span class="sd">          before the negative peak of the slow-waves. Values are set to np.nan when no co-occurring</span>
<span class="sd">          spindles were found.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] Kurz, E. M., Conzelmann, A., Barth, G. M., Renner, T. J., Zinke, K., &amp; Born, J.</span>
<span class="sd">               (2021). How do children with autism spectrum disorder form gist memory during sleep?</span>
<span class="sd">               A study of slow oscillationspindle coupling. Sleep, 44(6), zsaa290.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spindles</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">),</span> <span class="s2">&quot;spindles must be a detection dataframe.&quot;</span>
        <span class="n">distance_sp_to_sw_peak</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cooccurring_spindle_peaks</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Find intersecting channels</span>
        <span class="n">common_ch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_events</span><span class="p">[</span><span class="s1">&#39;Channel&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">(),</span> <span class="n">spindles</span><span class="p">[</span><span class="s1">&#39;Channel&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">common_ch</span><span class="p">),</span> <span class="s2">&quot;No common channel(s) were found.&quot;</span>

        <span class="c1"># Loop across channels</span>
        <span class="k">for</span> <span class="n">chan</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_events</span><span class="p">[</span><span class="s1">&#39;Channel&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>
            <span class="n">sw_chan_peaks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_events</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_events</span><span class="p">[</span><span class="s2">&quot;Channel&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">chan</span><span class="p">][</span><span class="s2">&quot;NegPeak&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
            <span class="n">sp_chan_peaks</span> <span class="o">=</span> <span class="n">spindles</span><span class="p">[</span><span class="n">spindles</span><span class="p">[</span><span class="s2">&quot;Channel&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">chan</span><span class="p">][</span><span class="s1">&#39;Peak&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
            <span class="c1"># Loop across individual slow-waves</span>
            <span class="k">for</span> <span class="n">sw_negpeak</span> <span class="ow">in</span> <span class="n">sw_chan_peaks</span><span class="p">:</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">sw_negpeak</span> <span class="o">-</span> <span class="n">lookaround</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">sw_negpeak</span> <span class="o">+</span> <span class="n">lookaround</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">sp_chan_peaks</span><span class="p">,</span> <span class="n">sp_chan_peaks</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
                    <span class="c1"># If multiple spindles are present, take the last one</span>
                    <span class="n">sp_peak</span> <span class="o">=</span> <span class="n">sp_chan_peaks</span><span class="p">[</span><span class="n">mask</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">cooccurring_spindle_peaks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sp_peak</span><span class="p">)</span>
                    <span class="n">distance_sp_to_sw_peak</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sp_peak</span> <span class="o">-</span> <span class="n">sw_negpeak</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cooccurring_spindle_peaks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
                    <span class="n">distance_sp_to_sw_peak</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="c1"># Add columns to self._events: IN-PLACE MODIFICATION!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_events</span><span class="p">[</span><span class="s2">&quot;CooccurringSpindle&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">distance_sp_to_sw_peak</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_events</span><span class="p">[</span><span class="s2">&quot;CooccurringSpindlePeak&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cooccurring_spindle_peaks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_events</span><span class="p">[</span><span class="s1">&#39;DistanceSpindleToSW&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">distance_sp_to_sw_peak</span></div>

<div class="viewcode-block" id="SWResults.get_coincidence_matrix"><a class="viewcode-back" href="../../generated/yasa.SWResults.html#yasa.SWResults.get_coincidence_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">get_coincidence_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scaled</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the (scaled) coincidence matrix.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scaled : bool</span>
<span class="sd">            If True (default), the coincidence matrix is scaled (see Notes).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        coincidence : pd.DataFrame</span>
<span class="sd">            A symmetric matrix with the (scaled) coincidence values.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Do slow-waves occur at the same time? One way to measure this is to</span>
<span class="sd">        calculate the coincidence matrix, which gives, for each pair of</span>
<span class="sd">        channel, the number of samples that were marked as a slow-waves in both</span>
<span class="sd">        channels. The output is a symmetric matrix, in which the diagonal is</span>
<span class="sd">        simply the number of data points that were marked as a slow-waves in</span>
<span class="sd">        the channel.</span>

<span class="sd">        The coincidence matrix can be scaled (default) by dividing the output</span>
<span class="sd">        by the product of the sum of each individual binary mask, as shown in</span>
<span class="sd">        the example below. It can then be used to define functional</span>
<span class="sd">        networks or quickly find outlier channels.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Calculate the coincidence of two binary mask:</span>

<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; x = np.array([0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1])</span>
<span class="sd">        &gt;&gt;&gt; y = np.array([0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1])</span>
<span class="sd">        &gt;&gt;&gt; x * y</span>
<span class="sd">        array([0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1])</span>

<span class="sd">        &gt;&gt;&gt; (x * y).sum()  # Coincidence</span>
<span class="sd">        3</span>

<span class="sd">        &gt;&gt;&gt; (x * y).sum() / (x.sum() * y.sum())  # Scaled coincidence</span>
<span class="sd">        0.12</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        - https://github.com/Mark-Kramer/Sleep-Networks-2021</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_coincidence_matrix</span><span class="p">(</span><span class="n">scaled</span><span class="o">=</span><span class="n">scaled</span><span class="p">)</span></div>

<div class="viewcode-block" id="SWResults.get_mask"><a class="viewcode-back" href="../../generated/yasa.SWResults.html#yasa.SWResults.get_mask">[docs]</a>    <span class="k">def</span> <span class="nf">get_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a boolean array indicating for each sample in data if this</span>
<span class="sd">        sample is part of a detected event (True) or not (False).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_mask</span><span class="p">()</span></div>

<div class="viewcode-block" id="SWResults.get_sync_events"><a class="viewcode-back" href="../../generated/yasa.SWResults.html#yasa.SWResults.get_sync_events">[docs]</a>    <span class="k">def</span> <span class="nf">get_sync_events</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="s1">&#39;NegPeak&#39;</span><span class="p">,</span> <span class="n">time_before</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">time_after</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">filt</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                        <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">as_dataframe</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the raw data of each detected event after centering to a specific timepoint.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        center : str</span>
<span class="sd">            Landmark of the event to synchronize the timing on.</span>
<span class="sd">            Default is to use the negative peak of the slow-wave.</span>
<span class="sd">        time_before : float</span>
<span class="sd">            Time (in seconds) before ``center``.</span>
<span class="sd">        time_after : float</span>
<span class="sd">            Time (in seconds) after ``center``.</span>
<span class="sd">        filt : tuple</span>
<span class="sd">            Optional filtering to apply to data. For instance, ``filt=(1, 30)``</span>
<span class="sd">            will apply a 1 to 30 Hz bandpass filter, and ``filt=(None, 40)``</span>
<span class="sd">            will apply a 40 Hz lowpass filter. Filtering is done using default</span>
<span class="sd">            parameters in the :py:func:`mne.filter.filter_data` function.</span>
<span class="sd">        mask : array_like or None</span>
<span class="sd">            Custom boolean mask. Only the detected events for which mask is True will be</span>
<span class="sd">            included. Default is None, i.e. no masking (all events are included).</span>
<span class="sd">        as_dataframe : boolean</span>
<span class="sd">            If True (default), returns a long-format pandas dataframe. If False, returns a list of</span>
<span class="sd">            numpy arrays. Each element of the list a unique channel, and the shape of the numpy</span>
<span class="sd">            arrays within the list is (n_events, n_times).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        df_sync : :py:class:`pandas.DataFrame` or list</span>
<span class="sd">            Ouput long-format dataframe (if ``as_dataframe=True``)::</span>

<span class="sd">            &#39;Event&#39; : Event number</span>
<span class="sd">            &#39;Time&#39; : Timing of the events (in seconds)</span>
<span class="sd">            &#39;Amplitude&#39; : Raw or filtered data for event</span>
<span class="sd">            &#39;Channel&#39; : Channel</span>
<span class="sd">            &#39;IdxChannel&#39; : Index of channel in data</span>
<span class="sd">            &#39;Stage&#39;: Sleep stage in which the events occured (if available)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_sync_events</span><span class="p">(</span>
            <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span> <span class="n">time_before</span><span class="o">=</span><span class="n">time_before</span><span class="p">,</span> <span class="n">time_after</span><span class="o">=</span><span class="n">time_after</span><span class="p">,</span> <span class="n">filt</span><span class="o">=</span><span class="n">filt</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span>
            <span class="n">as_dataframe</span><span class="o">=</span><span class="n">as_dataframe</span><span class="p">)</span></div>

<div class="viewcode-block" id="SWResults.plot_average"><a class="viewcode-back" href="../../generated/yasa.SWResults.html#yasa.SWResults.plot_average">[docs]</a>    <span class="k">def</span> <span class="nf">plot_average</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="s1">&#39;NegPeak&#39;</span><span class="p">,</span> <span class="n">hue</span><span class="o">=</span><span class="s1">&#39;Channel&#39;</span><span class="p">,</span> <span class="n">time_before</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">time_after</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span>
                     <span class="n">filt</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the average slow-wave.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        center : str</span>
<span class="sd">            Landmark of the event to synchronize the timing on. The default is to use the negative</span>
<span class="sd">            peak of the slow-wave.</span>
<span class="sd">        hue : str</span>
<span class="sd">            Grouping variable that will produce lines with different colors.</span>
<span class="sd">            Can be either &#39;Channel&#39; or &#39;Stage&#39;.</span>
<span class="sd">        time_before : float</span>
<span class="sd">            Time (in seconds) before ``center``.</span>
<span class="sd">        time_after : float</span>
<span class="sd">            Time (in seconds) after ``center``.</span>
<span class="sd">        filt : tuple</span>
<span class="sd">            Optional filtering to apply to data. For instance, ``filt=(1, 30)``</span>
<span class="sd">            will apply a 1 to 30 Hz bandpass filter, and ``filt=(None, 40)``</span>
<span class="sd">            will apply a 40 Hz lowpass filter. Filtering is done using default</span>
<span class="sd">            parameters in the :py:func:`mne.filter.filter_data` function.</span>
<span class="sd">        mask : array_like or None</span>
<span class="sd">            Custom boolean mask. Only the detected events for which mask is True will be</span>
<span class="sd">            plotted. Default is None, i.e. no masking (all events are included).</span>
<span class="sd">        figsize : tuple</span>
<span class="sd">            Figure size in inches.</span>
<span class="sd">        **kwargs : dict</span>
<span class="sd">            Optional argument that are passed to :py:func:`seaborn.lineplot`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">plot_average</span><span class="p">(</span>
            <span class="n">event_type</span><span class="o">=</span><span class="s1">&#39;sw&#39;</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span> <span class="n">hue</span><span class="o">=</span><span class="n">hue</span><span class="p">,</span> <span class="n">time_before</span><span class="o">=</span><span class="n">time_before</span><span class="p">,</span>
            <span class="n">time_after</span><span class="o">=</span><span class="n">time_after</span><span class="p">,</span> <span class="n">filt</span><span class="o">=</span><span class="n">filt</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="SWResults.plot_detection"><a class="viewcode-back" href="../../generated/yasa.SWResults.html#yasa.SWResults.plot_detection">[docs]</a>    <span class="k">def</span> <span class="nf">plot_detection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot an overlay of the detected slow-waves on the EEG signal.</span>

<span class="sd">        This only works in Jupyter and it requires the ipywidgets</span>
<span class="sd">        (https://ipywidgets.readthedocs.io/en/latest/) package.</span>

<span class="sd">        To activate the interactive mode, make sure to run:</span>

<span class="sd">        &gt;&gt;&gt; %matplotlib widget</span>

<span class="sd">        .. versionadded:: 0.4.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">plot_detection</span><span class="p">()</span></div></div>


<span class="c1">#############################################################################</span>
<span class="c1"># REMs DETECTION</span>
<span class="c1">#############################################################################</span>


<div class="viewcode-block" id="rem_detect"><a class="viewcode-back" href="../../generated/yasa.rem_detect.html#yasa.rem_detect">[docs]</a><span class="k">def</span> <span class="nf">rem_detect</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">roc</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">hypno</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">include</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">amplitude</span><span class="o">=</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">325</span><span class="p">),</span> <span class="n">duration</span><span class="o">=</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">),</span>
               <span class="n">freq_rem</span><span class="o">=</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">remove_outliers</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Rapid eye movements (REMs) detection.</span>

<span class="sd">    This detection requires both the left EOG (LOC) and right EOG (LOC).</span>
<span class="sd">    The units of the data must be uV. The algorithm is based on an amplitude</span>
<span class="sd">    thresholding of the negative product of the LOC and ROC</span>
<span class="sd">    filtered signal.</span>

<span class="sd">    .. versionadded:: 0.1.5</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    loc, roc : array_like</span>
<span class="sd">        Continuous EOG data (Left and Right Ocular Canthi, LOC / ROC) channels.</span>
<span class="sd">        Unit must be uV.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            The default unit of :py:class:`mne.io.BaseRaw` is Volts.</span>
<span class="sd">            Therefore, if passing data from a :py:class:`mne.io.BaseRaw`,</span>
<span class="sd">            you need to multiply the data by 1e6 to convert to micro-Volts</span>
<span class="sd">            (1 V = 1,000,000 uV), e.g.:</span>

<span class="sd">            &gt;&gt;&gt; data = raw.get_data() * 1e6  # Make sure that data is in uV</span>
<span class="sd">    sf : float</span>
<span class="sd">        Sampling frequency of the data, in Hz.</span>
<span class="sd">    hypno : array_like</span>
<span class="sd">        Sleep stage (hypnogram). If the hypnogram is loaded, the</span>
<span class="sd">        detection will only be applied to the value defined in</span>
<span class="sd">        ``include`` (default = REM sleep).</span>

<span class="sd">        The hypnogram must have the same number of samples as ``data``.</span>
<span class="sd">        To upsample your hypnogram, please refer to</span>
<span class="sd">        :py:func:`yasa.hypno_upsample_to_data`.</span>

<span class="sd">        .. note::</span>
<span class="sd">            The default hypnogram format in YASA is a 1D integer</span>
<span class="sd">            vector where:</span>

<span class="sd">            - -2 = Unscored</span>
<span class="sd">            - -1 = Artefact / Movement</span>
<span class="sd">            - 0 = Wake</span>
<span class="sd">            - 1 = N1 sleep</span>
<span class="sd">            - 2 = N2 sleep</span>
<span class="sd">            - 3 = N3 sleep</span>
<span class="sd">            - 4 = REM sleep</span>
<span class="sd">    include : tuple, list or int</span>
<span class="sd">        Values in ``hypno`` that will be included in the mask. The default is</span>
<span class="sd">        (4), meaning that the detection is applied on REM sleep.</span>
<span class="sd">        This has no effect when ``hypno`` is None.</span>
<span class="sd">    amplitude : tuple or list</span>
<span class="sd">        Minimum and maximum amplitude of the peak of the REM.</span>
<span class="sd">        Default is 50 uV to 325 uV.</span>
<span class="sd">    duration : tuple or list</span>
<span class="sd">        The minimum and maximum duration of the REMs.</span>
<span class="sd">        Default is 0.3 to 1.2 seconds.</span>
<span class="sd">    freq_rem : tuple or list</span>
<span class="sd">        Frequency range of REMs. Default is 0.5 to 5 Hz.</span>
<span class="sd">    remove_outliers : boolean</span>
<span class="sd">        If True, YASA will automatically detect and remove outliers REMs</span>
<span class="sd">        using :py:class:`sklearn.ensemble.IsolationForest`.</span>
<span class="sd">        YASA uses a random seed (42) to ensure reproducible results.</span>
<span class="sd">        Note that this step will only be applied if there are more than</span>
<span class="sd">        50 detected REMs in the first place. Default to False.</span>
<span class="sd">    verbose : bool or str</span>
<span class="sd">        Verbose level. Default (False) will only print warning and error</span>
<span class="sd">        messages. The logging levels are &#39;debug&#39;, &#39;info&#39;, &#39;warning&#39;, &#39;error&#39;,</span>
<span class="sd">        and &#39;critical&#39;. For most users the choice is between &#39;info&#39;</span>
<span class="sd">        (or ``verbose=True``) and warning (``verbose=False``).</span>

<span class="sd">        .. versionadded:: 0.2.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rem : :py:class:`yasa.REMResults`</span>
<span class="sd">        To get the full detection dataframe, use:</span>

<span class="sd">        &gt;&gt;&gt; rem = rem_detect(...)</span>
<span class="sd">        &gt;&gt;&gt; rem.summary()</span>

<span class="sd">        This will give a :py:class:`pandas.DataFrame` where each row is a</span>
<span class="sd">        detected REM and each column is a parameter (= property).</span>
<span class="sd">        To get the average parameters sleep stage:</span>

<span class="sd">        &gt;&gt;&gt; rem.summary(grp_stage=True)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The parameters that are calculated for each REM are:</span>

<span class="sd">    * ``&#39;Start&#39;``: Start of each detected REM, in seconds from the</span>
<span class="sd">      beginning of data.</span>
<span class="sd">    * ``&#39;Peak&#39;``: Location of the peak (in seconds of data)</span>
<span class="sd">    * ``&#39;End&#39;``: End time (in seconds)</span>
<span class="sd">    * ``&#39;Duration&#39;``: Duration (in seconds)</span>
<span class="sd">    * ``&#39;LOCAbsValPeak&#39;``: LOC absolute amplitude at REM peak (in uV)</span>
<span class="sd">    * ``&#39;ROCAbsValPeak&#39;``: ROC absolute amplitude at REM peak (in uV)</span>
<span class="sd">    * ``&#39;LOCAbsRiseSlope&#39;``: LOC absolute rise slope (in uV/s)</span>
<span class="sd">    * ``&#39;ROCAbsRiseSlope&#39;``: ROC absolute rise slope (in uV/s)</span>
<span class="sd">    * ``&#39;LOCAbsFallSlope&#39;``: LOC absolute fall slope (in uV/s)</span>
<span class="sd">    * ``&#39;ROCAbsFallSlope&#39;``: ROC absolute fall slope (in uV/s)</span>
<span class="sd">    * ``&#39;Stage&#39;``: Sleep stage (only if hypno was provided)</span>

<span class="sd">    Note that all the output parameters are computed on the filtered LOC and</span>
<span class="sd">    ROC signals.</span>

<span class="sd">    For better results, apply this detection only on artefact-free REM sleep.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    The rapid eye movements detection algorithm is based on:</span>

<span class="sd">    * Agarwal, R., Takeuchi, T., Laroche, S., &amp; Gotman, J. (2005).</span>
<span class="sd">      `Detection of rapid-eye movements in sleep studies.</span>
<span class="sd">      &lt;https://doi.org/10.1109/TBME.2005.851512&gt;`_</span>
<span class="sd">      IEEE Transactions on Bio-Medical Engineering, 52(8), 13901396.</span>

<span class="sd">    * Yetton, B. D., Niknazar, M., Duggan, K. A., McDevitt, E. A., Whitehurst,</span>
<span class="sd">      L. N., Sattari, N., &amp; Mednick, S. C. (2016). `Automatic detection of</span>
<span class="sd">      rapid eye movements (REMs): A machine learning approach.</span>
<span class="sd">      &lt;https://doi.org/10.1016/j.jneumeth.2015.11.015&gt;`_</span>
<span class="sd">      Journal of Neuroscience Methods, 259, 7282.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    For an example of how to run the detection, please refer to</span>
<span class="sd">    https://github.com/raphaelvallat/yasa/blob/master/notebooks/07_REMs_detection.ipynb</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">set_log_level</span><span class="p">(</span><span class="n">verbose</span><span class="p">)</span>
    <span class="c1"># Safety checks</span>
    <span class="n">loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span>
    <span class="n">roc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">roc</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span>
    <span class="k">assert</span> <span class="n">loc</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;LOC must be 1D.&#39;</span>
    <span class="k">assert</span> <span class="n">roc</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;ROC must be 1D.&#39;</span>
    <span class="k">assert</span> <span class="n">loc</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">roc</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="s1">&#39;LOC and ROC must have the same size.&#39;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">loc</span><span class="p">,</span> <span class="n">roc</span><span class="p">))</span>

    <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">ch_names</span><span class="p">,</span> <span class="n">hypno</span><span class="p">,</span> <span class="n">include</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">n_chan</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">,</span> <span class="n">bad_chan</span>
     <span class="p">)</span> <span class="o">=</span> <span class="n">_check_data_hypno</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;LOC&#39;</span><span class="p">,</span> <span class="s1">&#39;ROC&#39;</span><span class="p">],</span> <span class="n">hypno</span><span class="p">,</span> <span class="n">include</span><span class="p">)</span>

    <span class="c1"># If all channels are bad</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">bad_chan</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;At least one channel has bad amplitude. &#39;</span>
                       <span class="s1">&#39;Returning None.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Bandpass filter</span>
    <span class="n">data_filt</span> <span class="o">=</span> <span class="n">filter_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">freq_rem</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">freq_rem</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Calculate the negative product of LOC and ROC, maximal during REM.</span>
    <span class="n">negp</span> <span class="o">=</span> <span class="o">-</span><span class="n">data_filt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">data_filt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>

    <span class="c1"># Find peaks in data</span>
    <span class="c1"># - height: required height of peaks (min and max.)</span>
    <span class="c1"># - distance: required distance in samples between neighboring peaks.</span>
    <span class="c1"># - prominence: required prominence of peaks.</span>
    <span class="c1"># - wlen: limit search for bases to a specific window.</span>
    <span class="n">hmin</span><span class="p">,</span> <span class="n">hmax</span> <span class="o">=</span> <span class="n">amplitude</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">amplitude</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">pks</span><span class="p">,</span> <span class="n">pks_params</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">find_peaks</span><span class="p">(</span><span class="n">negp</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="p">(</span><span class="n">hmin</span><span class="p">,</span> <span class="n">hmax</span><span class="p">),</span> <span class="n">distance</span><span class="o">=</span><span class="p">(</span><span class="n">duration</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">sf</span><span class="p">),</span>
                                        <span class="n">prominence</span><span class="o">=</span><span class="p">(</span><span class="mf">0.8</span> <span class="o">*</span> <span class="n">hmin</span><span class="p">),</span> <span class="n">wlen</span><span class="o">=</span><span class="p">(</span><span class="n">duration</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">sf</span><span class="p">))</span>

    <span class="c1"># Intersect with sleep stage vector</span>
    <span class="c1"># We do that before calculating the features in order to gain some time</span>
    <span class="n">idx_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">pks</span><span class="p">,</span> <span class="n">idx_good</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">pks</span><span class="p">,</span> <span class="n">idx_mask</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">pks_params</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">pks_params</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">pks_params</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">idx_good</span><span class="p">]</span>

    <span class="c1"># If no peaks are detected, return None</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pks</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;No REMs were found in data. Returning None.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Hypnogram</span>
    <span class="k">if</span> <span class="n">hypno</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># The sleep stage at the beginning of the REM is considered.</span>
        <span class="n">rem_sta</span> <span class="o">=</span> <span class="n">hypno</span><span class="p">[</span><span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;left_bases&#39;</span><span class="p">]]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">rem_sta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">pks</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1"># Calculate time features</span>
    <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;Start&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;left_bases&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">sf</span>
    <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;Peak&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pks</span> <span class="o">/</span> <span class="n">sf</span>
    <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;End&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;right_bases&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">sf</span>
    <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;Duration&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;End&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;Start&#39;</span><span class="p">]</span>
    <span class="c1"># Time points in minutes (HH:MM:SS)</span>
    <span class="c1"># pks_params[&#39;StartMin&#39;] = pd.to_timedelta(pks_params[&#39;Start&#39;], unit=&#39;s&#39;).dt.round(&#39;s&#39;)  # noqa</span>
    <span class="c1"># pks_params[&#39;PeakMin&#39;] = pd.to_timedelta(pks_params[&#39;Peak&#39;], unit=&#39;s&#39;).dt.round(&#39;s&#39;)  # noqa</span>
    <span class="c1"># pks_params[&#39;EndMin&#39;] = pd.to_timedelta(pks_params[&#39;End&#39;], unit=&#39;s&#39;).dt.round(&#39;s&#39;)  # noqa</span>
    <span class="c1"># Absolute LOC / ROC value at peak (filtered)</span>
    <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;LOCAbsValPeak&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">data_filt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">pks</span><span class="p">])</span>
    <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;ROCAbsValPeak&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">data_filt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">pks</span><span class="p">])</span>
    <span class="c1"># Absolute rising and falling slope</span>
    <span class="n">dist_pk_left</span> <span class="o">=</span> <span class="p">(</span><span class="n">pks</span> <span class="o">-</span> <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;left_bases&#39;</span><span class="p">])</span> <span class="o">/</span> <span class="n">sf</span>
    <span class="n">dist_pk_right</span> <span class="o">=</span> <span class="p">(</span><span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;right_bases&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">pks</span><span class="p">)</span> <span class="o">/</span> <span class="n">sf</span>
    <span class="n">locrs</span> <span class="o">=</span> <span class="p">(</span><span class="n">data_filt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">pks</span><span class="p">]</span> <span class="o">-</span> <span class="n">data_filt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;left_bases&#39;</span><span class="p">]])</span> <span class="o">/</span> <span class="n">dist_pk_left</span>
    <span class="n">rocrs</span> <span class="o">=</span> <span class="p">(</span><span class="n">data_filt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">pks</span><span class="p">]</span> <span class="o">-</span> <span class="n">data_filt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;left_bases&#39;</span><span class="p">]])</span> <span class="o">/</span> <span class="n">dist_pk_left</span>
    <span class="n">locfs</span> <span class="o">=</span> <span class="p">(</span><span class="n">data_filt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;right_bases&#39;</span><span class="p">]]</span> <span class="o">-</span> <span class="n">data_filt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">pks</span><span class="p">])</span> <span class="o">/</span> <span class="n">dist_pk_right</span>
    <span class="n">rocfs</span> <span class="o">=</span> <span class="p">(</span><span class="n">data_filt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;right_bases&#39;</span><span class="p">]]</span> <span class="o">-</span> <span class="n">data_filt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">pks</span><span class="p">])</span> <span class="o">/</span> <span class="n">dist_pk_right</span>
    <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;LOCAbsRiseSlope&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">locrs</span><span class="p">)</span>
    <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;ROCAbsRiseSlope&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">rocrs</span><span class="p">)</span>
    <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;LOCAbsFallSlope&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">locfs</span><span class="p">)</span>
    <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;ROCAbsFallSlope&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">rocfs</span><span class="p">)</span>
    <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;Stage&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rem_sta</span>  <span class="c1"># Sleep stage</span>

    <span class="c1"># Convert to Pandas DataFrame</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">pks_params</span><span class="p">)</span>

    <span class="c1"># Make sure that the sign of ROC and LOC is opposite</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;IsOppositeSign&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">data_filt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">pks</span><span class="p">])</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">data_filt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">pks</span><span class="p">]))</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">data_filt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">pks</span><span class="p">])</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">data_filt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">pks</span><span class="p">])]</span>

    <span class="c1"># Remove bad duration</span>
    <span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span> <span class="o">=</span> <span class="n">duration</span>
    <span class="n">good_dur</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;Duration&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">tmin</span><span class="p">,</span> <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;Duration&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tmax</span><span class="p">)</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">good_dur</span><span class="p">]</span>

    <span class="c1"># Keep only useful channels</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="s1">&#39;Start&#39;</span><span class="p">,</span> <span class="s1">&#39;Peak&#39;</span><span class="p">,</span> <span class="s1">&#39;End&#39;</span><span class="p">,</span> <span class="s1">&#39;Duration&#39;</span><span class="p">,</span> <span class="s1">&#39;LOCAbsValPeak&#39;</span><span class="p">,</span> <span class="s1">&#39;ROCAbsValPeak&#39;</span><span class="p">,</span>
             <span class="s1">&#39;LOCAbsRiseSlope&#39;</span><span class="p">,</span> <span class="s1">&#39;ROCAbsRiseSlope&#39;</span><span class="p">,</span> <span class="s1">&#39;LOCAbsFallSlope&#39;</span><span class="p">,</span> <span class="s1">&#39;ROCAbsFallSlope&#39;</span><span class="p">,</span> <span class="s1">&#39;Stage&#39;</span><span class="p">]]</span>

    <span class="k">if</span> <span class="n">hypno</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Stage&#39;</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;Stage&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;Stage&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="c1"># We need at least 50 detected REMs to apply the Isolation Forest.</span>
    <span class="k">if</span> <span class="n">remove_outliers</span> <span class="ow">and</span> <span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">50</span><span class="p">:</span>
        <span class="n">col_keep</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Duration&#39;</span><span class="p">,</span> <span class="s1">&#39;LOCAbsValPeak&#39;</span><span class="p">,</span> <span class="s1">&#39;ROCAbsValPeak&#39;</span><span class="p">,</span> <span class="s1">&#39;LOCAbsRiseSlope&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;ROCAbsRiseSlope&#39;</span><span class="p">,</span> <span class="s1">&#39;LOCAbsFallSlope&#39;</span><span class="p">,</span> <span class="s1">&#39;ROCAbsFallSlope&#39;</span><span class="p">]</span>
        <span class="n">ilf</span> <span class="o">=</span> <span class="n">IsolationForest</span><span class="p">(</span><span class="n">contamination</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">max_samples</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span>
                              <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
        <span class="n">good</span> <span class="o">=</span> <span class="n">ilf</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">col_keep</span><span class="p">])</span>
        <span class="n">good</span><span class="p">[</span><span class="n">good</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%i</span><span class="s1"> outliers were removed.&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">good</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
        <span class="c1"># Remove outliers from DataFrame</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">good</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)]</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%i</span><span class="s1"> REMs were found in data.&#39;</span><span class="p">,</span> <span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">REMResults</span><span class="p">(</span><span class="n">events</span><span class="o">=</span><span class="n">df</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="o">=</span><span class="n">sf</span><span class="p">,</span> <span class="n">ch_names</span><span class="o">=</span><span class="n">ch_names</span><span class="p">,</span>
                      <span class="n">hypno</span><span class="o">=</span><span class="n">hypno</span><span class="p">,</span> <span class="n">data_filt</span><span class="o">=</span><span class="n">data_filt</span><span class="p">)</span></div>


<div class="viewcode-block" id="REMResults"><a class="viewcode-back" href="../../generated/yasa.REMResults.html#yasa.REMResults">[docs]</a><span class="k">class</span> <span class="nc">REMResults</span><span class="p">(</span><span class="n">_DetectionResults</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Output class for REMs detection.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    _events : :py:class:`pandas.DataFrame`</span>
<span class="sd">        Output detection dataframe</span>
<span class="sd">    _data : array_like</span>
<span class="sd">        EOG data of shape *(n_chan, n_samples)*, where the two channels are</span>
<span class="sd">        LOC and ROC.</span>
<span class="sd">    _data_filt : array_like</span>
<span class="sd">        Filtered EOG data of shape *(n_chan, n_samples)*, where the two</span>
<span class="sd">        channels are LOC and ROC.</span>
<span class="sd">    _sf : float</span>
<span class="sd">        Sampling frequency of data.</span>
<span class="sd">    _ch_names : list</span>
<span class="sd">        Channel names (= ``[&#39;LOC&#39;, &#39;ROC&#39;]``)</span>
<span class="sd">    _hypno : array_like or None</span>
<span class="sd">        Sleep staging vector.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="REMResults.__init__"><a class="viewcode-back" href="../../generated/yasa.REMResults.html#yasa.REMResults.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">ch_names</span><span class="p">,</span> <span class="n">hypno</span><span class="p">,</span> <span class="n">data_filt</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">events</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">ch_names</span><span class="p">,</span> <span class="n">hypno</span><span class="p">,</span> <span class="n">data_filt</span><span class="p">)</span></div>

<div class="viewcode-block" id="REMResults.summary"><a class="viewcode-back" href="../../generated/yasa.REMResults.html#yasa.REMResults.summary">[docs]</a>    <span class="k">def</span> <span class="nf">summary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grp_stage</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">aggfunc</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a summary of the REM detection, optionally grouped across stage.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        grp_stage : bool</span>
<span class="sd">            If True, group by sleep stage (provided that an hypnogram was</span>
<span class="sd">            used).</span>
<span class="sd">        mask : array_like or None</span>
<span class="sd">            Custom boolean mask. Only the detected events for which mask is True will be</span>
<span class="sd">            included in the summary. Default is None, i.e. no masking (all events are included).</span>
<span class="sd">        aggfunc : str or function</span>
<span class="sd">            Averaging function (e.g. ``&#39;mean&#39;`` or ``&#39;median&#39;``).</span>
<span class="sd">        sort : bool</span>
<span class="sd">            If True, sort group keys when grouping.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># ``grp_chan`` is always False for REM detection because the</span>
        <span class="c1"># REMs are always detected on a combination of LOC and ROC.</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">summary</span><span class="p">(</span><span class="n">event_type</span><span class="o">=</span><span class="s1">&#39;rem&#39;</span><span class="p">,</span> <span class="n">grp_chan</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">grp_stage</span><span class="o">=</span><span class="n">grp_stage</span><span class="p">,</span>
                               <span class="n">aggfunc</span><span class="o">=</span><span class="n">aggfunc</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="n">sort</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span></div>

<div class="viewcode-block" id="REMResults.get_mask"><a class="viewcode-back" href="../../generated/yasa.REMResults.html#yasa.REMResults.get_mask">[docs]</a>    <span class="k">def</span> <span class="nf">get_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a boolean array indicating for each sample in data if this</span>
<span class="sd">        sample is part of a detected event (True) or not (False).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We cannot use super() because &quot;Channel&quot; is not present in _events.</span>
        <span class="kn">from</span> <span class="nn">yasa.others</span> <span class="kn">import</span> <span class="n">_index_to_events</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">idx_ev</span> <span class="o">=</span> <span class="n">_index_to_events</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_events</span><span class="p">[[</span><span class="s1">&#39;Start&#39;</span><span class="p">,</span> <span class="s1">&#39;End&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sf</span><span class="p">)</span>
        <span class="n">mask</span><span class="p">[:,</span> <span class="n">idx_ev</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">mask</span></div>

<div class="viewcode-block" id="REMResults.get_sync_events"><a class="viewcode-back" href="../../generated/yasa.REMResults.html#yasa.REMResults.get_sync_events">[docs]</a>    <span class="k">def</span> <span class="nf">get_sync_events</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="s1">&#39;Peak&#39;</span><span class="p">,</span> <span class="n">time_before</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">time_after</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span>
                        <span class="n">filt</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the raw or filtered data of each detected event after centering to a specific</span>
<span class="sd">        timepoint.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        center : str</span>
<span class="sd">            Landmark of the event to synchronize the timing on.</span>
<span class="sd">            Default is to use the peak of the REM.</span>
<span class="sd">        time_before : float</span>
<span class="sd">            Time (in seconds) before ``center``.</span>
<span class="sd">        time_after : float</span>
<span class="sd">            Time (in seconds) after ``center``.</span>
<span class="sd">        filt : tuple</span>
<span class="sd">            Optional filtering to apply to data. For instance, ``filt=(1, 30)``</span>
<span class="sd">            will apply a 1 to 30 Hz bandpass filter, and ``filt=(None, 40)``</span>
<span class="sd">            will apply a 40 Hz lowpass filter. Filtering is done using default</span>
<span class="sd">            parameters in the :py:func:`mne.filter.filter_data` function.</span>
<span class="sd">        mask : array_like or None</span>
<span class="sd">            Custom boolean mask. Only the detected events for which mask is True will be</span>
<span class="sd">            included. Default is None, i.e. no masking (all events are included).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        df_sync : :py:class:`pandas.DataFrame`</span>
<span class="sd">            Ouput long-format dataframe::</span>

<span class="sd">            &#39;Event&#39; : Event number</span>
<span class="sd">            &#39;Time&#39; : Timing of the events (in seconds)</span>
<span class="sd">            &#39;Amplitude&#39; : Raw or filtered data for event</span>
<span class="sd">            &#39;Channel&#39; : Channel</span>
<span class="sd">            &#39;IdxChannel&#39; : Index of channel in data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">yasa.others</span> <span class="kn">import</span> <span class="n">get_centered_indices</span>
        <span class="k">assert</span> <span class="n">time_before</span> <span class="o">&gt;=</span> <span class="mi">0</span>
        <span class="k">assert</span> <span class="n">time_after</span> <span class="o">&gt;=</span> <span class="mi">0</span>
        <span class="n">bef</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sf</span> <span class="o">*</span> <span class="n">time_before</span><span class="p">)</span>
        <span class="n">aft</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sf</span> <span class="o">*</span> <span class="n">time_after</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">filt</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">filter_data</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sf</span><span class="p">,</span> <span class="n">l_freq</span><span class="o">=</span><span class="n">filt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">h_freq</span><span class="o">=</span><span class="n">filt</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;fir&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>

        <span class="c1"># Apply mask</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_mask</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
        <span class="n">masked_events</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_events</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="p">:]</span>

        <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">bef</span><span class="p">,</span> <span class="n">aft</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int&#39;</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sf</span>
        <span class="c1"># Get location of peaks in data</span>
        <span class="n">peaks</span> <span class="o">=</span> <span class="p">(</span><span class="n">masked_events</span><span class="p">[</span><span class="n">center</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sf</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="c1"># Get centered indices (here we could use second channel as well).</span>
        <span class="n">idx</span><span class="p">,</span> <span class="n">idx_valid</span> <span class="o">=</span> <span class="n">get_centered_indices</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">peaks</span><span class="p">,</span> <span class="n">bef</span><span class="p">,</span> <span class="n">aft</span><span class="p">)</span>
        <span class="c1"># If no good epochs are returned raise a warning</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx_valid</span><span class="p">),</span> <span class="p">(</span>
            <span class="s1">&#39;Time before and/or time after exceed data bounds, please &#39;</span>
            <span class="s1">&#39;lower the temporal window around center.&#39;</span><span class="p">)</span>

        <span class="c1"># Initialize empty dataframe</span>
        <span class="n">df_sync</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

        <span class="c1"># Loop across both EOGs (LOC and ROC)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ch</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ch_names</span><span class="p">):</span>
            <span class="n">amps</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span>
            <span class="n">df_chan</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">amps</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="n">df_chan</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span>
            <span class="n">df_chan</span> <span class="o">=</span> <span class="n">df_chan</span><span class="o">.</span><span class="n">melt</span><span class="p">(</span><span class="n">id_vars</span><span class="o">=</span><span class="s1">&#39;Time&#39;</span><span class="p">,</span> <span class="n">var_name</span><span class="o">=</span><span class="s1">&#39;Event&#39;</span><span class="p">,</span> <span class="n">value_name</span><span class="o">=</span><span class="s1">&#39;Amplitude&#39;</span><span class="p">)</span>
            <span class="n">df_chan</span><span class="p">[</span><span class="s1">&#39;Channel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ch</span>
            <span class="n">df_chan</span><span class="p">[</span><span class="s1">&#39;IdxChannel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">df_sync</span> <span class="o">=</span> <span class="n">df_sync</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df_chan</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">df_sync</span></div>

<div class="viewcode-block" id="REMResults.plot_average"><a class="viewcode-back" href="../../generated/yasa.REMResults.html#yasa.REMResults.plot_average">[docs]</a>    <span class="k">def</span> <span class="nf">plot_average</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="s1">&#39;Peak&#39;</span><span class="p">,</span> <span class="n">time_before</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">time_after</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">filt</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                     <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the average REM.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        center : str</span>
<span class="sd">            Landmark of the event to synchronize the timing on.</span>
<span class="sd">            Default is to use the peak of the REM.</span>
<span class="sd">        time_before : float</span>
<span class="sd">            Time (in seconds) before ``center``.</span>
<span class="sd">        time_after : float</span>
<span class="sd">            Time (in seconds) after ``center``.</span>
<span class="sd">        filt : tuple</span>
<span class="sd">            Optional filtering to apply to data. For instance, ``filt=(1, 30)``</span>
<span class="sd">            will apply a 1 to 30 Hz bandpass filter, and ``filt=(None, 40)``</span>
<span class="sd">            will apply a 40 Hz lowpass filter. Filtering is done using default</span>
<span class="sd">            parameters in the :py:func:`mne.filter.filter_data` function.</span>
<span class="sd">        mask : array_like or None</span>
<span class="sd">            Custom boolean mask. Only the detected events for which mask is True will be</span>
<span class="sd">            included. Default is None, i.e. no masking (all events are included).</span>
<span class="sd">        figsize : tuple</span>
<span class="sd">            Figure size in inches.</span>
<span class="sd">        **kwargs : dict</span>
<span class="sd">            Optional argument that are passed to :py:func:`seaborn.lineplot`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

        <span class="n">df_sync</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sync_events</span><span class="p">(</span><span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span> <span class="n">time_before</span><span class="o">=</span><span class="n">time_before</span><span class="p">,</span>
                                       <span class="n">time_after</span><span class="o">=</span><span class="n">time_after</span><span class="p">,</span> <span class="n">filt</span><span class="o">=</span><span class="n">filt</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>

        <span class="c1"># Start figure</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
        <span class="n">sns</span><span class="o">.</span><span class="n">lineplot</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">df_sync</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="s1">&#39;Time&#39;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s1">&#39;Amplitude&#39;</span><span class="p">,</span> <span class="n">hue</span><span class="o">=</span><span class="s1">&#39;Channel&#39;</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># ax.legend(frameon=False, loc=&#39;lower right&#39;)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">df_sync</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">df_sync</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Average REM&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time (sec)&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Amplitude (uV)&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ax</span></div></div>


<span class="c1">#############################################################################</span>
<span class="c1"># ARTEFACT DETECTION</span>
<span class="c1">#############################################################################</span>


<div class="viewcode-block" id="art_detect"><a class="viewcode-back" href="../../generated/yasa.art_detect.html#yasa.art_detect">[docs]</a><span class="k">def</span> <span class="nf">art_detect</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">hypno</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">include</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
               <span class="n">method</span><span class="o">=</span><span class="s1">&#39;covar&#39;</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_chan_reject</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Automatic artifact rejection.</span>

<span class="sd">    .. versionadded:: 0.2.0</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : array_like</span>
<span class="sd">        Single or multi-channel EEG data.</span>
<span class="sd">        Unit must be uV and shape *(n_chan, n_samples)*.</span>
<span class="sd">        Can also be a :py:class:`mne.io.BaseRaw`, in which case ``data``</span>
<span class="sd">        and ``sf`` will be automatically extracted,</span>
<span class="sd">        and ``data`` will also be automatically converted from Volts (MNE)</span>
<span class="sd">        to micro-Volts (YASA).</span>

<span class="sd">        .. warning::</span>
<span class="sd">            ``data`` must only contains EEG channels. Please make sure to</span>
<span class="sd">            exclude any EOG, EKG or EMG channels.</span>
<span class="sd">    sf : float</span>
<span class="sd">        Sampling frequency of the data in Hz.</span>
<span class="sd">        Can be omitted if ``data`` is a :py:class:`mne.io.BaseRaw` object.</span>
<span class="sd">    window : float</span>
<span class="sd">        The window length (= resolution) for artifact rejection, in seconds.</span>
<span class="sd">        Default to 5 seconds. Shorter windows (e.g. 1 or 2-seconds) will</span>
<span class="sd">        drastically increase computation time when ``method=&#39;covar&#39;``.</span>
<span class="sd">    hypno : array_like</span>
<span class="sd">        Sleep stage (hypnogram). If the hypnogram is passed, the</span>
<span class="sd">        detection will be applied separately for each of the stages defined in</span>
<span class="sd">        ``include``.</span>

<span class="sd">        The hypnogram must have the same number of samples as ``data``.</span>
<span class="sd">        To upsample your hypnogram, please refer to</span>
<span class="sd">        :py:func:`yasa.hypno_upsample_to_data`.</span>

<span class="sd">        .. note::</span>
<span class="sd">            The default hypnogram format in YASA is a 1D integer</span>
<span class="sd">            vector where:</span>

<span class="sd">            - -2 = Unscored</span>
<span class="sd">            - -1 = Artefact / Movement</span>
<span class="sd">            - 0 = Wake</span>
<span class="sd">            - 1 = N1 sleep</span>
<span class="sd">            - 2 = N2 sleep</span>
<span class="sd">            - 3 = N3 sleep</span>
<span class="sd">            - 4 = REM sleep</span>
<span class="sd">    include : tuple, list or int</span>
<span class="sd">        Sleep stages in ``hypno`` on which to perform the artifact rejection.</span>
<span class="sd">        The default is ``hypno=(1, 2, 3, 4)``, meaning that the artifact</span>
<span class="sd">        rejection is applied separately for all sleep stages, excluding wake.</span>
<span class="sd">        This parameter has no effect when ``hypno`` is None.</span>
<span class="sd">    method : str</span>
<span class="sd">        Artifact detection method (see Notes):</span>

<span class="sd">        * ``&#39;covar&#39;`` : Covariance-based, default for 4+ channels data</span>
<span class="sd">        * ``&#39;std&#39;`` : Standard-deviation-based, default for single-channel data</span>
<span class="sd">    threshold : float</span>
<span class="sd">        The number of standard deviations above or below which an</span>
<span class="sd">        epoch is considered an artifact. Higher values will result in a more</span>
<span class="sd">        conservative detection, i.e. less rejected epochs.</span>
<span class="sd">    n_chan_reject : int</span>
<span class="sd">        The number of channels that must be below or above ``threshold`` on any</span>
<span class="sd">        given epochs to consider this epoch as an artefact when</span>
<span class="sd">        ``method=&#39;std&#39;``. The default is 1, which means that the epoch will</span>
<span class="sd">        be marked as artifact as soon as one channel is above or below the</span>
<span class="sd">        threshold. This may be too conservative when working with a large</span>
<span class="sd">        number of channels (e.g.hdEEG) in which case users can increase</span>
<span class="sd">        ``n_chan_reject``. Note that this parameter only has an effect</span>
<span class="sd">        when ``method=&#39;std&#39;``.</span>
<span class="sd">    verbose : bool or str</span>
<span class="sd">        Verbose level. Default (False) will only print warning and error</span>
<span class="sd">        messages. The logging levels are &#39;debug&#39;, &#39;info&#39;, &#39;warning&#39;, &#39;error&#39;,</span>
<span class="sd">        and &#39;critical&#39;. For most users the choice is between &#39;info&#39;</span>
<span class="sd">        (or ``verbose=True``) and warning (``verbose=False``).</span>

<span class="sd">        .. versionadded:: 0.2.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    art_epochs : array_like</span>
<span class="sd">        1-D array of shape *(n_epochs)* where 1 = Artefact and 0 = Good.</span>
<span class="sd">    zscores : array_like</span>
<span class="sd">        Array of z-scores, shape is *(n_epochs)* if ``method=&#39;covar&#39;`` and</span>
<span class="sd">        *(n_epochs, n_chan)* if ``method=&#39;std&#39;``.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    .. caution::</span>
<span class="sd">        This function will only detect major body artefacts present on the EEG</span>
<span class="sd">        channel. It will not detect EKG contamination or eye blinks. For more</span>
<span class="sd">        artifact rejection tools, please refer to the `MNE Python package</span>
<span class="sd">        &lt;https://mne.tools/stable/auto_tutorials/preprocessing/plot_10_preprocessing_overview.html&gt;`_.</span>

<span class="sd">    .. tip::</span>
<span class="sd">        For best performance, apply this function on pre-staged data and make</span>
<span class="sd">        sure to pass the hypnogram.</span>
<span class="sd">        Sleep stages have very different EEG signatures</span>
<span class="sd">        and the artifect rejection will be much more accurate when applied</span>
<span class="sd">        separately on each sleep stage.</span>

<span class="sd">    We provide below a short description of the different methods. For</span>
<span class="sd">    multi-channel data, and if computation time is not an issue, we recommend</span>
<span class="sd">    using ``method=&#39;covar&#39;`` which uses a clustering approach on</span>
<span class="sd">    variance-covariance matrices, and therefore takes into account</span>
<span class="sd">    not only the variance in each channel and each epoch, but also the</span>
<span class="sd">    inter-relationship (covariance) between channel.</span>

<span class="sd">    ``method=&#39;covar&#39;`` is however not supported for single-channel EEG or when</span>
<span class="sd">    less than 4 channels are present in ``data``. In these cases, one can</span>
<span class="sd">    use the much faster ``method=&#39;std&#39;`` which is simply based on a z-scoring</span>
<span class="sd">    of the log-transformed standard deviation of each channel and each epoch.</span>

<span class="sd">    **1/ Covariance-based multi-channel artefact rejection**</span>

<span class="sd">    ``method=&#39;covar&#39;`` is essentially a wrapper around the</span>
<span class="sd">    :py:class:`pyriemann.clustering.Potato` class implemented in the</span>
<span class="sd">    `pyRiemann package</span>
<span class="sd">    &lt;https://pyriemann.readthedocs.io/en/latest/index.html&gt;`_.</span>

<span class="sd">    The main idea of this approach is to estimate a reference covariance</span>
<span class="sd">    matrix :math:`\bar{C}` (for each sleep stage separately if ``hypno`` is</span>
<span class="sd">    present) and reject every epoch which is too far from this reference</span>
<span class="sd">    matrix.</span>
<span class="sd">    The distance of the covariance matrix of the current epoch :math:`C`</span>
<span class="sd">    from the reference matrix is calculated using Riemannian</span>
<span class="sd">    geometry, which is more adapted than Euclidean geometry for</span>
<span class="sd">    symmetric positive definite covariance matrices:</span>

<span class="sd">    .. math::  d = {\left( \sum_i \log(\lambda_i)^2 \right)}^{-1/2}</span>

<span class="sd">    where :math:`\lambda_i` are the joint eigenvalues of :math:`C` and</span>
<span class="sd">    :math:`\bar{C}`. The epoch with covariance matric :math:`C`</span>
<span class="sd">    will be marked as an artifact if the distance :math:`d`</span>
<span class="sd">    is greater than a threshold :math:`T`</span>
<span class="sd">    (typically 2 or 3 standard deviations).</span>
<span class="sd">    :math:`\bar{C}` is iteratively estimated using a clustering approach.</span>

<span class="sd">    **2/ Standard-deviation-based single and multi-channel artefact rejection**</span>

<span class="sd">    ``method=&#39;std&#39;`` is a much faster and straightforward approach which</span>
<span class="sd">    is simply based on the distribution of the standard deviations of each</span>
<span class="sd">    epoch. Specifically, one first calculate the standard</span>
<span class="sd">    deviations of each epoch and each channel. Then, the resulting array of</span>
<span class="sd">    standard deviations is log-transformed and z-scored (for each sleep</span>
<span class="sd">    stage separately if ``hypno`` is present). Any epoch with one or more</span>
<span class="sd">    channel exceeding the threshold will be marked as artifact.</span>

<span class="sd">    Note that this approach is more sensitive to noise and/or the influence of</span>
<span class="sd">    one bad channel (e.g. electrode fell off at some point during the night).</span>
<span class="sd">    We therefore recommend that you visually inspect and remove any bad</span>
<span class="sd">    channels prior to using this function.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    * Barachant, A., Andreev, A., &amp; Congedo, M. (2013). `The Riemannian</span>
<span class="sd">      Potato: an automatic and adaptive artifact detection method for online</span>
<span class="sd">      experiments using Riemannian geometry.</span>
<span class="sd">      &lt;https://hal.archives-ouvertes.fr/hal-00781701/&gt;`_ TOBI</span>
<span class="sd">      Workshop lV, 1920.</span>

<span class="sd">    * Barthlemy, Q., Mayaud, L., Ojeda, D., &amp; Congedo, M. (2019).</span>
<span class="sd">      `The Riemannian Potato Field: A Tool for Online Signal Quality Index of</span>
<span class="sd">      EEG. &lt;https://doi.org/10.1109/TNSRE.2019.2893113&gt;`_</span>
<span class="sd">      IEEE Transactions on Neural Systems and Rehabilitation Engineering:</span>
<span class="sd">      A Publication of the IEEE Engineering in Medicine and Biology Society,</span>
<span class="sd">      27(2), 244255.</span>

<span class="sd">    * https://pyriemann.readthedocs.io/en/latest/index.html</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    For an example of how to run the detection, please refer to</span>
<span class="sd">    https://github.com/raphaelvallat/yasa/blob/master/notebooks/13_artifact_rejection.ipynb</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">###########################################################################</span>
    <span class="c1"># PREPROCESSING</span>
    <span class="c1">###########################################################################</span>
    <span class="n">set_log_level</span><span class="p">(</span><span class="n">verbose</span><span class="p">)</span>

    <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">hypno</span><span class="p">,</span> <span class="n">include</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">n_chan</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">,</span> <span class="n">_</span>
     <span class="p">)</span> <span class="o">=</span> <span class="n">_check_data_hypno</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">ch_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">hypno</span><span class="o">=</span><span class="n">hypno</span><span class="p">,</span> <span class="n">include</span><span class="o">=</span><span class="n">include</span><span class="p">,</span> <span class="n">check_amp</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n_chan_reject</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="s1">&#39;n_chan_reject must be int.&#39;</span>
    <span class="k">assert</span> <span class="n">n_chan_reject</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;n_chan_reject must be &gt;= 1.&#39;</span>
    <span class="k">assert</span> <span class="n">n_chan_reject</span> <span class="o">&lt;=</span> <span class="n">n_chan</span><span class="p">,</span> <span class="s1">&#39;n_chan_reject must be &lt;= n_chan.&#39;</span>

    <span class="c1"># Safety check: sampling frequency and window</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sf</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)),</span> <span class="s1">&#39;sf must be int or float&#39;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)),</span> <span class="s1">&#39;window must be int or float&#39;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sf</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">sf</span><span class="o">.</span><span class="n">is_integer</span><span class="p">(),</span> <span class="s1">&#39;sf must be a whole number.&#39;</span>
        <span class="n">sf</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sf</span><span class="p">)</span>
    <span class="n">win_sec</span> <span class="o">=</span> <span class="n">window</span>
    <span class="n">window</span> <span class="o">=</span> <span class="n">win_sec</span> <span class="o">*</span> <span class="n">sf</span>  <span class="c1"># Convert window to samples</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">window</span><span class="o">.</span><span class="n">is_integer</span><span class="p">(),</span> <span class="s1">&#39;window * sf must be a whole number.&#39;</span>
        <span class="n">window</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">window</span><span class="p">)</span>

    <span class="c1"># Safety check: hypnogram</span>
    <span class="k">if</span> <span class="n">hypno</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Extract hypnogram with only complete epochs</span>
        <span class="n">idx_max_full_epoch</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">n_samples</span> <span class="o">/</span> <span class="n">window</span><span class="p">))</span>
        <span class="n">hypno_win</span> <span class="o">=</span> <span class="n">hypno</span><span class="p">[::</span><span class="n">window</span><span class="p">][:</span><span class="n">idx_max_full_epoch</span><span class="p">]</span>

    <span class="c1"># Safety checks: methods</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="s2">&quot;method must be a string.&quot;</span>
    <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;cov&#39;</span><span class="p">,</span> <span class="s1">&#39;covar&#39;</span><span class="p">,</span> <span class="s1">&#39;covariance&#39;</span><span class="p">,</span> <span class="s1">&#39;riemann&#39;</span><span class="p">,</span> <span class="s1">&#39;potato&#39;</span><span class="p">]:</span>
        <span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;covar&#39;</span>
        <span class="n">is_pyriemann_installed</span><span class="p">()</span>
        <span class="kn">from</span> <span class="nn">pyriemann.estimation</span> <span class="kn">import</span> <span class="n">Covariances</span><span class="p">,</span> <span class="n">Shrinkage</span>
        <span class="kn">from</span> <span class="nn">pyriemann.clustering</span> <span class="kn">import</span> <span class="n">Potato</span>
        <span class="c1"># Must have at least 4 channels to use method=&#39;covar&#39;</span>
        <span class="k">if</span> <span class="n">n_chan</span> <span class="o">&lt;=</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Must have at least 4 channels for method=&#39;covar&#39;. &quot;</span>
                           <span class="s2">&quot;Automatically switching to method=&#39;std&#39;.&quot;</span><span class="p">)</span>
            <span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;std&#39;</span>

    <span class="c1">###########################################################################</span>
    <span class="c1"># START THE REJECTION</span>
    <span class="c1">###########################################################################</span>
    <span class="c1"># Remove flat channels</span>
    <span class="n">isflat</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">isflat</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Flat channel(s) were found and removed in data.&#39;</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="o">~</span><span class="n">isflat</span><span class="p">]</span>
        <span class="n">n_chan</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Epoch the data (n_epochs, n_chan, n_samples)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">epochs</span> <span class="o">=</span> <span class="n">sliding_window</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">win_sec</span><span class="p">)</span>
    <span class="n">n_epochs</span> <span class="o">=</span> <span class="n">epochs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># We first need to identify epochs with flat data (n_epochs, n_chan)</span>
    <span class="n">isflat</span> <span class="o">=</span> <span class="p">(</span><span class="n">epochs</span> <span class="o">==</span> <span class="n">epochs</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">][</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># 1 when all channels are flat, 0 when none ar flat (n_epochs)</span>
    <span class="n">prop_chan_flat</span> <span class="o">=</span> <span class="n">isflat</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">n_chan</span>
    <span class="c1"># If &gt;= 50% of channels are flat, automatically mark as artefact</span>
    <span class="n">epoch_is_flat</span> <span class="o">=</span> <span class="n">prop_chan_flat</span> <span class="o">&gt;=</span> <span class="mf">0.5</span>
    <span class="n">where_flat_epochs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">epoch_is_flat</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">n_flat_epochs</span> <span class="o">=</span> <span class="n">where_flat_epochs</span><span class="o">.</span><span class="n">size</span>

    <span class="c1"># Now let&#39;s make sure that we have an hypnogram and an include variable</span>
    <span class="k">if</span> <span class="s1">&#39;hypno_win&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">locals</span><span class="p">():</span>
        <span class="c1"># [-2, -2, -2, -2, ...], where -2 stands for unscored</span>
        <span class="n">hypno_win</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_epochs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">)</span>
        <span class="n">include</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">)</span>

    <span class="c1"># We want to make sure that hypno-win and n_epochs have EXACTLY same shape</span>
    <span class="k">assert</span> <span class="n">n_epochs</span> <span class="o">==</span> <span class="n">hypno_win</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;Hypno and epochs do not match.&#39;</span>

    <span class="c1"># Finally, we make sure not to include any flat epochs in calculation</span>
    <span class="c1"># just using a random number that is unlikely to be picked by users</span>
    <span class="k">if</span> <span class="n">n_flat_epochs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">hypno_win</span><span class="p">[</span><span class="n">where_flat_epochs</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">111991</span>

    <span class="c1"># Add logger info</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Number of channels in data = </span><span class="si">%i</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">n_chan</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Number of samples in data = </span><span class="si">%i</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Sampling frequency = </span><span class="si">%.2f</span><span class="s1"> Hz&#39;</span><span class="p">,</span> <span class="n">sf</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Data duration = </span><span class="si">%.2f</span><span class="s1"> seconds&#39;</span><span class="p">,</span> <span class="n">n_samples</span> <span class="o">/</span> <span class="n">sf</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Number of epochs = </span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">n_epochs</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Artifact window = </span><span class="si">%.2f</span><span class="s1"> seconds&#39;</span> <span class="o">%</span> <span class="n">win_sec</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Method = </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">method</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Threshold = </span><span class="si">%.2f</span><span class="s1"> standard deviations&#39;</span> <span class="o">%</span> <span class="n">threshold</span><span class="p">)</span>

    <span class="c1"># Create empty `hypno_art` vector (1 sample = 1 epoch)</span>
    <span class="n">epoch_is_art</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_epochs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;covar&#39;</span><span class="p">:</span>
        <span class="c1"># Calculate the covariance matrices,</span>
        <span class="c1"># shape (n_epochs, n_chan, n_chan)</span>
        <span class="n">covmats</span> <span class="o">=</span> <span class="n">Covariances</span><span class="p">()</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">epochs</span><span class="p">)</span>
        <span class="c1"># Shrink the covariance matrix (ensure positive semi-definite)</span>
        <span class="n">covmats</span> <span class="o">=</span> <span class="n">Shrinkage</span><span class="p">()</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">covmats</span><span class="p">)</span>
        <span class="c1"># Define Potato instance: 0 = clean, 1 = art</span>
        <span class="c1"># To increase speed we set the max number of iterations from 10 to 100</span>
        <span class="n">potato</span> <span class="o">=</span> <span class="n">Potato</span><span class="p">(</span><span class="n">metric</span><span class="o">=</span><span class="s1">&#39;riemann&#39;</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span> <span class="n">pos_label</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                        <span class="n">neg_label</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_iter_max</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
        <span class="c1"># Create empty z-scores output (n_epochs)</span>
        <span class="n">zscores</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_epochs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="k">for</span> <span class="n">stage</span> <span class="ow">in</span> <span class="n">include</span><span class="p">:</span>
            <span class="n">where_stage</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">hypno_win</span> <span class="o">==</span> <span class="n">stage</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># At least 30 epochs are required to calculate z-scores</span>
            <span class="c1"># which amounts to 2.5 minutes when using 5-seconds window</span>
            <span class="k">if</span> <span class="n">where_stage</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">30</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">hypno</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># Only show warnig if user actually pass an hypnogram</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;At least 30 epochs are required to &quot;</span>
                                   <span class="sa">f</span><span class="s2">&quot;calculate z-score. Skipping &quot;</span>
                                   <span class="sa">f</span><span class="s2">&quot;stage </span><span class="si">{</span><span class="n">stage</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="c1"># Apply Potato algorithm, extract z-scores and labels</span>
            <span class="n">zs</span> <span class="o">=</span> <span class="n">potato</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">covmats</span><span class="p">[</span><span class="n">where_stage</span><span class="p">])</span>
            <span class="n">art</span> <span class="o">=</span> <span class="n">potato</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">covmats</span><span class="p">[</span><span class="n">where_stage</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">hypno</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Only shows if user actually pass an hypnogram</span>
                <span class="n">perc_reject</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="p">(</span><span class="n">art</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">art</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
                <span class="n">text</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Stage </span><span class="si">{</span><span class="n">stage</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">art</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="si">}</span><span class="s2"> / </span><span class="si">{</span><span class="n">art</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s2"> &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;epochs rejected (</span><span class="si">{</span><span class="n">perc_reject</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">%)&quot;</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
            <span class="c1"># Append to global vector</span>
            <span class="n">epoch_is_art</span><span class="p">[</span><span class="n">where_stage</span><span class="p">]</span> <span class="o">=</span> <span class="n">art</span>
            <span class="n">zscores</span><span class="p">[</span><span class="n">where_stage</span><span class="p">]</span> <span class="o">=</span> <span class="n">zs</span>

    <span class="k">elif</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;std&#39;</span><span class="p">,</span> <span class="s1">&#39;sd&#39;</span><span class="p">]:</span>
        <span class="c1"># Calculate log-transformed standard dev in each epoch</span>
        <span class="c1"># We add 1 to avoid log warning id std is zero (e.g. flat line)</span>
        <span class="c1"># (n_epochs, n_chan)</span>
        <span class="n">std_epochs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">epochs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Create empty zscores output (n_epochs, n_chan)</span>
        <span class="n">zscores</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_epochs</span><span class="p">,</span> <span class="n">n_chan</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">for</span> <span class="n">stage</span> <span class="ow">in</span> <span class="n">include</span><span class="p">:</span>
            <span class="n">where_stage</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">hypno_win</span> <span class="o">==</span> <span class="n">stage</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># At least 30 epochs are required to calculate z-scores</span>
            <span class="c1"># which amounts to 2.5 minutes when using 5-seconds window</span>
            <span class="k">if</span> <span class="n">where_stage</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">30</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">hypno</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># Only show warnig if user actually pass an hypnogram</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;At least 30 epochs are required to &quot;</span>
                                   <span class="sa">f</span><span class="s2">&quot;calculate z-score. Skipping &quot;</span>
                                   <span class="sa">f</span><span class="s2">&quot;stage </span><span class="si">{</span><span class="n">stage</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="c1"># Calculate z-scores of STD for each channel x stage</span>
            <span class="n">c_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">std_epochs</span><span class="p">[</span><span class="n">where_stage</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">c_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">std_epochs</span><span class="p">[</span><span class="n">where_stage</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">zs</span> <span class="o">=</span> <span class="p">(</span><span class="n">std_epochs</span><span class="p">[</span><span class="n">where_stage</span><span class="p">]</span> <span class="o">-</span> <span class="n">c_mean</span><span class="p">)</span> <span class="o">/</span> <span class="n">c_std</span>
            <span class="c1"># Any epoch with at least X channel above or below threshold</span>
            <span class="n">n_chan_supra</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">zs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># &gt;</span>
            <span class="n">art</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_chan_supra</span> <span class="o">&gt;=</span> <span class="n">n_chan_reject</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>  <span class="c1"># &gt;= !</span>
            <span class="k">if</span> <span class="n">hypno</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Only shows if user actually pass an hypnogram</span>
                <span class="n">perc_reject</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="p">(</span><span class="n">art</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">art</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
                <span class="n">text</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Stage </span><span class="si">{</span><span class="n">stage</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">art</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="si">}</span><span class="s2"> / </span><span class="si">{</span><span class="n">art</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s2"> &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;epochs rejected (</span><span class="si">{</span><span class="n">perc_reject</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">%)&quot;</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
            <span class="c1"># Append to global vector</span>
            <span class="n">epoch_is_art</span><span class="p">[</span><span class="n">where_stage</span><span class="p">]</span> <span class="o">=</span> <span class="n">art</span>
            <span class="n">zscores</span><span class="p">[</span><span class="n">where_stage</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">zs</span>

    <span class="c1"># Mark flat epochs as artefacts</span>
    <span class="k">if</span> <span class="n">n_flat_epochs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Rejecting </span><span class="si">{</span><span class="n">n_flat_epochs</span><span class="si">}</span><span class="s2"> epochs with &gt;=50% of channels &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;that are flat. Z-scores set to np.nan for these epochs.&quot;</span><span class="p">)</span>
        <span class="n">epoch_is_art</span><span class="p">[</span><span class="n">where_flat_epochs</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1"># Log total percentage of epochs rejected</span>
    <span class="n">perc_reject</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="p">(</span><span class="n">epoch_is_art</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">n_epochs</span><span class="p">)</span>
    <span class="n">text</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;TOTAL: </span><span class="si">{</span><span class="n">epoch_is_art</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="si">}</span><span class="s2"> / </span><span class="si">{</span><span class="n">n_epochs</span><span class="si">}</span><span class="s2"> epochs rejected (</span><span class="si">{</span><span class="n">perc_reject</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">%)&quot;</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>

    <span class="c1"># Convert epoch_is_art to boolean [0, 0, 1] -- &gt; [False, False, True]</span>
    <span class="n">epoch_is_art</span> <span class="o">=</span> <span class="n">epoch_is_art</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">epoch_is_art</span><span class="p">,</span> <span class="n">zscores</span></div>
</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
      
    </p>
    <p>
        &copy; Copyright 2018-2022, Dr. Raphael Vallat, Center for Human Sleep Science, UC Berkeley.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.0.0.<br/>
    </p>
  </div>
</footer>
  </body>
</html>